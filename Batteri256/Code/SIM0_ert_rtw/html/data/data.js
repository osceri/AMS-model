var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"model/SIM","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include <stddef.h>\r\n#include <stdio.h>\r\n#include \"SIM0.h\"\r\n\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(SIM0_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n  SIM0_step();\r\n  OverrunFlag = false;\r\n}\r\n\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  (void)(argc);\r\n  (void)(argv);\r\n  SIM0_initialize();\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(SIM0_M) == (NULL)) {\r\n  }\r\n\r\n  SIM0_terminate();\r\n  return 0;\r\n}\r\n"},{"name":"SIM0.c","type":"source","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Model files","code":"#include \"SIM0.h\"\r\n#include <math.h>\r\n#include <string.h>\r\n#include \"rtwtypes.h\"\r\n#include <stddef.h>\r\n#include \"look1_binlxpw.h\"\r\n\r\nB_SIM0_T SIM0_B;\r\nDW_SIM0_T SIM0_DW;\r\nExtU_SIM0_T SIM0_U;\r\nExtY_SIM0_T SIM0_Y;\r\nstatic RT_MODEL_SIM0_T SIM0_M_;\r\nRT_MODEL_SIM0_T *const SIM0_M = &SIM0_M_;\r\nvoid SIM0_step(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  NeuDiagnosticTree *diagnosticTree_0;\r\n  NeuDiagnosticTree *diagnosticTree_1;\r\n  NeuDiagnosticTree *diagnosticTree_2;\r\n  NeuDiagnosticTree *diagnosticTree_3;\r\n  real_T rtb_Memory15[126];\r\n  real_T rtb_Memory21[126];\r\n  real_T rtb_Rpz[126];\r\n  real_T rtb_Rsz[126];\r\n  real_T rtb_Switch[126];\r\n  real_T rtb_tauz[126];\r\n  real_T tmp_1[65];\r\n  real_T tmp_3[65];\r\n  real_T tmp_5[65];\r\n  real_T tmp[32];\r\n  real_T tmp_7[32];\r\n  real_T rtb_Add2;\r\n  real_T rtb_Current;\r\n  real_T rtb_Exp;\r\n  real_T rtb_Memory20;\r\n  real_T rtb_OUTPUT_1_0;\r\n  real_T rtb_Product9;\r\n  real_T rtb_is_charge;\r\n  real_T rtb_is_drive;\r\n  real_T time;\r\n  real_T time_0;\r\n  real_T time_1;\r\n  real_T time_2;\r\n  real_T time_3;\r\n  real_T time_4;\r\n  real_T time_5;\r\n  real_T time_6;\r\n  real_T time_7;\r\n  real_T y;\r\n  int32_T i;\r\n  int32_T isHit;\r\n  int32_T isHit_0;\r\n  int32_T isHit_1;\r\n  int32_T isHit_2;\r\n  int_T tmp_2[10];\r\n  int_T tmp_4[10];\r\n  int_T tmp_6[10];\r\n  int_T tmp_0[9];\r\n  int_T tmp_8[9];\r\n  boolean_T rtb_Logic_a_idx_0;\r\n  boolean_T rtb_Logic_idx_0;\r\n  boolean_T rtb_Logic_idx_1;\r\n  rtb_Memory20 = SIM0_DW.Memory20_PreviousInput;\r\n  rtb_Add2 = SIM0_DW.Memory9_PreviousInput;\r\n  rtb_Exp = exp(SIM0_P.Cap_det / (SIM0_P.C_r * 3600.0) *\r\n                SIM0_DW.Memory9_PreviousInput);\r\n  for (i = 0; i < 126; i++) {\r\n    rtb_Memory15[i] = SIM0_DW.Memory15_PreviousInput[i];\r\n    y = SIM0_DW.Memory_PreviousInput[i] / SIM0_DW.Memory10_PreviousInput[i];\r\n    rtb_is_charge = look1_binlxpw(y, SIM0_P.soc, SIM0_P.Rs, 12U);\r\n    rtb_is_drive = look1_binlxpw(y, SIM0_P.soc, SIM0_P.tau, 12U);\r\n    rtb_Current = rtb_is_charge * rtb_is_drive;\r\n    rtb_is_charge = (rtb_is_charge + look1_binlxpw(y, SIM0_P.soc, SIM0_P.Rp, 12U))\r\n      * SIM0_P.Ts;\r\n    rtb_is_charge = (((2.0 * rtb_Current + rtb_is_charge) * rtb_Memory20 +\r\n                      (rtb_is_charge - 2.0 * rtb_Current) *\r\n                      SIM0_DW.Memory11_PreviousInput) - (SIM0_P.Ts - 2.0 *\r\n      rtb_is_drive) * SIM0_DW.Memory12_PreviousInput[i]) / (2.0 * rtb_is_drive +\r\n      SIM0_P.Ts);\r\n    rtb_is_drive = rtb_is_charge + look1_binlxpw(y, SIM0_P.soc, SIM0_P.ocv, 12U);\r\n    SIM0_Y.cell_voltages[i] = rtb_is_drive;\r\n    SIM0_Y.cell_socs[i] = y;\r\n    SIM0_Y.cell_capacities[i] = SIM0_DW.Memory10_PreviousInput[i];\r\n    rtb_Memory21[i] = SIM0_DW.Memory10_PreviousInput[i] * rtb_Exp;\r\n    rtb_Rsz[i] = rtb_is_charge;\r\n    rtb_Rpz[i] = rtb_is_drive;\r\n  }\r\n\r\n  rtb_Exp = SIM0_P.Ts * rtb_Memory20;\r\n  for (i = 0; i < 126; i++) {\r\n    y = SIM0_DW.Memory21_PreviousInput[i] / SIM0_P.R_short\r\n      * SIM0_DW.Memory19_PreviousInput[i] * SIM0_P.Gain_Gain + (rtb_Exp +\r\n      SIM0_DW.Memory_PreviousInput[i]);\r\n    if (y < SIM0_P.Constant1_Value) {\r\n      rtb_tauz[i] = SIM0_P.Constant1_Value;\r\n    } else {\r\n      rtb_tauz[i] = y;\r\n    }\r\n\r\n    rtb_Switch[i] = y;\r\n  }\r\n\r\n  SIM0_B.INPUT_5_1_1[0] = 1.0;\r\n  rtb_is_charge = 0.0;\r\n  rtb_is_drive = 0.0;\r\n  if (SIM0_DW.Memory6_PreviousInput != 0.0) {\r\n    SIM0_B.INPUT_5_1_1[0] = 2.0;\r\n    rtb_is_charge = 1.0;\r\n  } else if (SIM0_DW.Memory7_PreviousInput != 0.0) {\r\n    SIM0_B.INPUT_5_1_1[0] = 3.0;\r\n    rtb_is_drive = 1.0;\r\n  }\r\n\r\n  y = rtb_Memory15[0];\r\n  for (i = 0; i < 125; i++) {\r\n    y += rtb_Memory15[i + 1];\r\n  }\r\n\r\n  if (SIM0_DW.Memory16_PreviousInput != 0.0) {\r\n    rtb_Current = SIM0_DW.Memory17_PreviousInput - y;\r\n    if (rtb_Current < 0.0) {\r\n      rtb_Current = 0.0;\r\n    }\r\n\r\n    if (SIM0_DW.Memory18_PreviousInput < rtb_Current) {\r\n      rtb_Current = SIM0_DW.Memory18_PreviousInput;\r\n    }\r\n  } else {\r\n    rtb_Current = 0.0;\r\n  }\r\n\r\n  i = (int32_T)(((((uint32_T)(SIM0_DW.Memory1_PreviousInput != 0.0) << 1) +\r\n                  (SIM0_DW.Memory2_PreviousInput != 0.0)) << 1) +\r\n                SIM0_DW.Memory_PreviousInput_e);\r\n  rtb_Logic_idx_0 = SIM0_P.Logic_table[(uint32_T)i];\r\n  rtb_Logic_idx_1 = SIM0_P.Logic_table[i + 8U];\r\n  i = (int32_T)(((((uint32_T)(SIM0_DW.Memory3_PreviousInput != 0.0) << 1) +\r\n                  (SIM0_DW.Memory4_PreviousInput != 0.0)) << 1) +\r\n                SIM0_DW.Memory_PreviousInput_m);\r\n  rtb_Logic_a_idx_0 = SIM0_P.Logic_table_f[(uint32_T)i];\r\n  rtb_Exp = (rtb_Logic_idx_1 ? (real_T)SIM0_P.Logic_table_f[i + 8U] : 0.0) *\r\n    SIM0_DW.Memory5_PreviousInput;\r\n  SIM0_Y.AIR_minus_closed = rtb_Exp * SIM0_DW.Delay3_DSTATE[0];\r\n  SIM0_Y.AIR_plus_closed = rtb_Exp * SIM0_DW.Delay2_DSTATE[0];\r\n  rtb_Product9 = SIM0_Y.AIR_minus_closed * SIM0_Y.AIR_plus_closed;\r\n  SIM0_B.INPUT_7_1_1[0] = rtb_is_charge * rtb_Current * rtb_Product9;\r\n  SIM0_B.INPUT_7_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_7_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_7_1_1_Discrete[0] = !(SIM0_B.INPUT_7_1_1[0] ==\r\n    SIM0_DW.INPUT_7_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_7_1_1_Discrete[1] = SIM0_B.INPUT_7_1_1[0];\r\n  SIM0_B.INPUT_7_1_1[0] = SIM0_DW.INPUT_7_1_1_Discrete[1];\r\n  SIM0_B.INPUT_7_1_1[3] = SIM0_DW.INPUT_7_1_1_Discrete[0];\r\n  rtb_is_charge = SIM0_DW.Memory22_PreviousInput;\r\n  SIM0_B.INPUT_8_1_1[0] = rtb_is_drive * rtb_is_charge * rtb_Product9;\r\n  SIM0_B.INPUT_8_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_8_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_8_1_1_Discrete[0] = !(SIM0_B.INPUT_8_1_1[0] ==\r\n    SIM0_DW.INPUT_8_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_8_1_1_Discrete[1] = SIM0_B.INPUT_8_1_1[0];\r\n  SIM0_B.INPUT_8_1_1[0] = SIM0_DW.INPUT_8_1_1_Discrete[1];\r\n  SIM0_B.INPUT_8_1_1[3] = SIM0_DW.INPUT_8_1_1_Discrete[0];\r\n  SIM0_B.INPUT_2_1_1[0] = y;\r\n  SIM0_B.INPUT_2_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_2_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_2_1_1_Discrete[0] = !(SIM0_B.INPUT_2_1_1[0] ==\r\n    SIM0_DW.INPUT_2_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_2_1_1_Discrete[1] = SIM0_B.INPUT_2_1_1[0];\r\n  SIM0_B.INPUT_2_1_1[0] = SIM0_DW.INPUT_2_1_1_Discrete[1];\r\n  SIM0_B.INPUT_2_1_1[3] = SIM0_DW.INPUT_2_1_1_Discrete[0];\r\n  SIM0_B.INPUT_1_1_1[0] = y;\r\n  SIM0_B.INPUT_1_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_1_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_1_1_1_Discrete[0] = !(SIM0_B.INPUT_1_1_1[0] ==\r\n    SIM0_DW.INPUT_1_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_1_1_1_Discrete[1] = SIM0_B.INPUT_1_1_1[0];\r\n  SIM0_B.INPUT_1_1_1[0] = SIM0_DW.INPUT_1_1_1_Discrete[1];\r\n  SIM0_B.INPUT_1_1_1[3] = SIM0_DW.INPUT_1_1_1_Discrete[0];\r\n  SIM0_Y.precharge_closed = rtb_Exp * SIM0_DW.Delay1_DSTATE;\r\n  SIM0_B.INPUT_3_1_1[0] = SIM0_Y.precharge_closed;\r\n  SIM0_B.INPUT_3_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_3_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_3_1_1_Discrete[0] = !(SIM0_B.INPUT_3_1_1[0] ==\r\n    SIM0_DW.INPUT_3_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_3_1_1_Discrete[1] = SIM0_B.INPUT_3_1_1[0];\r\n  SIM0_B.INPUT_3_1_1[0] = SIM0_DW.INPUT_3_1_1_Discrete[1];\r\n  SIM0_B.INPUT_3_1_1[3] = SIM0_DW.INPUT_3_1_1_Discrete[0];\r\n  SIM0_B.INPUT_4_1_1[0] = SIM0_Y.AIR_plus_closed;\r\n  SIM0_B.INPUT_4_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_4_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_4_1_1_Discrete[0] = !(SIM0_B.INPUT_4_1_1[0] ==\r\n    SIM0_DW.INPUT_4_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_4_1_1_Discrete[1] = SIM0_B.INPUT_4_1_1[0];\r\n  SIM0_B.INPUT_4_1_1[0] = SIM0_DW.INPUT_4_1_1_Discrete[1];\r\n  SIM0_B.INPUT_4_1_1[3] = SIM0_DW.INPUT_4_1_1_Discrete[0];\r\n  SIM0_B.INPUT_5_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_5_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_5_1_1_Discrete[0] = !(SIM0_B.INPUT_5_1_1[0] ==\r\n    SIM0_DW.INPUT_5_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_5_1_1_Discrete[1] = SIM0_B.INPUT_5_1_1[0];\r\n  SIM0_B.INPUT_5_1_1[0] = SIM0_DW.INPUT_5_1_1_Discrete[1];\r\n  SIM0_B.INPUT_5_1_1[3] = SIM0_DW.INPUT_5_1_1_Discrete[0];\r\n  SIM0_B.INPUT_6_1_1[0] = SIM0_Y.AIR_minus_closed;\r\n  SIM0_B.INPUT_6_1_1[1] = 0.0;\r\n  SIM0_B.INPUT_6_1_1[2] = 0.0;\r\n  SIM0_DW.INPUT_6_1_1_Discrete[0] = !(SIM0_B.INPUT_6_1_1[0] ==\r\n    SIM0_DW.INPUT_6_1_1_Discrete[1]);\r\n  SIM0_DW.INPUT_6_1_1_Discrete[1] = SIM0_B.INPUT_6_1_1[0];\r\n  SIM0_B.INPUT_6_1_1[0] = SIM0_DW.INPUT_6_1_1_Discrete[1];\r\n  SIM0_B.INPUT_6_1_1[3] = SIM0_DW.INPUT_6_1_1_Discrete[0];\r\n  simulationData = (NeslSimulationData *)SIM0_DW.STATE_1_SimData;\r\n  rtb_is_drive = ((SIM0_M->Timing.clockTick0) * 0.2);\r\n  time = rtb_is_drive;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 17;\r\n  simulationData->mData->mDiscStates.mX = &SIM0_DW.STATE_1_Discrete[0];\r\n  simulationData->mData->mModeVector.mN = 16;\r\n  simulationData->mData->mModeVector.mX = &SIM0_DW.STATE_1_Modes[0];\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_0[0] = 0;\r\n  tmp[0] = SIM0_B.INPUT_8_1_1[0];\r\n  tmp[1] = SIM0_B.INPUT_8_1_1[1];\r\n  tmp[2] = SIM0_B.INPUT_8_1_1[2];\r\n  tmp[3] = SIM0_B.INPUT_8_1_1[3];\r\n  tmp_0[1] = 4;\r\n  tmp[4] = SIM0_B.INPUT_7_1_1[0];\r\n  tmp[5] = SIM0_B.INPUT_7_1_1[1];\r\n  tmp[6] = SIM0_B.INPUT_7_1_1[2];\r\n  tmp[7] = SIM0_B.INPUT_7_1_1[3];\r\n  tmp_0[2] = 8;\r\n  tmp[8] = SIM0_B.INPUT_2_1_1[0];\r\n  tmp[9] = SIM0_B.INPUT_2_1_1[1];\r\n  tmp[10] = SIM0_B.INPUT_2_1_1[2];\r\n  tmp[11] = SIM0_B.INPUT_2_1_1[3];\r\n  tmp_0[3] = 12;\r\n  tmp[12] = SIM0_B.INPUT_1_1_1[0];\r\n  tmp[13] = SIM0_B.INPUT_1_1_1[1];\r\n  tmp[14] = SIM0_B.INPUT_1_1_1[2];\r\n  tmp[15] = SIM0_B.INPUT_1_1_1[3];\r\n  tmp_0[4] = 16;\r\n  tmp[16] = SIM0_B.INPUT_3_1_1[0];\r\n  tmp[17] = SIM0_B.INPUT_3_1_1[1];\r\n  tmp[18] = SIM0_B.INPUT_3_1_1[2];\r\n  tmp[19] = SIM0_B.INPUT_3_1_1[3];\r\n  tmp_0[5] = 20;\r\n  tmp[20] = SIM0_B.INPUT_4_1_1[0];\r\n  tmp[21] = SIM0_B.INPUT_4_1_1[1];\r\n  tmp[22] = SIM0_B.INPUT_4_1_1[2];\r\n  tmp[23] = SIM0_B.INPUT_4_1_1[3];\r\n  tmp_0[6] = 24;\r\n  tmp[24] = SIM0_B.INPUT_5_1_1[0];\r\n  tmp[25] = SIM0_B.INPUT_5_1_1[1];\r\n  tmp[26] = SIM0_B.INPUT_5_1_1[2];\r\n  tmp[27] = SIM0_B.INPUT_5_1_1[3];\r\n  tmp_0[7] = 28;\r\n  tmp[28] = SIM0_B.INPUT_6_1_1[0];\r\n  tmp[29] = SIM0_B.INPUT_6_1_1[1];\r\n  tmp[30] = SIM0_B.INPUT_6_1_1[2];\r\n  tmp[31] = SIM0_B.INPUT_6_1_1[3];\r\n  tmp_0[8] = 32;\r\n  simulationData->mData->mInputValues.mN = 32;\r\n  simulationData->mData->mInputValues.mX = &tmp[0];\r\n  simulationData->mData->mInputOffsets.mN = 9;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_0[0];\r\n  simulationData->mData->mOutputs.mN = 33;\r\n  simulationData->mData->mOutputs.mX = &SIM0_B.STATE_1[0];\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  y = ((SIM0_M->Timing.clockTick0) * 0.2);\r\n  time_0 = y;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_0;\r\n  isHit = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  i = ne_simulator_method((NeslSimulator *)SIM0_DW.STATE_1_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (i != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg;\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(SIM0_M, msg);\r\n    }\r\n  }\r\n\r\n  SIM0_Y.IMD_error_latched = rtb_Logic_a_idx_0;\r\n  SIM0_Y.AMS_error_latched = rtb_Logic_idx_0;\r\n  simulationData = (NeslSimulationData *)SIM0_DW.OUTPUT_1_0_SimData;\r\n  time_1 = rtb_is_drive;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_1;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &SIM0_DW.OUTPUT_1_0_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &SIM0_DW.OUTPUT_1_0_Modes;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_2[0] = 0;\r\n  tmp_1[0] = SIM0_B.INPUT_8_1_1[0];\r\n  tmp_1[1] = SIM0_B.INPUT_8_1_1[1];\r\n  tmp_1[2] = SIM0_B.INPUT_8_1_1[2];\r\n  tmp_1[3] = SIM0_B.INPUT_8_1_1[3];\r\n  tmp_2[1] = 4;\r\n  tmp_1[4] = SIM0_B.INPUT_7_1_1[0];\r\n  tmp_1[5] = SIM0_B.INPUT_7_1_1[1];\r\n  tmp_1[6] = SIM0_B.INPUT_7_1_1[2];\r\n  tmp_1[7] = SIM0_B.INPUT_7_1_1[3];\r\n  tmp_2[2] = 8;\r\n  tmp_1[8] = SIM0_B.INPUT_2_1_1[0];\r\n  tmp_1[9] = SIM0_B.INPUT_2_1_1[1];\r\n  tmp_1[10] = SIM0_B.INPUT_2_1_1[2];\r\n  tmp_1[11] = SIM0_B.INPUT_2_1_1[3];\r\n  tmp_2[3] = 12;\r\n  tmp_1[12] = SIM0_B.INPUT_1_1_1[0];\r\n  tmp_1[13] = SIM0_B.INPUT_1_1_1[1];\r\n  tmp_1[14] = SIM0_B.INPUT_1_1_1[2];\r\n  tmp_1[15] = SIM0_B.INPUT_1_1_1[3];\r\n  tmp_2[4] = 16;\r\n  tmp_1[16] = SIM0_B.INPUT_3_1_1[0];\r\n  tmp_1[17] = SIM0_B.INPUT_3_1_1[1];\r\n  tmp_1[18] = SIM0_B.INPUT_3_1_1[2];\r\n  tmp_1[19] = SIM0_B.INPUT_3_1_1[3];\r\n  tmp_2[5] = 20;\r\n  tmp_1[20] = SIM0_B.INPUT_4_1_1[0];\r\n  tmp_1[21] = SIM0_B.INPUT_4_1_1[1];\r\n  tmp_1[22] = SIM0_B.INPUT_4_1_1[2];\r\n  tmp_1[23] = SIM0_B.INPUT_4_1_1[3];\r\n  tmp_2[6] = 24;\r\n  tmp_1[24] = SIM0_B.INPUT_5_1_1[0];\r\n  tmp_1[25] = SIM0_B.INPUT_5_1_1[1];\r\n  tmp_1[26] = SIM0_B.INPUT_5_1_1[2];\r\n  tmp_1[27] = SIM0_B.INPUT_5_1_1[3];\r\n  tmp_2[7] = 28;\r\n  tmp_1[28] = SIM0_B.INPUT_6_1_1[0];\r\n  tmp_1[29] = SIM0_B.INPUT_6_1_1[1];\r\n  tmp_1[30] = SIM0_B.INPUT_6_1_1[2];\r\n  tmp_1[31] = SIM0_B.INPUT_6_1_1[3];\r\n  tmp_2[8] = 32;\r\n  memcpy(&tmp_1[32], &SIM0_B.STATE_1[0], 33U * sizeof(real_T));\r\n  tmp_2[9] = 65;\r\n  simulationData->mData->mInputValues.mN = 65;\r\n  simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n  simulationData->mData->mInputOffsets.mN = 10;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_2[0];\r\n  simulationData->mData->mOutputs.mN = 1;\r\n  simulationData->mData->mOutputs.mX = &rtb_OUTPUT_1_0;\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  time_2 = y;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_2;\r\n  isHit_0 = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit_0;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.OUTPUT_1_0_DiagMgr;\r\n  diagnosticTree_0 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  i = ne_simulator_method((NeslSimulator *)SIM0_DW.OUTPUT_1_0_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (i != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_0;\r\n      msg_0 = rtw_diagnostics_msg(diagnosticTree_0);\r\n      rtmSetErrorStatus(SIM0_M, msg_0);\r\n    }\r\n  }\r\n\r\n  SIM0_Y.current = rtb_OUTPUT_1_0;\r\n  simulationData = (NeslSimulationData *)SIM0_DW.OUTPUT_1_1_SimData;\r\n  time_3 = rtb_is_drive;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_3;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &SIM0_DW.OUTPUT_1_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &SIM0_DW.OUTPUT_1_1_Modes;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_4[0] = 0;\r\n  tmp_3[0] = SIM0_B.INPUT_8_1_1[0];\r\n  tmp_3[1] = SIM0_B.INPUT_8_1_1[1];\r\n  tmp_3[2] = SIM0_B.INPUT_8_1_1[2];\r\n  tmp_3[3] = SIM0_B.INPUT_8_1_1[3];\r\n  tmp_4[1] = 4;\r\n  tmp_3[4] = SIM0_B.INPUT_7_1_1[0];\r\n  tmp_3[5] = SIM0_B.INPUT_7_1_1[1];\r\n  tmp_3[6] = SIM0_B.INPUT_7_1_1[2];\r\n  tmp_3[7] = SIM0_B.INPUT_7_1_1[3];\r\n  tmp_4[2] = 8;\r\n  tmp_3[8] = SIM0_B.INPUT_2_1_1[0];\r\n  tmp_3[9] = SIM0_B.INPUT_2_1_1[1];\r\n  tmp_3[10] = SIM0_B.INPUT_2_1_1[2];\r\n  tmp_3[11] = SIM0_B.INPUT_2_1_1[3];\r\n  tmp_4[3] = 12;\r\n  tmp_3[12] = SIM0_B.INPUT_1_1_1[0];\r\n  tmp_3[13] = SIM0_B.INPUT_1_1_1[1];\r\n  tmp_3[14] = SIM0_B.INPUT_1_1_1[2];\r\n  tmp_3[15] = SIM0_B.INPUT_1_1_1[3];\r\n  tmp_4[4] = 16;\r\n  tmp_3[16] = SIM0_B.INPUT_3_1_1[0];\r\n  tmp_3[17] = SIM0_B.INPUT_3_1_1[1];\r\n  tmp_3[18] = SIM0_B.INPUT_3_1_1[2];\r\n  tmp_3[19] = SIM0_B.INPUT_3_1_1[3];\r\n  tmp_4[5] = 20;\r\n  tmp_3[20] = SIM0_B.INPUT_4_1_1[0];\r\n  tmp_3[21] = SIM0_B.INPUT_4_1_1[1];\r\n  tmp_3[22] = SIM0_B.INPUT_4_1_1[2];\r\n  tmp_3[23] = SIM0_B.INPUT_4_1_1[3];\r\n  tmp_4[6] = 24;\r\n  tmp_3[24] = SIM0_B.INPUT_5_1_1[0];\r\n  tmp_3[25] = SIM0_B.INPUT_5_1_1[1];\r\n  tmp_3[26] = SIM0_B.INPUT_5_1_1[2];\r\n  tmp_3[27] = SIM0_B.INPUT_5_1_1[3];\r\n  tmp_4[7] = 28;\r\n  tmp_3[28] = SIM0_B.INPUT_6_1_1[0];\r\n  tmp_3[29] = SIM0_B.INPUT_6_1_1[1];\r\n  tmp_3[30] = SIM0_B.INPUT_6_1_1[2];\r\n  tmp_3[31] = SIM0_B.INPUT_6_1_1[3];\r\n  tmp_4[8] = 32;\r\n  memcpy(&tmp_3[32], &SIM0_B.STATE_1[0], 33U * sizeof(real_T));\r\n  tmp_4[9] = 65;\r\n  simulationData->mData->mInputValues.mN = 65;\r\n  simulationData->mData->mInputValues.mX = &tmp_3[0];\r\n  simulationData->mData->mInputOffsets.mN = 10;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_4[0];\r\n  simulationData->mData->mOutputs.mN = 1;\r\n  simulationData->mData->mOutputs.mX = &rtb_is_charge;\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  time_4 = y;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_4;\r\n  isHit_1 = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit_1;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.OUTPUT_1_1_DiagMgr;\r\n  diagnosticTree_1 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  i = ne_simulator_method((NeslSimulator *)SIM0_DW.OUTPUT_1_1_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (i != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_1;\r\n      msg_1 = rtw_diagnostics_msg(diagnosticTree_1);\r\n      rtmSetErrorStatus(SIM0_M, msg_1);\r\n    }\r\n  }\r\n\r\n  SIM0_Y.vehicle_voltage = rtb_is_charge;\r\n  simulationData = (NeslSimulationData *)SIM0_DW.OUTPUT_1_2_SimData;\r\n  time_5 = rtb_is_drive;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_5;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &SIM0_DW.OUTPUT_1_2_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &SIM0_DW.OUTPUT_1_2_Modes;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_6[0] = 0;\r\n  tmp_5[0] = SIM0_B.INPUT_8_1_1[0];\r\n  tmp_5[1] = SIM0_B.INPUT_8_1_1[1];\r\n  tmp_5[2] = SIM0_B.INPUT_8_1_1[2];\r\n  tmp_5[3] = SIM0_B.INPUT_8_1_1[3];\r\n  tmp_6[1] = 4;\r\n  tmp_5[4] = SIM0_B.INPUT_7_1_1[0];\r\n  tmp_5[5] = SIM0_B.INPUT_7_1_1[1];\r\n  tmp_5[6] = SIM0_B.INPUT_7_1_1[2];\r\n  tmp_5[7] = SIM0_B.INPUT_7_1_1[3];\r\n  tmp_6[2] = 8;\r\n  tmp_5[8] = SIM0_B.INPUT_2_1_1[0];\r\n  tmp_5[9] = SIM0_B.INPUT_2_1_1[1];\r\n  tmp_5[10] = SIM0_B.INPUT_2_1_1[2];\r\n  tmp_5[11] = SIM0_B.INPUT_2_1_1[3];\r\n  tmp_6[3] = 12;\r\n  tmp_5[12] = SIM0_B.INPUT_1_1_1[0];\r\n  tmp_5[13] = SIM0_B.INPUT_1_1_1[1];\r\n  tmp_5[14] = SIM0_B.INPUT_1_1_1[2];\r\n  tmp_5[15] = SIM0_B.INPUT_1_1_1[3];\r\n  tmp_6[4] = 16;\r\n  tmp_5[16] = SIM0_B.INPUT_3_1_1[0];\r\n  tmp_5[17] = SIM0_B.INPUT_3_1_1[1];\r\n  tmp_5[18] = SIM0_B.INPUT_3_1_1[2];\r\n  tmp_5[19] = SIM0_B.INPUT_3_1_1[3];\r\n  tmp_6[5] = 20;\r\n  tmp_5[20] = SIM0_B.INPUT_4_1_1[0];\r\n  tmp_5[21] = SIM0_B.INPUT_4_1_1[1];\r\n  tmp_5[22] = SIM0_B.INPUT_4_1_1[2];\r\n  tmp_5[23] = SIM0_B.INPUT_4_1_1[3];\r\n  tmp_6[6] = 24;\r\n  tmp_5[24] = SIM0_B.INPUT_5_1_1[0];\r\n  tmp_5[25] = SIM0_B.INPUT_5_1_1[1];\r\n  tmp_5[26] = SIM0_B.INPUT_5_1_1[2];\r\n  tmp_5[27] = SIM0_B.INPUT_5_1_1[3];\r\n  tmp_6[7] = 28;\r\n  tmp_5[28] = SIM0_B.INPUT_6_1_1[0];\r\n  tmp_5[29] = SIM0_B.INPUT_6_1_1[1];\r\n  tmp_5[30] = SIM0_B.INPUT_6_1_1[2];\r\n  tmp_5[31] = SIM0_B.INPUT_6_1_1[3];\r\n  tmp_6[8] = 32;\r\n  memcpy(&tmp_5[32], &SIM0_B.STATE_1[0], 33U * sizeof(real_T));\r\n  tmp_6[9] = 65;\r\n  simulationData->mData->mInputValues.mN = 65;\r\n  simulationData->mData->mInputValues.mX = &tmp_5[0];\r\n  simulationData->mData->mInputOffsets.mN = 10;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_6[0];\r\n  simulationData->mData->mOutputs.mN = 1;\r\n  simulationData->mData->mOutputs.mX = &rtb_is_charge;\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  time_6 = y;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_6;\r\n  isHit_2 = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit_2;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.OUTPUT_1_2_DiagMgr;\r\n  diagnosticTree_2 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  i = ne_simulator_method((NeslSimulator *)SIM0_DW.OUTPUT_1_2_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (i != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_2;\r\n      msg_2 = rtw_diagnostics_msg(diagnosticTree_2);\r\n      rtmSetErrorStatus(SIM0_M, msg_2);\r\n    }\r\n  }\r\n\r\n  SIM0_Y.accumulator_voltage = rtb_is_charge;\r\n  SIM0_Y.SC_probe = rtb_Exp;\r\n  memcpy(&SIM0_Y.cell_temperatures[0], &SIM0_P.cTmp[0], 60U * sizeof(real_T));\r\n  SIM0_Y.IMD_ok = SIM0_P.IMD_ok;\r\n  memcpy(&SIM0_DW.Memory15_PreviousInput[0], &rtb_Rpz[0], 126U * sizeof(real_T));\r\n  memcpy(&SIM0_DW.Memory12_PreviousInput[0], &rtb_Rsz[0], 126U * sizeof(real_T));\r\n  SIM0_DW.Memory20_PreviousInput = rtb_OUTPUT_1_0;\r\n  SIM0_DW.Memory11_PreviousInput = rtb_Memory20;\r\n  SIM0_DW.Memory9_PreviousInput = fabs(rtb_Memory20 + rtb_Add2);\r\n  for (i = 0; i < 126; i++) {\r\n    y = rtb_Memory21[i];\r\n    if (rtb_Switch[i] > y) {\r\n      SIM0_DW.Memory_PreviousInput[i] = y;\r\n    } else {\r\n      SIM0_DW.Memory_PreviousInput[i] = rtb_tauz[i];\r\n    }\r\n\r\n    SIM0_DW.Memory10_PreviousInput[i] = y;\r\n    SIM0_DW.Memory19_PreviousInput[i] = SIM0_U.BalanceOut[i];\r\n    SIM0_DW.Memory21_PreviousInput[i] = rtb_Rpz[i];\r\n  }\r\n\r\n  SIM0_DW.Memory6_PreviousInput = SIM0_U.charge;\r\n  SIM0_DW.Memory7_PreviousInput = SIM0_U.drive;\r\n  SIM0_DW.Memory16_PreviousInput = SIM0_U.EnableCharge;\r\n  SIM0_DW.Memory17_PreviousInput = SIM0_U.VoltageLimit;\r\n  SIM0_DW.Memory18_PreviousInput = SIM0_U.CurrentLimit;\r\n  SIM0_DW.Memory1_PreviousInput = SIM0_U.AMS_error;\r\n  SIM0_DW.Memory2_PreviousInput = SIM0_U.AMS_error_reset;\r\n  SIM0_DW.Memory_PreviousInput_e = rtb_Logic_idx_0;\r\n  SIM0_DW.Memory3_PreviousInput = SIM0_U.IMD_error;\r\n  SIM0_DW.Memory4_PreviousInput = SIM0_U.IMD_error_reset;\r\n  SIM0_DW.Memory_PreviousInput_m = rtb_Logic_a_idx_0;\r\n  SIM0_DW.Memory5_PreviousInput = SIM0_U.SC;\r\n  SIM0_DW.Delay3_DSTATE[0] = SIM0_DW.Delay3_DSTATE[1];\r\n  SIM0_DW.Delay3_DSTATE[1] = SIM0_DW.Memory8_PreviousInput;\r\n  SIM0_DW.Delay2_DSTATE[0] = SIM0_DW.Delay2_DSTATE[1];\r\n  SIM0_DW.Delay2_DSTATE[1] = SIM0_DW.Memory13_PreviousInput;\r\n  SIM0_DW.Memory22_PreviousInput = SIM0_U.drive_current;\r\n  SIM0_DW.Delay1_DSTATE = SIM0_DW.Memory14_PreviousInput;\r\n  simulationData = (NeslSimulationData *)SIM0_DW.STATE_1_SimData;\r\n  time_7 = rtb_is_drive;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_7;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 17;\r\n  simulationData->mData->mDiscStates.mX = &SIM0_DW.STATE_1_Discrete[0];\r\n  simulationData->mData->mModeVector.mN = 16;\r\n  simulationData->mData->mModeVector.mX = &SIM0_DW.STATE_1_Modes[0];\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_8[0] = 0;\r\n  tmp_7[0] = SIM0_B.INPUT_8_1_1[0];\r\n  tmp_7[1] = SIM0_B.INPUT_8_1_1[1];\r\n  tmp_7[2] = SIM0_B.INPUT_8_1_1[2];\r\n  tmp_7[3] = SIM0_B.INPUT_8_1_1[3];\r\n  tmp_8[1] = 4;\r\n  tmp_7[4] = SIM0_B.INPUT_7_1_1[0];\r\n  tmp_7[5] = SIM0_B.INPUT_7_1_1[1];\r\n  tmp_7[6] = SIM0_B.INPUT_7_1_1[2];\r\n  tmp_7[7] = SIM0_B.INPUT_7_1_1[3];\r\n  tmp_8[2] = 8;\r\n  tmp_7[8] = SIM0_B.INPUT_2_1_1[0];\r\n  tmp_7[9] = SIM0_B.INPUT_2_1_1[1];\r\n  tmp_7[10] = SIM0_B.INPUT_2_1_1[2];\r\n  tmp_7[11] = SIM0_B.INPUT_2_1_1[3];\r\n  tmp_8[3] = 12;\r\n  tmp_7[12] = SIM0_B.INPUT_1_1_1[0];\r\n  tmp_7[13] = SIM0_B.INPUT_1_1_1[1];\r\n  tmp_7[14] = SIM0_B.INPUT_1_1_1[2];\r\n  tmp_7[15] = SIM0_B.INPUT_1_1_1[3];\r\n  tmp_8[4] = 16;\r\n  tmp_7[16] = SIM0_B.INPUT_3_1_1[0];\r\n  tmp_7[17] = SIM0_B.INPUT_3_1_1[1];\r\n  tmp_7[18] = SIM0_B.INPUT_3_1_1[2];\r\n  tmp_7[19] = SIM0_B.INPUT_3_1_1[3];\r\n  tmp_8[5] = 20;\r\n  tmp_7[20] = SIM0_B.INPUT_4_1_1[0];\r\n  tmp_7[21] = SIM0_B.INPUT_4_1_1[1];\r\n  tmp_7[22] = SIM0_B.INPUT_4_1_1[2];\r\n  tmp_7[23] = SIM0_B.INPUT_4_1_1[3];\r\n  tmp_8[6] = 24;\r\n  tmp_7[24] = SIM0_B.INPUT_5_1_1[0];\r\n  tmp_7[25] = SIM0_B.INPUT_5_1_1[1];\r\n  tmp_7[26] = SIM0_B.INPUT_5_1_1[2];\r\n  tmp_7[27] = SIM0_B.INPUT_5_1_1[3];\r\n  tmp_8[7] = 28;\r\n  tmp_7[28] = SIM0_B.INPUT_6_1_1[0];\r\n  tmp_7[29] = SIM0_B.INPUT_6_1_1[1];\r\n  tmp_7[30] = SIM0_B.INPUT_6_1_1[2];\r\n  tmp_7[31] = SIM0_B.INPUT_6_1_1[3];\r\n  tmp_8[8] = 32;\r\n  simulationData->mData->mInputValues.mN = 32;\r\n  simulationData->mData->mInputValues.mX = &tmp_7[0];\r\n  simulationData->mData->mInputOffsets.mN = 9;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_8[0];\r\n  diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.STATE_1_DiagMgr;\r\n  diagnosticTree_3 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  i = ne_simulator_method((NeslSimulator *)SIM0_DW.STATE_1_Simulator,\r\n    NESL_SIM_UPDATE, simulationData, diagnosticManager);\r\n  if (i != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_3;\r\n      msg_3 = rtw_diagnostics_msg(diagnosticTree_3);\r\n      rtmSetErrorStatus(SIM0_M, msg_3);\r\n    }\r\n  }\r\n\r\n  SIM0_DW.Memory13_PreviousInput = SIM0_U.EnableAirPlus;\r\n  SIM0_DW.Memory14_PreviousInput = SIM0_U.EnablePrecharge;\r\n  SIM0_DW.Memory8_PreviousInput = SIM0_U.EnableAirMinus;\r\n  SIM0_M->Timing.clockTick0++;\r\n}\r\n\r\nvoid SIM0_initialize(void)\r\n{\r\n  {\r\n    NeModelParameters modelParameters;\r\n    NeModelParameters modelParameters_0;\r\n    NeModelParameters modelParameters_1;\r\n    NeModelParameters modelParameters_2;\r\n    NeslSimulationData *tmp_1;\r\n    NeslSimulator *tmp;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    NeuDiagnosticTree *diagnosticTree_0;\r\n    NeuDiagnosticTree *diagnosticTree_1;\r\n    NeuDiagnosticTree *diagnosticTree_2;\r\n    real_T tmp_2;\r\n    int32_T i;\r\n    boolean_T tmp_0;\r\n    tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 0, 0);\r\n    SIM0_DW.STATE_1_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(SIM0_DW.STATE_1_Simulator);\r\n    if (tmp_0) {\r\n      SIM0_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 0, 0);\r\n      SIM0_DW.STATE_1_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    SIM0_DW.STATE_1_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    SIM0_DW.STATE_1_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters.mSolverTolerance = 0.001;\r\n    modelParameters.mSolverAbsTol = 0.001;\r\n    modelParameters.mSolverRelTol = 0.001;\r\n    modelParameters.mVariableStepSolver = false;\r\n    modelParameters.mIsUsingODEN = false;\r\n    modelParameters.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters.mFixedStepSize = 0.001;\r\n    modelParameters.mStartTime = 0.0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mUseSimState = false;\r\n    modelParameters.mLinTrimCompile = false;\r\n    modelParameters.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters.mRTWModifiedTimeStamp = 5.71633359E+8;\r\n    modelParameters.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters.mIsUsingODEN = tmp_0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    i = nesl_initialize_simulator((NeslSimulator *)SIM0_DW.STATE_1_Simulator,\r\n      &modelParameters, diagnosticManager);\r\n    if (i != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n      if (tmp_0) {\r\n        char *msg;\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(SIM0_M, msg);\r\n      }\r\n    }\r\n\r\n    tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 1, 0);\r\n    SIM0_DW.OUTPUT_1_0_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(SIM0_DW.OUTPUT_1_0_Simulator);\r\n    if (tmp_0) {\r\n      SIM0_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 1, 0);\r\n      SIM0_DW.OUTPUT_1_0_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    SIM0_DW.OUTPUT_1_0_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    SIM0_DW.OUTPUT_1_0_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_0.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_0.mSolverTolerance = 0.001;\r\n    modelParameters_0.mSolverAbsTol = 0.001;\r\n    modelParameters_0.mSolverRelTol = 0.001;\r\n    modelParameters_0.mVariableStepSolver = false;\r\n    modelParameters_0.mIsUsingODEN = false;\r\n    modelParameters_0.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters_0.mFixedStepSize = 0.001;\r\n    modelParameters_0.mStartTime = 0.0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mUseSimState = false;\r\n    modelParameters_0.mLinTrimCompile = false;\r\n    modelParameters_0.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters_0.mRTWModifiedTimeStamp = 5.71633359E+8;\r\n    modelParameters_0.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters_0.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters_0.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters_0.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters_0.mIsUsingODEN = tmp_0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.OUTPUT_1_0_DiagMgr;\r\n    diagnosticTree_0 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    i = nesl_initialize_simulator((NeslSimulator *)SIM0_DW.OUTPUT_1_0_Simulator,\r\n      &modelParameters_0, diagnosticManager);\r\n    if (i != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n      if (tmp_0) {\r\n        char *msg_0;\r\n        msg_0 = rtw_diagnostics_msg(diagnosticTree_0);\r\n        rtmSetErrorStatus(SIM0_M, msg_0);\r\n      }\r\n    }\r\n\r\n    tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 1, 1);\r\n    SIM0_DW.OUTPUT_1_1_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(SIM0_DW.OUTPUT_1_1_Simulator);\r\n    if (tmp_0) {\r\n      SIM0_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 1, 1);\r\n      SIM0_DW.OUTPUT_1_1_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    SIM0_DW.OUTPUT_1_1_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    SIM0_DW.OUTPUT_1_1_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_1.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_1.mSolverTolerance = 0.001;\r\n    modelParameters_1.mSolverAbsTol = 0.001;\r\n    modelParameters_1.mSolverRelTol = 0.001;\r\n    modelParameters_1.mVariableStepSolver = false;\r\n    modelParameters_1.mIsUsingODEN = false;\r\n    modelParameters_1.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters_1.mFixedStepSize = 0.001;\r\n    modelParameters_1.mStartTime = 0.0;\r\n    modelParameters_1.mLoadInitialState = false;\r\n    modelParameters_1.mUseSimState = false;\r\n    modelParameters_1.mLinTrimCompile = false;\r\n    modelParameters_1.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters_1.mRTWModifiedTimeStamp = 5.71633359E+8;\r\n    modelParameters_1.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters_1.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters_1.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters_1.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters_1.mIsUsingODEN = tmp_0;\r\n    modelParameters_1.mLoadInitialState = false;\r\n    modelParameters_1.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.OUTPUT_1_1_DiagMgr;\r\n    diagnosticTree_1 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    i = nesl_initialize_simulator((NeslSimulator *)SIM0_DW.OUTPUT_1_1_Simulator,\r\n      &modelParameters_1, diagnosticManager);\r\n    if (i != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n      if (tmp_0) {\r\n        char *msg_1;\r\n        msg_1 = rtw_diagnostics_msg(diagnosticTree_1);\r\n        rtmSetErrorStatus(SIM0_M, msg_1);\r\n      }\r\n    }\r\n\r\n    tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 1, 2);\r\n    SIM0_DW.OUTPUT_1_2_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(SIM0_DW.OUTPUT_1_2_Simulator);\r\n    if (tmp_0) {\r\n      SIM0_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"SIM0/SIM/Solver Configuration_1\", 1, 2);\r\n      SIM0_DW.OUTPUT_1_2_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    SIM0_DW.OUTPUT_1_2_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    SIM0_DW.OUTPUT_1_2_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_2.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_2.mSolverTolerance = 0.001;\r\n    modelParameters_2.mSolverAbsTol = 0.001;\r\n    modelParameters_2.mSolverRelTol = 0.001;\r\n    modelParameters_2.mVariableStepSolver = false;\r\n    modelParameters_2.mIsUsingODEN = false;\r\n    modelParameters_2.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters_2.mFixedStepSize = 0.001;\r\n    modelParameters_2.mStartTime = 0.0;\r\n    modelParameters_2.mLoadInitialState = false;\r\n    modelParameters_2.mUseSimState = false;\r\n    modelParameters_2.mLinTrimCompile = false;\r\n    modelParameters_2.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters_2.mRTWModifiedTimeStamp = 5.71633359E+8;\r\n    modelParameters_2.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters_2.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters_2.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters_2.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters_2.mIsUsingODEN = tmp_0;\r\n    modelParameters_2.mLoadInitialState = false;\r\n    modelParameters_2.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)SIM0_DW.OUTPUT_1_2_DiagMgr;\r\n    diagnosticTree_2 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    i = nesl_initialize_simulator((NeslSimulator *)SIM0_DW.OUTPUT_1_2_Simulator,\r\n      &modelParameters_2, diagnosticManager);\r\n    if (i != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(SIM0_M));\r\n      if (tmp_0) {\r\n        char *msg_2;\r\n        msg_2 = rtw_diagnostics_msg(diagnosticTree_2);\r\n        rtmSetErrorStatus(SIM0_M, msg_2);\r\n      }\r\n    }\r\n\r\n    SIM0_DW.Memory20_PreviousInput = SIM0_P.Memory20_InitialCondition;\r\n    SIM0_DW.Memory11_PreviousInput = SIM0_P.Memory11_InitialCondition;\r\n    SIM0_DW.Memory9_PreviousInput = SIM0_P.Memory9_InitialCondition;\r\n    for (i = 0; i < 126; i++) {\r\n      SIM0_DW.Memory15_PreviousInput[i] = SIM0_P.Memory15_InitialCondition;\r\n      SIM0_DW.Memory12_PreviousInput[i] = SIM0_P.Memory12_InitialCondition[i];\r\n      SIM0_DW.Memory_PreviousInput[i] = SIM0_P.cQur[i];\r\n      SIM0_DW.Memory10_PreviousInput[i] = SIM0_P.cCap[i];\r\n      SIM0_DW.Memory19_PreviousInput[i] = SIM0_P.Memory19_InitialCondition;\r\n      SIM0_DW.Memory21_PreviousInput[i] = SIM0_P.Memory21_InitialCondition;\r\n    }\r\n\r\n    SIM0_DW.Memory6_PreviousInput = SIM0_P.Memory6_InitialCondition;\r\n    SIM0_DW.Memory7_PreviousInput = SIM0_P.Memory7_InitialCondition;\r\n    SIM0_DW.Memory16_PreviousInput = SIM0_P.Memory16_InitialCondition;\r\n    SIM0_DW.Memory17_PreviousInput = SIM0_P.Memory17_InitialCondition;\r\n    SIM0_DW.Memory18_PreviousInput = SIM0_P.Memory18_InitialCondition;\r\n    SIM0_DW.Memory1_PreviousInput = SIM0_P.Memory1_InitialCondition;\r\n    SIM0_DW.Memory2_PreviousInput = SIM0_P.Memory2_InitialCondition;\r\n    SIM0_DW.Memory_PreviousInput_e = SIM0_P.SRFlipFlop2_initial_condition;\r\n    SIM0_DW.Memory3_PreviousInput = SIM0_P.Memory3_InitialCondition;\r\n    SIM0_DW.Memory4_PreviousInput = SIM0_P.Memory4_InitialCondition;\r\n    SIM0_DW.Memory_PreviousInput_m = SIM0_P.SRFlipFlop1_initial_condition;\r\n    SIM0_DW.Memory5_PreviousInput = SIM0_P.Memory5_InitialCondition;\r\n    SIM0_DW.Delay3_DSTATE[0] = SIM0_P.Delay3_InitialCondition;\r\n    SIM0_DW.Delay2_DSTATE[0] = SIM0_P.Delay2_InitialCondition;\r\n    SIM0_DW.Delay3_DSTATE[1] = SIM0_P.Delay3_InitialCondition;\r\n    SIM0_DW.Delay2_DSTATE[1] = SIM0_P.Delay2_InitialCondition;\r\n    SIM0_DW.Memory22_PreviousInput = SIM0_P.Memory22_InitialCondition;\r\n    SIM0_DW.Delay1_DSTATE = SIM0_P.Delay1_InitialCondition;\r\n    SIM0_DW.Memory13_PreviousInput = SIM0_P.Memory13_InitialCondition;\r\n    SIM0_DW.Memory14_PreviousInput = SIM0_P.Memory14_InitialCondition;\r\n    SIM0_DW.Memory8_PreviousInput = SIM0_P.Memory8_InitialCondition;\r\n  }\r\n}\r\n\r\nvoid SIM0_terminate(void)\r\n{\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)SIM0_DW.STATE_1_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)SIM0_DW.STATE_1_SimData);\r\n  nesl_erase_simulator(\"SIM0/SIM/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    SIM0_DW.OUTPUT_1_0_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)SIM0_DW.OUTPUT_1_0_SimData);\r\n  nesl_erase_simulator(\"SIM0/SIM/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    SIM0_DW.OUTPUT_1_1_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)SIM0_DW.OUTPUT_1_1_SimData);\r\n  nesl_erase_simulator(\"SIM0/SIM/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    SIM0_DW.OUTPUT_1_2_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)SIM0_DW.OUTPUT_1_2_SimData);\r\n  nesl_erase_simulator(\"SIM0/SIM/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n}\r\n"},{"name":"SIM0.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_SIM0_h_\r\n#define RTW_HEADER_SIM0_h_\r\n#ifndef SIM0_COMMON_INCLUDES_\r\n#define SIM0_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"nesl_rtw.h\"\r\n#include \"SIM0_627956e1_1_gateway.h\"\r\n#endif\r\n\r\n#include \"SIM0_types.h\"\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\ntypedef struct {\r\n  real_T INPUT_7_1_1[4];\r\n  real_T INPUT_8_1_1[4];\r\n  real_T INPUT_2_1_1[4];\r\n  real_T INPUT_1_1_1[4];\r\n  real_T INPUT_3_1_1[4];\r\n  real_T INPUT_4_1_1[4];\r\n  real_T INPUT_5_1_1[4];\r\n  real_T INPUT_6_1_1[4];\r\n  real_T STATE_1[33];\r\n} B_SIM0_T;\r\n\r\ntypedef struct {\r\n  real_T Delay3_DSTATE[2];\r\n  real_T Delay2_DSTATE[2];\r\n  real_T INPUT_7_1_1_Discrete[2];\r\n  real_T INPUT_8_1_1_Discrete[2];\r\n  real_T INPUT_2_1_1_Discrete[2];\r\n  real_T INPUT_1_1_1_Discrete[2];\r\n  real_T Delay1_DSTATE;\r\n  real_T INPUT_3_1_1_Discrete[2];\r\n  real_T INPUT_4_1_1_Discrete[2];\r\n  real_T INPUT_5_1_1_Discrete[2];\r\n  real_T INPUT_6_1_1_Discrete[2];\r\n  real_T STATE_1_Discrete[17];\r\n  real_T Memory15_PreviousInput[126];\r\n  real_T Memory12_PreviousInput[126];\r\n  real_T Memory20_PreviousInput;\r\n  real_T Memory11_PreviousInput;\r\n  real_T Memory_PreviousInput[126];\r\n  real_T Memory10_PreviousInput[126];\r\n  real_T Memory9_PreviousInput;\r\n  real_T Memory19_PreviousInput[126];\r\n  real_T Memory21_PreviousInput[126];\r\n  real_T Memory6_PreviousInput;\r\n  real_T Memory7_PreviousInput;\r\n  real_T Memory16_PreviousInput;\r\n  real_T Memory17_PreviousInput;\r\n  real_T Memory18_PreviousInput;\r\n  real_T Memory1_PreviousInput;\r\n  real_T Memory2_PreviousInput;\r\n  real_T Memory3_PreviousInput;\r\n  real_T Memory4_PreviousInput;\r\n  real_T Memory5_PreviousInput;\r\n  real_T Memory22_PreviousInput;\r\n  real_T OUTPUT_1_0_Discrete;\r\n  real_T OUTPUT_1_1_Discrete;\r\n  real_T OUTPUT_1_2_Discrete;\r\n  real_T Memory13_PreviousInput;\r\n  real_T Memory14_PreviousInput;\r\n  real_T Memory8_PreviousInput;\r\n  void* STATE_1_Simulator;\r\n  void* STATE_1_SimData;\r\n  void* STATE_1_DiagMgr;\r\n  void* STATE_1_ZcLogger;\r\n  void* STATE_1_TsInfo;\r\n  void* OUTPUT_1_0_Simulator;\r\n  void* OUTPUT_1_0_SimData;\r\n  void* OUTPUT_1_0_DiagMgr;\r\n  void* OUTPUT_1_0_ZcLogger;\r\n  void* OUTPUT_1_0_TsInfo;\r\n  void* OUTPUT_1_1_Simulator;\r\n  void* OUTPUT_1_1_SimData;\r\n  void* OUTPUT_1_1_DiagMgr;\r\n  void* OUTPUT_1_1_ZcLogger;\r\n  void* OUTPUT_1_1_TsInfo;\r\n  void* OUTPUT_1_2_Simulator;\r\n  void* OUTPUT_1_2_SimData;\r\n  void* OUTPUT_1_2_DiagMgr;\r\n  void* OUTPUT_1_2_ZcLogger;\r\n  void* OUTPUT_1_2_TsInfo;\r\n  int_T STATE_1_Modes[16];\r\n  int_T OUTPUT_1_0_Modes;\r\n  int_T OUTPUT_1_1_Modes;\r\n  int_T OUTPUT_1_2_Modes;\r\n  boolean_T Memory_PreviousInput_e;\r\n  boolean_T Memory_PreviousInput_m;\r\n  boolean_T STATE_1_FirstOutput;\r\n  boolean_T OUTPUT_1_0_FirstOutput;\r\n  boolean_T OUTPUT_1_1_FirstOutput;\r\n  boolean_T OUTPUT_1_2_FirstOutput;\r\n} DW_SIM0_T;\r\n\r\ntypedef struct {\r\n  real_T AMS_error;\r\n  real_T AMS_error_reset;\r\n  real_T IMD_error;\r\n  real_T IMD_error_reset;\r\n  real_T SC;\r\n  real_T EnableAirMinus;\r\n  real_T EnableAirPlus;\r\n  real_T EnablePrecharge;\r\n  real_T VoltageLimit;\r\n  real_T CurrentLimit;\r\n  real_T EnableCharge;\r\n  real_T charge;\r\n  real_T drive;\r\n  real_T BalanceOut[126];\r\n  real_T drive_current;\r\n} ExtU_SIM0_T;\r\n\r\ntypedef struct {\r\n  boolean_T AMS_error_latched;\r\n  boolean_T IMD_error_latched;\r\n  real_T SC_probe;\r\n  real_T AIR_minus_closed;\r\n  real_T AIR_plus_closed;\r\n  real_T precharge_closed;\r\n  real_T current;\r\n  real_T vehicle_voltage;\r\n  real_T accumulator_voltage;\r\n  real_T cell_voltages[126];\r\n  real_T cell_socs[126];\r\n  real_T cell_capacities[126];\r\n  real_T cell_temperatures[60];\r\n  real_T IMD_ok;\r\n} ExtY_SIM0_T;\r\n\r\nstruct P_SIM0_T_ {\r\n  real_T C_r;\r\n  real_T Cap_det;\r\n  real_T IMD_ok;\r\n  real_T R_short;\r\n  real_T Rp[13];\r\n  real_T Rs[13];\r\n  real_T Ts;\r\n  real_T cCap[126];\r\n  real_T cQur[126];\r\n  real_T cTmp[60];\r\n  real_T ocv[13];\r\n  real_T soc[13];\r\n  real_T tau[13];\r\n  boolean_T SRFlipFlop2_initial_condition;\r\n  boolean_T SRFlipFlop1_initial_condition;\r\n  real_T Memory15_InitialCondition;\r\n  real_T Memory12_InitialCondition[126];\r\n  real_T Memory20_InitialCondition;\r\n  real_T Memory11_InitialCondition;\r\n  real_T Memory9_InitialCondition;\r\n  real_T Memory19_InitialCondition;\r\n  real_T Memory21_InitialCondition;\r\n  real_T Gain_Gain;\r\n  real_T Constant1_Value;\r\n  real_T Memory6_InitialCondition;\r\n  real_T Memory7_InitialCondition;\r\n  real_T Memory16_InitialCondition;\r\n  real_T Memory17_InitialCondition;\r\n  real_T Memory18_InitialCondition;\r\n  real_T Memory1_InitialCondition;\r\n  real_T Memory2_InitialCondition;\r\n  real_T Memory3_InitialCondition;\r\n  real_T Memory4_InitialCondition;\r\n  real_T Memory5_InitialCondition;\r\n  real_T Delay3_InitialCondition;\r\n  real_T Delay2_InitialCondition;\r\n  real_T Memory22_InitialCondition;\r\n  real_T Delay1_InitialCondition;\r\n  real_T Memory13_InitialCondition;\r\n  real_T Memory14_InitialCondition;\r\n  real_T Memory8_InitialCondition;\r\n  boolean_T Logic_table[16];\r\n  boolean_T Logic_table_f[16];\r\n};\r\n\r\nstruct tag_RTM_SIM0_T {\r\n  const char_T * volatile errorStatus;\r\n  struct {\r\n    uint32_T clockTick0;\r\n  } Timing;\r\n};\r\n\r\nextern P_SIM0_T SIM0_P;\r\nextern B_SIM0_T SIM0_B;\r\nextern DW_SIM0_T SIM0_DW;\r\nextern ExtU_SIM0_T SIM0_U;\r\nextern ExtY_SIM0_T SIM0_Y;\r\nextern void SIM0_initialize(void);\r\nextern void SIM0_step(void);\r\nextern void SIM0_terminate(void);\r\nextern RT_MODEL_SIM0_T *const SIM0_M;\r\n\r\n#endif\r\n\r\n"},{"name":"SIM0_private.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_SIM0_private_h_\r\n#define RTW_HEADER_SIM0_private_h_\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n"},{"name":"SIM0_types.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_SIM0_types_h_\r\n#define RTW_HEADER_SIM0_types_h_\r\n\r\ntypedef struct P_SIM0_T_ P_SIM0_T;\r\ntypedef struct tag_RTM_SIM0_T RT_MODEL_SIM0_T;\r\n\r\n#endif\r\n\r\n"},{"name":"SIM0_data.c","type":"source","group":"data","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Data files","code":"#include \"SIM0.h\"\r\n\r\nP_SIM0_T SIM0_P = {\r\n\r\n  6.6,\r\n\r\n  -1.0E-7,\r\n\r\n  1.0,\r\n\r\n  33.0,\r\n\r\n\r\n  { 0.0013284973182, 0.00132849731829051, 0.00133071540686515,\r\n    0.00133106364620441, 0.00133282418704394, 0.00133927918011939,\r\n    0.00135371077616641, 0.00137940112592065, 0.00141963238011775,\r\n    0.00147768668949337, 0.00155684620478314, 0.00166039307672272,\r\n    0.00179160945604776 },\r\n\r\n\r\n  { 0.0044622496006, 0.00446224960061823, 0.00395928973129493,\r\n    0.00365723545490869, 0.00346135878439388, 0.00332839611795259,\r\n    0.00323577769308545, 0.00317057626115591, 0.00312485453442757,\r\n    0.00309346940400882, 0.00307294184679812, 0.00306083426030356,\r\n    0.00305538791678206 },\r\n\r\n  0.2,\r\n\r\n\r\n  { 23992.347012624476, 24186.387557408943, 23387.191258276496,\r\n    23523.545416242814, 25783.690886603054, 21501.646029503809,\r\n    25989.445680456898, 24097.563700613107, 24760.060819589125,\r\n    22095.835525012939, 23169.96543579478, 23481.93583623469, 24182.715691220477,\r\n    22089.799302149528, 24231.634326416304, 22547.152800325541,\r\n    23826.190048424611, 24412.355888661376, 24087.059967177087,\r\n    24842.633504236757, 24766.077110819053, 23109.092263402246,\r\n    24017.05615743397, 22815.62219359578, 22438.211478607438, 24684.825933493707,\r\n    23760.049849075251, 23705.081085390593, 24671.12726565386,\r\n    24354.583697409053, 24110.201173874535, 25010.251228304995,\r\n    24689.789458557716, 23999.763257058581, 23069.638896888773,\r\n    23108.446358249719, 24952.101870531271, 22148.169611322188,\r\n    23735.538063364082, 21811.1528231011, 24780.498014452653, 24621.716302393419,\r\n    23761.162083483512, 23689.162786839519, 21273.716079296722,\r\n    24341.172322675924, 21567.565080034095, 21440.719693356696,\r\n    23839.933710298439, 22811.519016429495, 24171.490621423374,\r\n    24436.97780568403, 24617.732545205356, 23068.84087461701, 24209.377623166849,\r\n    23860.633350315078, 24586.069998469924, 24296.157079925917,\r\n    24657.888425985075, 23628.062132075418, 23612.798543848734,\r\n    24767.773405305437, 21636.344537584249, 23255.413594485992,\r\n    22489.405550191339, 23377.41519729235, 24408.679262048619,\r\n    24585.727149241757, 22745.056357319863, 23288.930087316832,\r\n    23897.024874130049, 23468.136624246428, 24061.818555261005, 24159.9309429558,\r\n    22830.038441059871, 23583.169734070769, 21627.905400838466,\r\n    24905.361710518475, 23130.909239005843, 22556.15002599778,\r\n    23506.055316577189, 22331.353135367903, 23739.1423822984, 23199.335003471817,\r\n    25937.778709184153, 24898.465387329594, 21263.1134968155, 24201.32693172761,\r\n    22361.862124188927, 23504.944820119195, 23924.404073318728,\r\n    24507.734028808121, 23486.953050597094, 25336.300146546077,\r\n    23279.062848221154, 24087.512120829684, 24424.734120627596,\r\n    23845.188592721159, 24640.952785381047, 24083.213137847597,\r\n    22975.853816335912, 21954.62664861391, 25618.592948555706, 23155.46991122554,\r\n    23863.359722310648, 24323.166955145978, 23873.596996734002,\r\n    22855.273787201968, 23292.285417548144, 23635.110052776894,\r\n    25238.958491504029, 22899.184309993037, 24544.668467287822,\r\n    24068.62313994853, 23526.139957870848, 22703.027254039869,\r\n    23475.859045373836, 23673.309717540695, 22290.604925513642,\r\n    23952.182244870786, 22937.706723709824, 23665.759412040275,\r\n    24096.21334095424, 22855.345940753163, 23471.743638794305,\r\n    24110.062757534179 },\r\n\r\n\r\n  { 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0,\r\n    11880.0, 11880.0, 11880.0, 11880.0, 11880.0, 11880.0 },\r\n\r\n\r\n  { 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0,\r\n    20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0,\r\n    20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0,\r\n    20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0,\r\n    20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0 },\r\n\r\n\r\n  { 0.0, 2.99808472821531, 3.29015678205606, 3.51449858492796, 3.66802196422992,\r\n    3.76050972589663, 3.81021773542304, 3.83947699888896, 3.87029574398353,\r\n    3.91996150102984, 3.99664318400941, 4.09499317158672, 4.19174938813381 },\r\n\r\n\r\n  { 0.0, 0.01, 0.0909090909090909, 0.181818181818182, 0.272727272727273,\r\n    0.363636363636364, 0.454545454545455, 0.545454545454545, 0.636363636363636,\r\n    0.727272727272727, 0.818181818181818, 0.909090909090909, 1.0 },\r\n\r\n\r\n  { 950.87194683, 950.871946837005, 952.459545918238, 952.715608141667,\r\n    956.801088701637, 1116.9800008749899, 2163.29230815358, 2204.3466729378397,\r\n    1183.99583949683, 1060.79424954235, 1114.3206284707098, 1188.42633649718,\r\n    1282.34445639369 },\r\n\r\n  false,\r\n\r\n  false,\r\n\r\n  0.0,\r\n\r\n\r\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  -1.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n\r\n  { false, true, false, false, true, true, false, false, true, false, true, true,\r\n    false, false, false, false },\r\n\r\n\r\n  { false, true, false, false, true, true, false, false, true, false, true, true,\r\n    false, false, false, false }\r\n};\r\n"},{"name":"look1_binlxpw.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"look1_binlxpw.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nreal_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n                     uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T yL_0d0;\r\n  uint32_T iLeft;\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n    bpIdx = maxIndex >> 1U;\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while (iRght - iLeft > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = (iRght + iLeft) >> 1U;\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  yL_0d0 = table[iLeft];\r\n  return (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n"},{"name":"look1_binlxpw.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_look1_binlxpw_h_\r\n#define RTW_HEADER_look1_binlxpw_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T maxIndex);\r\n\r\n#endif\r\n\r\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_backsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      backward substitution: solving Ux=b for real\r\n *      double precision float operands.\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\r\n * Abstract: Backward substitution: Solving Ux=b \r\n *           U: real, double\r\n *           b: real, double\r\n *           U is an upper (or unit upper) triangular full matrix.\r\n *           The entries in the lower triangle are ignored.\r\n *           U is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                   const real_T    *pb,\r\n                                   real_T          *x,\r\n                                   int_T            N,\r\n                                   int_T            P,\r\n                                   boolean_T        unit_upper)\r\n{\r\n  int_T i,k;\r\n  for(k=P; k>0; k--) {\r\n    real_T *pUcol = pU;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N-1;\r\n      real_T s = 0.0;\r\n      real_T *pUrow = pUcol--;          /* access current row of U */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pUrow * *xj--;\r\n          pUrow -= N;\r\n        }\r\n      }\r\n\r\n      if (unit_upper) {\r\n        *xj = *pb-- - s;\r\n      } else {\r\n        *xj = (*pb-- - s) / *pUrow;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_backsubrr_dbl.c */\r\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_forwardsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      forward substitution: solving Lx=b\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\r\n * Abstract: Forward substitution: solving Lx=b \r\n *           L: Real, double\r\n *           b: Real, double\r\n *           L is a lower (or unit lower) triangular full matrix.\r\n *           The entries in the upper triangle are ignored.\r\n *           L is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                  const real_T  *pb,\r\n                                  real_T        *x,\r\n                                  int_T          N,\r\n                                  int_T          P,\r\n                                  const int32_T *piv,\r\n                                  boolean_T      unit_lower)\r\n{  \r\n  /* Real inputs: */\r\n  int_T i, k;\r\n  for(k=0; k<P; k++) {\r\n    real_T *pLcol = pL;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N;\r\n      real_T s = 0.0;\r\n      real_T *pLrow = pLcol++;          /* access current row of L */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pLrow * *xj;\r\n          pLrow += N;\r\n          xj++;\r\n        }\r\n      }\r\n\r\n      if (unit_lower) {\r\n        *xj = pb[piv[i]] - s;\r\n      } else {\r\n        *xj = (pb[piv[i]] - s) / *pLrow;\r\n      }\r\n    }\r\n    pb += N;\r\n  }\r\n}\r\n\r\n/* [EOF] rt_forwardsubrr_dbl.c */\r\n"},{"name":"rt_lu_real.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_lu_real.c     \r\n *\r\n * Abstract:\r\n *      Real-Time Workshop support routine for lu_real\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_lu_real  =======================================================\r\n * Abstract: A is real.\r\n *\r\n */\r\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\r\n                const int_T n,     /* number or rows = number of columns */\r\n                int32_T     *piv)  /* pivote vector                      */\r\n{\r\n  int_T k;\r\n\r\n  /* initialize row-pivot indices: */\r\n  for (k = 0; k < n; k++) {\r\n    piv[k] = k;\r\n  }\r\n\r\n  /* Loop over each column: */\r\n  for (k = 0; k < n; k++) {\r\n    const int_T kn = k*n;\r\n    int_T p = k;\r\n\r\n    /* Scan the lower triangular part of this column only\r\n     * Record row of largest value\r\n     */\r\n    {\r\n      int_T i;\r\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\r\n      for (i = k+1; i < n; i++) {\r\n        real_T q = fabs(A[i+kn]);\r\n        if (q > Amax) {p = i; Amax = q;}\r\n      }\r\n    }\r\n\r\n    /* swap rows if required */\r\n    if (p != k) {\r\n      int_T j;\r\n      int32_T t1;\r\n      for (j = 0; j < n; j++) {\r\n        real_T t;\r\n        const int_T j_n = j*n;\r\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\r\n      }\r\n      /* swap pivot row indices */\r\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\r\n    }\r\n\r\n    /* column reduction */\r\n    {\r\n      real_T Adiag = A[k+kn];\r\n      int_T i,j;\r\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\r\n\r\n        /* divide lower triangular part of column by max */\r\n        Adiag = 1.0/Adiag;\r\n        for (i = k+1; i < n; i++) {\r\n          A[i+kn] *= Adiag;\r\n        }\r\n\r\n        /* subtract multiple of column from remaining columns */\r\n        for (j = k+1; j < n; j++) {\r\n          int_T j_n = j*n;\r\n          for (i = k+1; i < n; i++) {\r\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_lu_real.c */\r\n"},{"name":"rt_matrixlib.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef rt_matrixlib_h\r\n#define rt_matrixlib_h\r\n\r\n/* Copyright 2007-2013 The MathWorks, Inc.\r\n *\r\n * File    : rt_matrixlib.h\r\n * Abstract:\r\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\r\n *\r\n */\r\n\r\n\r\n/*==========*\r\n * Includes *\r\n *==========*/\r\n\r\n#include \"rtwtypes.h\"\r\n#include <limits.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* Matrix Multiplication Utility Functions */\r\nextern void rt_MatMultRR_Dbl(real_T         *y, \r\n                             const real_T   *A, \r\n                             const real_T   *B, \r\n                             const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Dbl(creal_T       *y,\r\n                             const real_T  *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCR_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const real_T  *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCC_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultRR_Sgl(real32_T       *y,\r\n                             const real32_T *A,\r\n                             const real32_T *B,\r\n                             const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\r\n                             const real32_T  *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const real32_T  *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\r\n                                   const real_T *A,\r\n                                   const real_T *B,\r\n                                   const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\r\n                                   const real_T  *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const real_T  *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n#endif\r\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\r\n                                   const real32_T *A,\r\n                                   const real32_T *B,\r\n                                   const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\r\n                                   const real32_T  *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const real32_T  *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n#endif \r\n\r\n/* Matrix Inversion Utility Functions */\r\nextern void rt_lu_real(real_T      *A,\r\n                       const int_T n,\r\n                       int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx(creal_T *A,\r\n                       const int_T n,\r\n                       int32_T *piv);\r\n#endif\r\n\r\nextern void rt_lu_real_sgl(real32_T      *A,\r\n                           const int_T n,\r\n                           int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx_sgl(creal32_T *A,\r\n                           const int_T n,\r\n                           int32_T *piv);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                          const real_T    *pb,\r\n                                          real_T          *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                         const real_T  *pb,\r\n                                         real_T        *x,\r\n                                         int_T          N,\r\n                                         int_T          P,\r\n                                         const int32_T *piv,\r\n                                         boolean_T      unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\r\n                                         const real_T    *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\r\n                                          const real32_T    *pb,\r\n                                          real32_T          *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\r\n                                         const real32_T    *pb,\r\n                                         real32_T    *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\r\n                                         const real32_T    *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\n\r\nextern void rt_MatDivRR_Dbl(real_T        *Out,\r\n                            const real_T  *In1,\r\n                            const real_T  *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            real_T        *x,\r\n                            const int_T    dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\r\n                            const real_T  *In1,\r\n                            const creal_T *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const real_T  *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const creal_T *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n#endif\r\n\r\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\r\n                            const real32_T  *In1,\r\n                            const real32_T  *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            real32_T        *x,\r\n                            const int_T      dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\r\n                            const real32_T  *In1,\r\n                            const creal32_T *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const real32_T  *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const creal32_T *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n#endif\r\n\r\n\r\n/* Matrix multiplication defines */\r\n\r\n/* Quick (approximate) complex absolute value: */\r\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\r\n\r\n/* Quick (approximate) complex absolute value for singles: */\r\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \r\n\r\n#ifdef CREAL_T\r\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\r\n                                const creal_T In1,\r\n                                const creal_T In2);\r\n\r\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\r\n                                  const creal_T In1,\r\n                                  const creal_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\r\n                                     const creal_T In1);\r\n\r\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\r\n                                const creal32_T In1,\r\n                                const creal32_T In2);\r\n\r\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\r\n                                  const creal32_T In1,\r\n                                  const creal32_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\r\n                                     const creal32_T In1);\r\n\r\n#endif\r\n\r\nextern real_T rt_Hypot_Dbl(real_T In1,\r\n                           real_T In2);\r\n\r\nextern real32_T rt_Hypot_Sgl(real32_T In1,\r\n                             real32_T In2);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* rt_matrixlib_h */\r\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\r\n *\r\n * File: rt_matrixlib_dbl.c\r\n *\r\n * Abstract:\r\n *      Simulink Coder utility functions\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n#ifdef CREAL_T\r\nvoid rt_ComplexTimes_Dbl(creal_T* c,\r\n                         const creal_T a,\r\n                         const creal_T b)\r\n{\r\n    if (a.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.re * b.im;\r\n        if (b.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (b.re == 0.0 || a.re == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else if (b.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0 || a.re == 0.0) { \r\n            c->re = 0.0;\r\n        }\r\n    } else if (a.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0) {\r\n            c->im = 0.0;\r\n        }\r\n    } else if (b.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.re * b.im;\r\n    } else {\r\n        c->re = a.re * b.re - a.im * b.im;\r\n        c->im = a.re * b.im + a.im * b.re;\r\n    }\r\n}\r\n\r\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\r\n                           const creal_T a,\r\n                           const creal_T b)\r\n{\r\n    if (b.im == 0.0) {\r\n        c->re = a.re / b.re;\r\n        if (a.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else { /* a.im != 0.0 */\r\n            c->im = a.im / b.re;\r\n            if (a.re == 0.0) {\r\n                c->re = 0.0;\r\n            }\r\n        }\r\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\r\n        c->re = a.im / b.im;\r\n        c->im = -a.re / b.im;\r\n        if (a.re == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (a.im == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else {\r\n        real_T brm = fabs(b.re);\r\n        real_T bim = fabs(b.im);\r\n        if (brm > bim) {\r\n            real_T s = b.im / b.re;\r\n            real_T d = b.re + s * b.im;\r\n            c->im = (a.im - s * a.re) / d;\r\n            c->re = (a.re + s * a.im) / d;\r\n        } else if (brm == bim) {\r\n            real_T half = 0.5;\r\n            real_T sgnbr = b.re > 0.0 ? half : -half;\r\n            real_T sgnbi = b.im > 0.0 ? half : -half;\r\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\r\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\r\n        } else {\r\n            real_T s = b.re / b.im;\r\n            real_T d = b.im + s * b.re;\r\n            c->im = (s * a.im - a.re) / d;\r\n            c->re = (s * a.re + a.im) / d;\r\n        }\r\n    }\r\n}\r\n\r\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\r\n                              const creal_T In1)\r\n{\r\n    creal_T y;\r\n    y.re = 1.0;\r\n    y.im = 0.0;\r\n\r\n    rt_ComplexRDivide_Dbl(Out, y, In1);\r\n}\r\n\r\n#endif\r\n\r\n\r\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\r\n{\r\n    real_T y;\r\n    if (a != a || b != b) {\r\n        y = a + b;\r\n    } else {\r\n        real_T t;\r\n        if (fabs(a) > fabs(b)) {\r\n            t = b/a;\r\n            y = fabs(a)*sqrt(1.0 + t*t);\r\n        } else {\r\n            if (b == 0.0) {\r\n                y = 0.0;\r\n            } else {\r\n                t = a/b;\r\n                y = fabs(b)*sqrt(1.0 + t*t);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return y;\r\n}\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n"},{"name":"SIM0_627956e1_1.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_std.h\"\r\n#include \"pm_default_allocator.h\"\r\n#include \"ne_dae_fwd.h\"\r\n#include \"ne_profiler_fwd.h\"\r\n#include \"ne_dae_construct.h\"\r\n#include \"nesl_la.h\"\r\n#include \"SIM0_627956e1_1.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n\r\nvoid SIM0_627956e1_1_dae( NeDae **dae, const NeModelParameters *modelParams,\r\n  const NeSolverParameters *solverParams)\r\n{\r\n  PmAllocator *ne_allocator;\r\n  const McLinearAlgebraFactory *linear_algebra_ptr =\r\n    (solverParams->mLinearAlgebra == NE_FULL_LA) ?\r\n    get_rtw_linear_algebra() :\r\n    ((solverParams->mLinearAlgebra == NE_SPARSE_LA) ?\r\n     mc_get_csparse_linear_algebra() :\r\n     get_auto_linear_algebra());\r\n  NeRtpValues *rtpValues = NULL;\r\n  ne_allocator = pm_default_allocator();\r\n  ne_dae_create( dae,\r\n                SIM0_627956e1_1_dae_ds( ne_allocator ),\r\n                NULL,\r\n                FALSE,\r\n                rtpValues,\r\n                *solverParams,\r\n                *modelParams,\r\n                linear_algebra_ptr,\r\n                NULL,\r\n                NULL,\r\n                NULL,\r\n                ne_allocator,\r\n                DAEMON_CHOICE_NONE);\r\n}\r\n"},{"name":"SIM0_627956e1_1.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __SIM0_627956e1_1_h__\r\n#define __SIM0_627956e1_1_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void SIM0_627956e1_1_dae( NeDae **dae, const NeModelParameters\r\n    *modelParams,\r\n    const NeSolverParameters *solverParams);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n/* SIM0_627956e1_1_ds.c - body for module SIM0_627956e1_1_ds */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_zc.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_il.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_all.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_act.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_exp.h\"\r\n#include \"SIM0_627956e1_1_ds_log.h\"\r\n#include \"SIM0_627956e1_1_ds_tdxf_p.h\"\r\n#include \"SIM0_627956e1_1_ds_dxf_p.h\"\r\n#include \"SIM0_627956e1_1_ds_dxf.h\"\r\n#include \"SIM0_627956e1_1_ds_mode.h\"\r\n#include \"SIM0_627956e1_1_ds_f.h\"\r\n#include \"SIM0_627956e1_1_ds_duf.h\"\r\n#include \"SIM0_627956e1_1_ds_assert.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"ssc_ml_fun.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n\r\nstatic int32_T ds_m_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_m(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dum_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dum(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_a_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_a(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_b_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_b(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_c_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_c(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vpf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vsf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf0(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_duf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_tduf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_v_x(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cer(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddcer(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddcer_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ic(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_icr(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_im(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_id(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_il(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_freqs(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_y(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_duy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dty_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dty(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_r(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_i(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_sfo(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_sfp(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_init_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_init_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_passert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_iassert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_t(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v0(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_tmax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_l(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_j(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qx(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qu(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qt(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_q1(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qx_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qu_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_q1_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_var_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_eq_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_slv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_nldv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_sclv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_imin(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_imax(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dimin(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dimax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_freqs(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic void release_reference(NeDynamicSystem *ds);\r\nstatic void get_reference(NeDynamicSystem *ds);\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T);\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp);\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr);\r\nstatic NeEquationData s_equation_data[15] = { { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/Capacitor\", 1U, 0U, TRUE, 1.0, \"1\", }, {\r\n    \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/Diode\", 1U, 1U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/Diode\", 3U, 2U, TRUE, 1.0,\r\n    \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\", 3U, 5U,\r\n    TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"SIM0/SIM/SPMT Switch\", 5U, 8U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\", 7U, 13U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\", 9U, 20U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\",\r\n    11U, 29U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"SIM0/SIM/SPMT Switch\", 13U, 40U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\", 15U, 53U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\", 15U, 68U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/SPMT Switch\",\r\n    11U, 83U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"SIM0/SIM/Switch\", 3U, 94U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/Switch1\", 3U, 97U, TRUE, 1.0, \"1\", }, {\r\n    \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"SIM0/SIM/Switch2\", 3U, 100U, TRUE, 1.0,\r\n    \"1\", } };\r\n\r\nstatic NeCERData *s_cer_data = NULL;\r\nstatic NeICRData *s_icr_data = NULL;\r\nstatic NeVariableData s_variable_data[15] = { { \"SIM.Capacitor.vc\", 0U, 0,\r\n    \"SIM0/SIM/Capacitor\", 1.0, \"1\", 0.0, TRUE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"SIM.Diode.private.Cjunction.vc\", 0U, 0, \"SIM0/SIM/Diode\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Capacitor voltage\", }, {\r\n    \"SIM.SPMT_Switch.i3\", 0U, 0, \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Current (p -> n3)\", }, {\r\n    \"SIM.Switch.v\", 0U, 0, \"SIM0/SIM/Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1,\r\n        1 } }, NE_INIT_MODE_NONE, \"Voltage\", }, { \"SIM.Resistor.p.v\", 0U, 1,\r\n    \"SIM0/SIM/Resistor\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage\", }, { \"SIM.SPMT_Switch.v2\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n2)\", }, { \"SIM.Diode.i_capacitor\", 0U, 0,\r\n    \"SIM0/SIM/Diode\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Junction capacitance current\", }, { \"SIM.Switch1.v\", 0U,\r\n    0, \"SIM0/SIM/Switch1\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage\", }, { \"SIM.SPMT_Switch.connected_port_index\",\r\n    0U, 0, \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Connected port index\", }, { \"SIM.SPMT_Switch.v1\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n1)\", }, { \"SIM.SPMT_Switch.v4\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n4)\", }, { \"SIM.SPMT_Switch.v5\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n5)\", }, { \"SIM.SPMT_Switch.v6\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n6)\", }, { \"SIM.SPMT_Switch.v7\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n7)\", }, { \"SIM.SPMT_Switch.v8\", 0U, 0,\r\n    \"SIM0/SIM/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n8)\", } };\r\n\r\nstatic NeVariableData s_discrete_data[1] = { {\r\n    \"SIM.SPMT_Switch.stuck_port_index\", 0U, 0, \"SIM0/SIM/SPMT Switch\", 1.0, \"1\",\r\n    0.0, FALSE, FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Stuck port index\", } };\r\n\r\nstatic NeObservableData s_observable_data[124] = { { \"SIM.Capacitor.i\",\r\n    \"SIM0/SIM/Capacitor\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"SIM.Capacitor.n.v\", \"SIM0/SIM/Capacitor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Capacitor.p.v\",\r\n    \"SIM0/SIM/Capacitor\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Capacitor.v\", \"SIM0/SIM/Capacitor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Capacitor.vc\",\r\n    \"SIM0/SIM/Capacitor\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_MANDATORY, FALSE, TRUE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Capacitor voltage\", }, { \"SIM.Capacitor.power_dissipated\",\r\n    \"SIM0/SIM/Capacitor\", { { 1, 1 } }, \"kW\", 1.0e-6, \"kW\",\r\n    NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"SIM.Controlled_Current_Source.head.v\", \"SIM0/SIM/Controlled Current Source\",\r\n    { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Current_Source.i\", \"SIM0/SIM/Controlled Current Source\", { {\r\n        1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"SIM.Controlled_Current_Source.iT\", \"SIM0/SIM/Controlled Current Source\", {\r\n        { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"iT\", }, {\r\n    \"SIM.Controlled_Current_Source.tail.v\", \"SIM0/SIM/Controlled Current Source\",\r\n    { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Current_Source.v\", \"SIM0/SIM/Controlled Current Source\", { {\r\n        1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"SIM.Controlled_Current_Source1.head.v\",\r\n    \"SIM0/SIM/Controlled Current Source1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Current_Source1.i\", \"SIM0/SIM/Controlled Current Source1\", {\r\n      { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"SIM.Controlled_Current_Source1.iT\", \"SIM0/SIM/Controlled Current Source1\",\r\n      { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"iT\", }, {\r\n    \"SIM.Controlled_Current_Source1.tail.v\",\r\n    \"SIM0/SIM/Controlled Current Source1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Current_Source1.v\", \"SIM0/SIM/Controlled Current Source1\", {\r\n      { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"SIM.Controlled_Voltage_Source.i\", \"SIM0/SIM/Controlled Voltage Source\", { {\r\n        1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"SIM.Controlled_Voltage_Source.n.v\", \"SIM0/SIM/Controlled Voltage Source\", {\r\n      { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    TRUE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Voltage_Source.p.v\", \"SIM0/SIM/Controlled Voltage Source\", {\r\n      { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Voltage_Source.v\", \"SIM0/SIM/Controlled Voltage Source\", { {\r\n        1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"SIM.Controlled_Voltage_Source.vT\", \"SIM0/SIM/Controlled Voltage Source\", {\r\n        { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"SIM.Controlled_Voltage_Source1.i\", \"SIM0/SIM/Controlled Voltage Source1\", {\r\n      { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"SIM.Controlled_Voltage_Source1.n.v\", \"SIM0/SIM/Controlled Voltage Source1\",\r\n    { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Voltage_Source1.p.v\", \"SIM0/SIM/Controlled Voltage Source1\",\r\n    { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Controlled_Voltage_Source1.v\", \"SIM0/SIM/Controlled Voltage Source1\", {\r\n      { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"SIM.Controlled_Voltage_Source1.vT\", \"SIM0/SIM/Controlled Voltage Source1\",\r\n      { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"SIM.Current_Sensor.I\", \"SIM0/SIM/Current Sensor\", { { 1, 1 } }, \"A\", 1.0,\r\n    \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"I\", }, { \"SIM.Current_Sensor.i1\",\r\n    \"SIM0/SIM/Current Sensor\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"SIM.Current_Sensor.n.v\",\r\n    \"SIM0/SIM/Current Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Current_Sensor.p.v\",\r\n    \"SIM0/SIM/Current Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Current_Sensor_I\",\r\n    \"SIM0/SIM/PS-Simulink\\nConverter\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current_Sensor_I\", }, {\r\n    \"SIM.Diode.private.Cjunction.i\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"A\", 1.0,\r\n    \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"SIM.Diode.private.Cjunction.n.v\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Diode.private.Cjunction.p.v\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Diode.private.Cjunction.v\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Diode.private.Cjunction.vc\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Capacitor voltage\", }, {\r\n    \"SIM.Diode.Tsim\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, { \"SIM.Diode.fault_input\",\r\n    \"SIM0/SIM/Diode\", { { 1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_DERIVED,\r\n    NE_INIT_MODE_NONE, TRUE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Input fault trigger\", }, { \"SIM.Diode.i\", \"SIM0/SIM/Diode\", { { 1, 1 } },\r\n    \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"SIM.Diode.i_capacitor\",\r\n    \"SIM0/SIM/Diode\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Junction capacitance current\", }, { \"SIM.Diode.i_diode\", \"SIM0/SIM/Diode\",\r\n      { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\",\r\n  }, { \"SIM.Diode.i_out\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Diode current output\", }, {\r\n    \"SIM.Diode.v_diode\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"SIM.Diode.n.v\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Diode.ni.v\",\r\n    \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Diode.p.v\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Diode.power_dissipated\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, { \"SIM.Diode.v\",\r\n    \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Diode.v_capacitor\", \"SIM0/SIM/Diode\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"SIM.Electrical_Reference.V.v\", \"SIM0/SIM/Electrical Reference\", { { 1, 1 }\r\n    }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Resistor.i\",\r\n    \"SIM0/SIM/Resistor\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"SIM.Resistor.n.v\", \"SIM0/SIM/Resistor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Resistor.p.v\",\r\n    \"SIM0/SIM/Resistor\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Resistor.v\", \"SIM0/SIM/Resistor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Resistor.power_dissipated\", \"SIM0/SIM/Resistor\", { { 1, 1 } },\r\n    \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"SIM.Resistor1.i\", \"SIM0/SIM/Resistor1\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"SIM.Resistor1.n.v\",\r\n    \"SIM0/SIM/Resistor1\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Resistor1.p.v\", \"SIM0/SIM/Resistor1\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Resistor1.v\",\r\n    \"SIM0/SIM/Resistor1\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Resistor1.power_dissipated\", \"SIM0/SIM/Resistor1\", { {\r\n        1, 1 } }, \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE,\r\n    \"power_dissipated\", }, { \"SIM.SPMT_Switch.connected_port_index\",\r\n    \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Connected port index\", }, {\r\n    \"SIM.SPMT_Switch.i1\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> n1)\", }, {\r\n    \"SIM.SPMT_Switch.i2\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> n2)\", }, {\r\n    \"SIM.SPMT_Switch.i3\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> n3)\", }, {\r\n    \"SIM.SPMT_Switch.i4\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n4)\", }, {\r\n    \"SIM.SPMT_Switch.i5\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n5)\", }, {\r\n    \"SIM.SPMT_Switch.i6\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n6)\", }, {\r\n    \"SIM.SPMT_Switch.i7\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n7)\", }, {\r\n    \"SIM.SPMT_Switch.i8\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n8)\", }, {\r\n    \"SIM.SPMT_Switch.icom\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> all)\", }, {\r\n    \"SIM.SPMT_Switch.n1.v\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.SPMT_Switch.n2.v\",\r\n    \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.SPMT_Switch.n3.v\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.SPMT_Switch.n4.v\",\r\n    \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"SIM.SPMT_Switch.n5.v\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, { \"SIM.SPMT_Switch.n6.v\",\r\n    \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"SIM.SPMT_Switch.n7.v\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, { \"SIM.SPMT_Switch.n8.v\",\r\n    \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"SIM.SPMT_Switch.p.v\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.SPMT_Switch.power_dissipated\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } },\r\n    \"W\", 1.0, \"kW\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"SIM.SPMT_Switch.stuck_port_index\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } },\r\n    \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Stuck port index\", }, {\r\n    \"SIM.SPMT_Switch.v1\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage (p -> n1)\", }, {\r\n    \"SIM.SPMT_Switch.v2\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage (p -> n2)\", }, {\r\n    \"SIM.SPMT_Switch.v3\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage (p -> n3)\", }, {\r\n    \"SIM.SPMT_Switch.v4\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n4)\", }, {\r\n    \"SIM.SPMT_Switch.v5\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n5)\", }, {\r\n    \"SIM.SPMT_Switch.v6\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n6)\", }, {\r\n    \"SIM.SPMT_Switch.v7\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n7)\", }, {\r\n    \"SIM.SPMT_Switch.v8\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n8)\", }, {\r\n    \"SIM.SPMT_Switch.vT\", \"SIM0/SIM/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"SIM.Simulink_PS_Converter1_output\", \"SIM0/SIM/Simulink-PS\\nConverter1\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter1_output\", }, { \"SIM.Simulink_PS_Converter2_output\",\r\n    \"SIM0/SIM/Simulink-PS\\nConverter2\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter2_output\", }, {\r\n    \"SIM.Simulink_PS_Converter3_output\", \"SIM0/SIM/Simulink-PS\\nConverter3\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter3_output\", }, { \"SIM.Simulink_PS_Converter4_output\",\r\n    \"SIM0/SIM/Simulink-PS\\nConverter4\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter4_output\", }, {\r\n    \"SIM.Simulink_PS_Converter5_output\", \"SIM0/SIM/Simulink-PS\\nConverter5\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter5_output\", }, { \"SIM.Simulink_PS_Converter6_output\",\r\n    \"SIM0/SIM/Simulink-PS\\nConverter6\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter6_output\", }, {\r\n    \"SIM.Simulink_PS_Converter7_output\", \"SIM0/SIM/Simulink-PS\\nConverter7\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter7_output\", }, { \"SIM.Simulink_PS_Converter_output\",\r\n    \"SIM0/SIM/Simulink-PS\\nConverter\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter_output\", }, {\r\n    \"SIM.Switch.i\", \"SIM0/SIM/Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"SIM.Switch.n.v\",\r\n    \"SIM0/SIM/Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, TRUE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\",\r\n  }, { \"SIM.Switch.p.v\", \"SIM0/SIM/Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Switch.v\",\r\n    \"SIM0/SIM/Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Switch.power_dissipated\", \"SIM0/SIM/Switch\", { { 1, 1 }\r\n    }, \"A*V\", 1.0e-6, \"A*V\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"SIM.Switch.vT\", \"SIM0/SIM/Switch\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, { \"SIM.Switch1.i\",\r\n    \"SIM0/SIM/Switch1\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"SIM.Switch1.n.v\", \"SIM0/SIM/Switch1\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Switch1.p.v\",\r\n    \"SIM0/SIM/Switch1\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Switch1.v\", \"SIM0/SIM/Switch1\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Switch1.power_dissipated\", \"SIM0/SIM/Switch1\", { { 1, 1 } }, \"A*V\",\r\n    1.0e-6, \"A*V\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"SIM.Switch1.vT\", \"SIM0/SIM/Switch1\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, { \"SIM.Switch2.i\",\r\n    \"SIM0/SIM/Switch2\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"SIM.Switch2.n.v\", \"SIM0/SIM/Switch2\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Switch2.p.v\",\r\n    \"SIM0/SIM/Switch2\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"SIM.Switch2.v\", \"SIM0/SIM/Switch2\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"SIM.Switch2.power_dissipated\", \"SIM0/SIM/Switch2\", { { 1, 1 } }, \"A*V\",\r\n    1.0e-6, \"A*V\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"SIM.Switch2.vT\", \"SIM0/SIM/Switch2\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, { \"SIM.Voltage_Sensor.V\",\r\n    \"SIM0/SIM/Voltage Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, { \"SIM.Voltage_Sensor.n.v\",\r\n    \"SIM0/SIM/Voltage Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Voltage_Sensor.p.v\",\r\n    \"SIM0/SIM/Voltage Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Voltage_Sensor1.V\",\r\n    \"SIM0/SIM/Voltage Sensor1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, { \"SIM.Voltage_Sensor1.n.v\",\r\n    \"SIM0/SIM/Voltage Sensor1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Voltage_Sensor1.p.v\",\r\n    \"SIM0/SIM/Voltage Sensor1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"SIM.Voltage_Sensor1_V\",\r\n    \"SIM0/SIM/PS-Simulink\\nConverter1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage_Sensor1_V\", }, {\r\n    \"SIM.Voltage_Sensor_V\", \"SIM0/SIM/PS-Simulink\\nConverter2\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage_Sensor_V\", } };\r\n\r\nstatic NeModeData *s_major_mode_data = NULL;\r\nstatic NeZCData s_zc_data[16] = { { \"SIM0/SIM/Diode\", 1U, 0U, \"SIM.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 1U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 2U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 3U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 4U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 5U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 6U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 7U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 8U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 9U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 10U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 11U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/SPMT Switch\", 1U, 12U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/Switch\", 1U, 13U, \"SIM.Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/Switch1\", 1U, 14U, \"SIM.Switch1\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    NE_ZC_TYPE_FALSE, }, { \"SIM0/SIM/Switch2\", 1U, 15U, \"SIM.Switch2\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    NE_ZC_TYPE_FALSE, } };\r\n\r\nstatic NeRange s_range[16] = { {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeAssertData s_assert_data[55] = { { \"SIM0/SIM/SPMT Switch\", 1U, 0U,\r\n    \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not an integer value.  Fractional indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonIntegerIndex\", }, { \"SIM0/SIM/SPMT Switch\",\r\n    1U, 1U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not a positive value.  Zero and negative indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonPositiveIndex\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 2U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"Index is out of range.\",\r\n    \"physmod:common:data2:mf:xlate:IndexOutOfRange\", }, { \"SIM0/SIM/SPMT Switch\",\r\n    1U, 3U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not an integer value.  Fractional indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonIntegerIndex\", }, { \"SIM0/SIM/SPMT Switch\",\r\n    1U, 4U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not a positive value.  Zero and negative indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonPositiveIndex\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 5U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"Index is out of range.\",\r\n    \"physmod:common:data2:mf:xlate:IndexOutOfRange\", }, { \"SIM0/SIM/Capacitor\",\r\n    1U, 6U, \"SIM.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"SIM0/SIM/Capacitor\", 1U, 7U, \"SIM.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"SIM0/SIM/Capacitor\", 1U, 8U, \"SIM.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"SIM0/SIM/Capacitor\", 1U, 9U, \"SIM.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"SIM0/SIM/Resistor\", 1U, 10U, \"SIM.Resistor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"SIM0/SIM/Resistor\", 1U, 11U, \"SIM.Resistor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"SIM0/SIM/Resistor1\", 1U, 12U, \"SIM.Resistor1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"SIM0/SIM/Resistor1\", 1U, 13U, \"SIM.Resistor1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"SIM0/SIM/Diode\", 1U, 14U, \"SIM.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/Diode\", 1U, 15U, \"SIM.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/Diode\", 1U, 16U, \"SIM.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 17U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 18U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 19U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 20U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 21U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 22U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 23U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 24U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 25U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 26U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 27U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 28U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 29U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 30U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 31U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 32U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 33U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 34U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 35U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 36U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 37U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 38U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 39U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 40U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 41U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 42U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 43U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 44U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 45U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 46U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 47U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 48U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 49U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 50U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/SPMT Switch\", 1U, 51U, \"SIM.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/Switch\", 1U, 52U, \"SIM.Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/Switch1\", 1U, 53U, \"SIM.Switch1\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"SIM0/SIM/Switch2\", 1U, 54U, \"SIM.Switch2\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", } };\r\n\r\nstatic NeRange s_assert_range[55] = { {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 16U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 16U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 16U, 48U, 22U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeAssertData *s_param_assert_data = NULL;\r\nstatic NeRange *s_param_assert_range = NULL;\r\nstatic NeAssertData *s_initial_assert_data = NULL;\r\nstatic NeRange *s_initial_assert_range = NULL;\r\nstatic NeRange s_equation_range[103] = { {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    46U, 9U, 46U, 24U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 9U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    46U, 9U, 46U, 24U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 9U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    46U, 9U, 46U, 24U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 9U, 48U, 22U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeRange *s_cer_range = NULL;\r\nstatic NeRange *s_icr_range = NULL;\r\nstatic NeParameterData *s_logical_parameter_data = NULL;\r\nstatic NeParameterData *s_integer_parameter_data = NULL;\r\nstatic NeParameterData *s_index_parameter_data = NULL;\r\nstatic NeParameterData *s_real_parameter_data = NULL;\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM_P.mNumCol = 15;\r\n  out->mM_P.mNumRow = 15;\r\n  out->mM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM.mN = 2;\r\n  out->mM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMM.mN = 2;\r\n  out->mVMM.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM_P.mNumCol = 15;\r\n  out->mDXM_P.mNumRow = 2;\r\n  out->mDXM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mDXM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM.mN = 0;\r\n  out->mDXM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM_P.mNumCol = 1;\r\n  out->mDDM_P.mNumRow = 2;\r\n  out->mDDM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDDM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM.mN = 0;\r\n  out->mDDM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM_P.mNumCol = 8;\r\n  out->mDUM_P.mNumRow = 2;\r\n  out->mDUM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mDUM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM.mN = 0;\r\n  out->mDUM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM_P.mNumCol = 1;\r\n  out->mDTM_P.mNumRow = 2;\r\n  out->mDTM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM.mN = 0;\r\n  out->mDTM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM_P.mNumCol = 0;\r\n  out->mDPM_P.mNumRow = 2;\r\n  out->mDPM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDPM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM.mN = 0;\r\n  out->mDPM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA_P.mNumCol = 15;\r\n  out->mA_P.mNumRow = 15;\r\n  out->mA_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mA_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA.mN = 4;\r\n  out->mA.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 4);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB_P.mNumCol = 8;\r\n  out->mB_P.mNumRow = 15;\r\n  out->mB_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mB_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB.mN = 1;\r\n  out->mB.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC_P.mNumCol = 1;\r\n  out->mC_P.mNumRow = 15;\r\n  out->mC_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mC_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC.mN = 0;\r\n  out->mC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mF.mN = 15;\r\n  out->mF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMF.mN = 15;\r\n  out->mVMF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVPF.mN = 15;\r\n  out->mVPF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVSF.mN = 15;\r\n  out->mVSF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF.mN = 15;\r\n  out->mSLF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF0.mN = 15;\r\n  out->mSLF0.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF_P.mNumCol = 15;\r\n  out->mDXF_P.mNumRow = 15;\r\n  out->mDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    29);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF.mN = 29;\r\n  out->mDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 29);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF_P.mNumCol = 8;\r\n  out->mDUF_P.mNumRow = 15;\r\n  out->mDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    8);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF.mN = 8;\r\n  out->mDUF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 8);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF_P.mNumCol = 1;\r\n  out->mDTF_P.mNumRow = 15;\r\n  out->mDTF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF.mN = 0;\r\n  out->mDTF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF_P.mNumCol = 1;\r\n  out->mDDF_P.mNumRow = 15;\r\n  out->mDDF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDDF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF.mN = 0;\r\n  out->mDDF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF_P.mNumCol = 0;\r\n  out->mDPDXF_P.mNumRow = 29;\r\n  out->mDPDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDPDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF.mN = 0;\r\n  out->mDPDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF_P.mNumCol = 0;\r\n  out->mDWF_P.mNumRow = 15;\r\n  out->mDWF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDWF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF.mN = 0;\r\n  out->mDWF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUF_P.mNumCol = 8;\r\n  out->mTDUF_P.mNumRow = 15;\r\n  out->mTDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mTDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    13);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXF_P.mNumCol = 15;\r\n  out->mTDXF_P.mNumRow = 15;\r\n  out->mTDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mTDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    41);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_P.mNumCol = 8;\r\n  out->mDNF_P.mNumRow = 15;\r\n  out->mDNF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mDNF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF.mN = 0;\r\n  out->mDNF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_V_X.mN = 15;\r\n  out->mDNF_V_X.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCER.mN = 0;\r\n  out->mCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER.mN = 0;\r\n  out->mDXCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER_P.mNumCol = 15;\r\n  out->mDXCER_P.mNumRow = 0;\r\n  out->mDXCER_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 16);\r\n  out->mDXCER_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDCER.mN = 0;\r\n  out->mDDCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDCER_P.mNumCol = 1;\r\n  out->mDDCER_P.mNumRow = 0;\r\n  out->mDDCER_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDDCER_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIC.mN = 15;\r\n  out->mIC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR.mN = 0;\r\n  out->mICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IM.mN = 0;\r\n  out->mICR_IM.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_ID.mN = 0;\r\n  out->mICR_ID.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IL.mN = 0;\r\n  out->mICR_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR.mN = 0;\r\n  out->mDXICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR_P.mNumCol = 15;\r\n  out->mDXICR_P.mNumRow = 0;\r\n  out->mDXICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 16);\r\n  out->mDXICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR.mN = 0;\r\n  out->mDDICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR_P.mNumCol = 1;\r\n  out->mDDICR_P.mNumRow = 0;\r\n  out->mDDICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDDICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUICR_P.mNumCol = 8;\r\n  out->mTDUICR_P.mNumRow = 0;\r\n  out->mTDUICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 9);\r\n  out->mTDUICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM_P.mNumCol = 15;\r\n  out->mICRM_P.mNumRow = 0;\r\n  out->mICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM.mN = 0;\r\n  out->mICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM_P.mNumCol = 15;\r\n  out->mDXICRM_P.mNumRow = 0;\r\n  out->mDXICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 16);\r\n  out->mDXICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM.mN = 0;\r\n  out->mDXICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM_P.mNumCol = 1;\r\n  out->mDDICRM_P.mNumRow = 0;\r\n  out->mDDICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDDICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM.mN = 0;\r\n  out->mDDICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_freqs(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mFREQS.mN = 0;\r\n  out->mFREQS.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDUY_P.mNumCol = 8;\r\n  out->mMDUY_P.mNumRow = 3;\r\n  out->mMDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mMDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDXY_P.mNumCol = 15;\r\n  out->mMDXY_P.mNumRow = 3;\r\n  out->mMDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mMDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUY_P.mNumCol = 8;\r\n  out->mTDUY_P.mNumRow = 3;\r\n  out->mTDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mTDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXY_P.mNumCol = 15;\r\n  out->mTDXY_P.mNumRow = 3;\r\n  out->mTDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mTDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mY.mN = 3;\r\n  out->mY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY_P.mNumCol = 15;\r\n  out->mDXY_P.mNumRow = 3;\r\n  out->mDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY.mN = 3;\r\n  out->mDXY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY_P.mNumCol = 8;\r\n  out->mDUY_P.mNumRow = 3;\r\n  out->mDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY.mN = 3;\r\n  out->mDUY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY_P.mNumCol = 1;\r\n  out->mDTY_P.mNumRow = 3;\r\n  out->mDTY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY.mN = 0;\r\n  out->mDTY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMODE.mN = 16;\r\n  out->mMODE.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mZC.mN = 16;\r\n  out->mZC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_R.mN = 0;\r\n  out->mCACHE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_I.mN = 0;\r\n  out->mCACHE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_R.mN = 1;\r\n  out->mUPDATE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_I.mN = 0;\r\n  out->mUPDATE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_R.mN = 1;\r\n  out->mUPDATE2_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_I.mN = 0;\r\n  out->mUPDATE2_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_R.mN = 1;\r\n  out->mLOCK_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_I.mN = 0;\r\n  out->mLOCK_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_R.mN = 1;\r\n  out->mLOCK2_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_I.mN = 0;\r\n  out->mLOCK2_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFO.mN = 0;\r\n  out->mSFO.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFP.mN = 0;\r\n  out->mSFP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_R.mN = 1;\r\n  out->mINIT_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_I.mN = 0;\r\n  out->mINIT_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOG.mN = 109;\r\n  out->mLOG.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 109);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mASSERT.mN = 55;\r\n  out->mASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    55);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mPASSERT.mN = 0;\r\n  out->mPASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIASSERT.mN = 0;\r\n  out->mIASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_T.mN = 0;\r\n  out->mDEL_T.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V.mN = 0;\r\n  out->mDEL_V.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V0.mN = 0;\r\n  out->mDEL_V0.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_TMAX.mN = 0;\r\n  out->mDEL_TMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT_P.mNumCol = 15;\r\n  out->mDXDELT_P.mNumRow = 0;\r\n  out->mDXDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 16);\r\n  out->mDXDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT.mN = 0;\r\n  out->mDXDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT_P.mNumCol = 8;\r\n  out->mDUDELT_P.mNumRow = 0;\r\n  out->mDUDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 9);\r\n  out->mDUDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT.mN = 0;\r\n  out->mDUDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT_P.mNumCol = 1;\r\n  out->mDTDELT_P.mNumRow = 0;\r\n  out->mDTDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDTDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT.mN = 0;\r\n  out->mDTDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_EXP.mN = 118;\r\n  out->mOBS_EXP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    118);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ACT.mN = 118;\r\n  out->mOBS_ACT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    118);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ALL.mN = 118;\r\n  out->mOBS_ALL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    118);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_IL.mN = 118;\r\n  out->mOBS_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 118);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_L.mN = 0;\r\n  out->mDP_L.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_I.mN = 0;\r\n  out->mDP_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_J.mN = 0;\r\n  out->mDP_J.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_R.mN = 0;\r\n  out->mDP_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX.mN = 0;\r\n  out->mQX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU.mN = 0;\r\n  out->mQU.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT.mN = 0;\r\n  out->mQT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1.mN = 0;\r\n  out->mQ1.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX_P.mNumCol = 15;\r\n  out->mQX_P.mNumRow = 15;\r\n  out->mQX_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  out->mQX_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU_P.mNumCol = 8;\r\n  out->mQU_P.mNumRow = 15;\r\n  out->mQU_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mQU_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT_P.mNumCol = 1;\r\n  out->mQT_P.mNumRow = 15;\r\n  out->mQT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1_P.mNumCol = 1;\r\n  out->mQ1_P.mNumRow = 15;\r\n  out->mQ1_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQ1_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVAR_TOL.mN = 15;\r\n  out->mVAR_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mEQ_TOL.mN = 15;\r\n  out->mEQ_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLV.mN = 15;\r\n  out->mLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLV.mN = 15;\r\n  out->mSLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mNLDV.mN = 15;\r\n  out->mNLDV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSCLV.mN = 15;\r\n  out->mSCLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMIN.mN = 15;\r\n  out->mIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMAX.mN = 15;\r\n  out->mIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 15);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMIN.mN = 1;\r\n  out->mDIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMAX.mN = 1;\r\n  out->mDIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic void release_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  if (--_ds->mRefCnt == 0) {\r\n    _ds->mAlloc.mFreeFcn(&_ds->mAlloc, _ds);\r\n  }\r\n}\r\n\r\nstatic void get_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  ++_ds->mRefCnt;\r\n}\r\n\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T kp)\r\n{\r\n  _NeDynamicSystem *_ds = (_NeDynamicSystem *)ds;\r\n  (void) kp;\r\n  ne_ds_get_reference(&_ds->mBase);\r\n  return &_ds->mBase;\r\n}\r\n\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp)\r\n{\r\n  (void)ds;\r\n  (void)kp;\r\n  memcpy(out->mX, in->mX.mX, sizeof(real_T)*out->mN);\r\n}\r\n\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr)\r\n{\r\n  (void)ds;\r\n  memcpy(outl->mX, inl->mX, sizeof(int32_T)*inl->mN);\r\n  memcpy(outi->mX, ini->mX, sizeof(int32_T)*ini->mN);\r\n  memcpy(outj->mX, inj->mX, sizeof(int32_T)*inj->mN);\r\n  memcpy(outr->mX, inr->mX, sizeof(real_T)*inr->mN);\r\n}\r\n\r\nNeDynamicSystem *SIM0_627956e1_1_dae_ds(PmAllocator *allocator)\r\n{\r\n  NeDynamicSystem *ds;\r\n  _NeDynamicSystem *_ds;\r\n  static SscIoInfo input_info[8];\r\n  static SscIoInfo output_info[3];\r\n\r\n  /* allocate dynamic system data and extended data */\r\n  _ds = (_NeDynamicSystem *)allocator->mCallocFcn( allocator, sizeof\r\n    (_NeDynamicSystem), 1);\r\n  _ds->mAlloc = *allocator;\r\n  _ds->mRefCnt = 1;\r\n  ds = &_ds->mBase;\r\n\r\n  /* setup sizes */\r\n  ds->mNumVariables = 15;\r\n  ds->mNumDiscreteRealVariables = 1;\r\n  ds->mNumDifferentialVariables = 2;\r\n  ds->mNumEquations = 15;\r\n  ds->mNumCEResiduals = 0;\r\n  ds->mNumICResiduals = 0;\r\n  ds->mNumFreqs = 0;\r\n  ds->mNumModes = 16;\r\n  ds->mNumMajorModes = 0;\r\n  ds->mNumRealCache = 0;\r\n  ds->mNumIntCache = 0;\r\n  ds->mNumObservables = 124;\r\n  ds->mNumObservableElements = 118;\r\n  ds->mNumZcs = 16;\r\n  ds->mNumAsserts = 55;\r\n  ds->mNumAssertRanges = 55;\r\n  ds->mNumParamAsserts = 0;\r\n  ds->mNumParamAssertRanges = 0;\r\n  ds->mNumInitialAsserts = 0;\r\n  ds->mNumInitialAssertRanges = 0;\r\n  ds->mNumRanges = 16;\r\n  ds->mNumEquationRanges = 103;\r\n  ds->mNumCERRanges = 0;\r\n  ds->mNumICRRanges = 0;\r\n  ds->mNumFundamentalSamples = 0;\r\n  ds->mNumDelays = 0;\r\n  ds->mNumLogicalParameters = 0;\r\n  ds->mNumIntegerParameters = 0;\r\n  ds->mNumIndexParameters = 0;\r\n  ds->mNumRealParameters = 0;\r\n  ds->mNumLogicalDerivedParameters = 0;\r\n  ds->mNumIntegerDerivedParameters = 0;\r\n  ds->mNumIndexDerivedParameters = 0;\r\n  ds->mNumRealDerivedParameters = 0;\r\n  ds->mIsOutputLinear = TRUE;\r\n  ds->mIsOutputSwitchedLinear = TRUE;\r\n  ds->mIsScalable = FALSE;\r\n\r\n  /* setup ios */\r\n  ds->mNumIo[SSC_INPUT_IO_TYPE] = 8;\r\n  input_info[0].mIdentifier = \"SIM.Simulink_PS_Converter7_output\";\r\n  input_info[0].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[0].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[0].mSize, 1, 1);\r\n  input_info[0].mName = \"SIM.Simulink_PS_Converter7_output\";\r\n  input_info[0].mUnit = \"1\";\r\n  input_info[1].mIdentifier = \"SIM.Simulink_PS_Converter6_output\";\r\n  input_info[1].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[1].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[1].mSize, 1, 1);\r\n  input_info[1].mName = \"SIM.Simulink_PS_Converter6_output\";\r\n  input_info[1].mUnit = \"1\";\r\n  input_info[2].mIdentifier = \"SIM.Simulink_PS_Converter1_output\";\r\n  input_info[2].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[2].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[2].mSize, 1, 1);\r\n  input_info[2].mName = \"SIM.Simulink_PS_Converter1_output\";\r\n  input_info[2].mUnit = \"1\";\r\n  input_info[3].mIdentifier = \"SIM.Simulink_PS_Converter_output\";\r\n  input_info[3].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[3].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[3].mSize, 1, 1);\r\n  input_info[3].mName = \"SIM.Simulink_PS_Converter_output\";\r\n  input_info[3].mUnit = \"1\";\r\n  input_info[4].mIdentifier = \"SIM.Simulink_PS_Converter2_output\";\r\n  input_info[4].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[4].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[4].mSize, 1, 1);\r\n  input_info[4].mName = \"SIM.Simulink_PS_Converter2_output\";\r\n  input_info[4].mUnit = \"1\";\r\n  input_info[5].mIdentifier = \"SIM.Simulink_PS_Converter3_output\";\r\n  input_info[5].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[5].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[5].mSize, 1, 1);\r\n  input_info[5].mName = \"SIM.Simulink_PS_Converter3_output\";\r\n  input_info[5].mUnit = \"1\";\r\n  input_info[6].mIdentifier = \"SIM.Simulink_PS_Converter4_output\";\r\n  input_info[6].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[6].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[6].mSize, 1, 1);\r\n  input_info[6].mName = \"SIM.Simulink_PS_Converter4_output\";\r\n  input_info[6].mUnit = \"1\";\r\n  input_info[7].mIdentifier = \"SIM.Simulink_PS_Converter5_output\";\r\n  input_info[7].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[7].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[7].mSize, 1, 1);\r\n  input_info[7].mName = \"SIM.Simulink_PS_Converter5_output\";\r\n  input_info[7].mUnit = \"1\";\r\n  ds->mIo[SSC_INPUT_IO_TYPE] = input_info;\r\n  ds->mNumIo[SSC_OUTPUT_IO_TYPE] = 3;\r\n  output_info[0].mIdentifier = \"SIM.Current_Sensor_I\";\r\n  output_info[0].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& output_info[0].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& output_info[0].mSize, 1, 1);\r\n  output_info[0].mName = \"SIM.Current_Sensor_I\";\r\n  output_info[0].mUnit = \"A\";\r\n  output_info[1].mIdentifier = \"SIM.Voltage_Sensor1_V\";\r\n  output_info[1].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& output_info[1].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& output_info[1].mSize, 1, 1);\r\n  output_info[1].mName = \"SIM.Voltage_Sensor1_V\";\r\n  output_info[1].mUnit = \"V\";\r\n  output_info[2].mIdentifier = \"SIM.Voltage_Sensor_V\";\r\n  output_info[2].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& output_info[2].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& output_info[2].mSize, 1, 1);\r\n  output_info[2].mName = \"SIM.Voltage_Sensor_V\";\r\n  output_info[2].mUnit = \"V\";\r\n  ds->mIo[SSC_OUTPUT_IO_TYPE] = output_info;\r\n\r\n  /* setup administration methods */\r\n  ds->mReleaseReference = release_reference;\r\n  ds->mGetReference = get_reference;\r\n  ds->mDiagnosticsDsFcn = diagnostics;\r\n  ds->mExpandFcn = expand;\r\n  ds->mRtpMapFcn = rtpmap;\r\n  ds->mMethods[NE_DS_METHOD_M_P] = ds_m_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_M_P] = ds_output_m_p;\r\n  ds->mMethods[NE_DS_METHOD_M] = ds_m;\r\n  ds->mMakeOutput[NE_DS_METHOD_M] = ds_output_m;\r\n  ds->mMethods[NE_DS_METHOD_VMM] = ds_vmm;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMM] = ds_output_vmm;\r\n  ds->mMethods[NE_DS_METHOD_DXM_P] = ds_dxm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM_P] = ds_output_dxm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXM] = ds_dxm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM] = ds_output_dxm;\r\n  ds->mMethods[NE_DS_METHOD_DDM_P] = ds_ddm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM_P] = ds_output_ddm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDM] = ds_ddm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM] = ds_output_ddm;\r\n  ds->mMethods[NE_DS_METHOD_DUM_P] = ds_dum_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM_P] = ds_output_dum_p;\r\n  ds->mMethods[NE_DS_METHOD_DUM] = ds_dum;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM] = ds_output_dum;\r\n  ds->mMethods[NE_DS_METHOD_DTM_P] = ds_dtm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM_P] = ds_output_dtm_p;\r\n  ds->mMethods[NE_DS_METHOD_DTM] = ds_dtm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM] = ds_output_dtm;\r\n  ds->mMethods[NE_DS_METHOD_DPM_P] = ds_dpm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM_P] = ds_output_dpm_p;\r\n  ds->mMethods[NE_DS_METHOD_DPM] = ds_dpm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM] = ds_output_dpm;\r\n  ds->mMethods[NE_DS_METHOD_A_P] = ds_a_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_A_P] = ds_output_a_p;\r\n  ds->mMethods[NE_DS_METHOD_A] = ds_a;\r\n  ds->mMakeOutput[NE_DS_METHOD_A] = ds_output_a;\r\n  ds->mMethods[NE_DS_METHOD_B_P] = ds_b_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_B_P] = ds_output_b_p;\r\n  ds->mMethods[NE_DS_METHOD_B] = ds_b;\r\n  ds->mMakeOutput[NE_DS_METHOD_B] = ds_output_b;\r\n  ds->mMethods[NE_DS_METHOD_C_P] = ds_c_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_C_P] = ds_output_c_p;\r\n  ds->mMethods[NE_DS_METHOD_C] = ds_c;\r\n  ds->mMakeOutput[NE_DS_METHOD_C] = ds_output_c;\r\n  ds->mMethods[NE_DS_METHOD_F] = SIM0_627956e1_1_ds_f;\r\n  ds->mMakeOutput[NE_DS_METHOD_F] = ds_output_f;\r\n  ds->mMethods[NE_DS_METHOD_VMF] = ds_vmf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMF] = ds_output_vmf;\r\n  ds->mMethods[NE_DS_METHOD_VPF] = ds_vpf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VPF] = ds_output_vpf;\r\n  ds->mMethods[NE_DS_METHOD_VSF] = ds_vsf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VSF] = ds_output_vsf;\r\n  ds->mMethods[NE_DS_METHOD_SLF] = ds_slf;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF] = ds_output_slf;\r\n  ds->mMethods[NE_DS_METHOD_SLF0] = ds_slf0;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF0] = ds_output_slf0;\r\n  ds->mMethods[NE_DS_METHOD_DXF_P] = SIM0_627956e1_1_ds_dxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF_P] = ds_output_dxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DXF] = SIM0_627956e1_1_ds_dxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF] = ds_output_dxf;\r\n  ds->mMethods[NE_DS_METHOD_DUF_P] = ds_duf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF_P] = ds_output_duf_p;\r\n  ds->mMethods[NE_DS_METHOD_DUF] = SIM0_627956e1_1_ds_duf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF] = ds_output_duf;\r\n  ds->mMethods[NE_DS_METHOD_DTF_P] = ds_dtf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF_P] = ds_output_dtf_p;\r\n  ds->mMethods[NE_DS_METHOD_DTF] = ds_dtf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF] = ds_output_dtf;\r\n  ds->mMethods[NE_DS_METHOD_DDF_P] = ds_ddf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF_P] = ds_output_ddf_p;\r\n  ds->mMethods[NE_DS_METHOD_DDF] = ds_ddf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF] = ds_output_ddf;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF_P] = ds_dpdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF_P] = ds_output_dpdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF] = ds_dpdxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF] = ds_output_dpdxf;\r\n  ds->mMethods[NE_DS_METHOD_DWF_P] = ds_dwf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF_P] = ds_output_dwf_p;\r\n  ds->mMethods[NE_DS_METHOD_DWF] = ds_dwf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF] = ds_output_dwf;\r\n  ds->mMethods[NE_DS_METHOD_TDUF_P] = ds_tduf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUF_P] = ds_output_tduf_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXF_P] = SIM0_627956e1_1_ds_tdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXF_P] = ds_output_tdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF_P] = ds_dnf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_P] = ds_output_dnf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF] = ds_dnf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF] = ds_output_dnf;\r\n  ds->mMethods[NE_DS_METHOD_DNF_V_X] = ds_dnf_v_x;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_V_X] = ds_output_dnf_v_x;\r\n  ds->mMethods[NE_DS_METHOD_CER] = ds_cer;\r\n  ds->mMakeOutput[NE_DS_METHOD_CER] = ds_output_cer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER] = ds_dxcer;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER] = ds_output_dxcer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER_P] = ds_dxcer_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER_P] = ds_output_dxcer_p;\r\n  ds->mMethods[NE_DS_METHOD_DDCER] = ds_ddcer;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDCER] = ds_output_ddcer;\r\n  ds->mMethods[NE_DS_METHOD_DDCER_P] = ds_ddcer_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDCER_P] = ds_output_ddcer_p;\r\n  ds->mMethods[NE_DS_METHOD_IC] = ds_ic;\r\n  ds->mMakeOutput[NE_DS_METHOD_IC] = ds_output_ic;\r\n  ds->mMethods[NE_DS_METHOD_ICR] = ds_icr;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR] = ds_output_icr;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IM] = ds_icr_im;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IM] = ds_output_icr_im;\r\n  ds->mMethods[NE_DS_METHOD_ICR_ID] = ds_icr_id;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_ID] = ds_output_icr_id;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IL] = ds_icr_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IL] = ds_output_icr_il;\r\n  ds->mMethods[NE_DS_METHOD_DXICR] = ds_dxicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR] = ds_output_dxicr;\r\n  ds->mMethods[NE_DS_METHOD_DXICR_P] = ds_dxicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR_P] = ds_output_dxicr_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICR] = ds_ddicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR] = ds_output_ddicr;\r\n  ds->mMethods[NE_DS_METHOD_DDICR_P] = ds_ddicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR_P] = ds_output_ddicr_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUICR_P] = ds_tduicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUICR_P] = ds_output_tduicr_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM_P] = ds_icrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM_P] = ds_output_icrm_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM] = ds_icrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM] = ds_output_icrm;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM_P] = ds_dxicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM_P] = ds_output_dxicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM] = ds_dxicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM] = ds_output_dxicrm;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM_P] = ds_ddicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM_P] = ds_output_ddicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM] = ds_ddicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM] = ds_output_ddicrm;\r\n  ds->mMethods[NE_DS_METHOD_FREQS] = ds_freqs;\r\n  ds->mMakeOutput[NE_DS_METHOD_FREQS] = ds_output_freqs;\r\n  ds->mMethods[NE_DS_METHOD_MDUY_P] = ds_mduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDUY_P] = ds_output_mduy_p;\r\n  ds->mMethods[NE_DS_METHOD_MDXY_P] = ds_mdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDXY_P] = ds_output_mdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUY_P] = ds_tduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUY_P] = ds_output_tduy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXY_P] = ds_tdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXY_P] = ds_output_tdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_Y] = ds_y;\r\n  ds->mMakeOutput[NE_DS_METHOD_Y] = ds_output_y;\r\n  ds->mMethods[NE_DS_METHOD_DXY_P] = ds_dxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY_P] = ds_output_dxy_p;\r\n  ds->mMethods[NE_DS_METHOD_DXY] = ds_dxy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY] = ds_output_dxy;\r\n  ds->mMethods[NE_DS_METHOD_DUY_P] = ds_duy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY_P] = ds_output_duy_p;\r\n  ds->mMethods[NE_DS_METHOD_DUY] = ds_duy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY] = ds_output_duy;\r\n  ds->mMethods[NE_DS_METHOD_DTY_P] = ds_dty_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY_P] = ds_output_dty_p;\r\n  ds->mMethods[NE_DS_METHOD_DTY] = ds_dty;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY] = ds_output_dty;\r\n  ds->mMethods[NE_DS_METHOD_MODE] = SIM0_627956e1_1_ds_mode;\r\n  ds->mMakeOutput[NE_DS_METHOD_MODE] = ds_output_mode;\r\n  ds->mMethods[NE_DS_METHOD_ZC] = SIM0_627956e1_1_ds_zc;\r\n  ds->mMakeOutput[NE_DS_METHOD_ZC] = ds_output_zc;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_R] = ds_cache_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_R] = ds_output_cache_r;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_I] = ds_cache_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_I] = ds_output_cache_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_R] = ds_update_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_R] = ds_output_update_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_I] = ds_update_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_I] = ds_output_update_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_R] = ds_update2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_R] = ds_output_update2_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_I] = ds_update2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_I] = ds_output_update2_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_R] = ds_lock_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_R] = ds_output_lock_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_I] = ds_lock_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_I] = ds_output_lock_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_R] = ds_lock2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_R] = ds_output_lock2_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_I] = ds_lock2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_I] = ds_output_lock2_i;\r\n  ds->mMethods[NE_DS_METHOD_SFO] = ds_sfo;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFO] = ds_output_sfo;\r\n  ds->mMethods[NE_DS_METHOD_SFP] = ds_sfp;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFP] = ds_output_sfp;\r\n  ds->mMethods[NE_DS_METHOD_INIT_R] = ds_init_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_R] = ds_output_init_r;\r\n  ds->mMethods[NE_DS_METHOD_INIT_I] = ds_init_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_I] = ds_output_init_i;\r\n  ds->mMethods[NE_DS_METHOD_LOG] = SIM0_627956e1_1_ds_log;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOG] = ds_output_log;\r\n  ds->mMethods[NE_DS_METHOD_ASSERT] = SIM0_627956e1_1_ds_assert;\r\n  ds->mMakeOutput[NE_DS_METHOD_ASSERT] = ds_output_assert;\r\n  ds->mMethods[NE_DS_METHOD_PASSERT] = ds_passert;\r\n  ds->mMakeOutput[NE_DS_METHOD_PASSERT] = ds_output_passert;\r\n  ds->mMethods[NE_DS_METHOD_IASSERT] = ds_iassert;\r\n  ds->mMakeOutput[NE_DS_METHOD_IASSERT] = ds_output_iassert;\r\n  ds->mMethods[NE_DS_METHOD_DEL_T] = ds_del_t;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_T] = ds_output_del_t;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V] = ds_del_v;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V] = ds_output_del_v;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V0] = ds_del_v0;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V0] = ds_output_del_v0;\r\n  ds->mMethods[NE_DS_METHOD_DEL_TMAX] = ds_del_tmax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_TMAX] = ds_output_del_tmax;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT_P] = ds_dxdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT_P] = ds_output_dxdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT] = ds_dxdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT] = ds_output_dxdelt;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT_P] = ds_dudelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT_P] = ds_output_dudelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT] = ds_dudelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT] = ds_output_dudelt;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT_P] = ds_dtdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT_P] = ds_output_dtdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT] = ds_dtdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT] = ds_output_dtdelt;\r\n  ds->mMethods[NE_DS_METHOD_OBS_EXP] = SIM0_627956e1_1_ds_obs_exp;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_EXP] = ds_output_obs_exp;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ACT] = SIM0_627956e1_1_ds_obs_act;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ACT] = ds_output_obs_act;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ALL] = SIM0_627956e1_1_ds_obs_all;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ALL] = ds_output_obs_all;\r\n  ds->mMethods[NE_DS_METHOD_OBS_IL] = SIM0_627956e1_1_ds_obs_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_IL] = ds_output_obs_il;\r\n  ds->mMethods[NE_DS_METHOD_DP_L] = ds_dp_l;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_L] = ds_output_dp_l;\r\n  ds->mMethods[NE_DS_METHOD_DP_I] = ds_dp_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_I] = ds_output_dp_i;\r\n  ds->mMethods[NE_DS_METHOD_DP_J] = ds_dp_j;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_J] = ds_output_dp_j;\r\n  ds->mMethods[NE_DS_METHOD_DP_R] = ds_dp_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_R] = ds_output_dp_r;\r\n  ds->mMethods[NE_DS_METHOD_QX] = ds_qx;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX] = ds_output_qx;\r\n  ds->mMethods[NE_DS_METHOD_QU] = ds_qu;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU] = ds_output_qu;\r\n  ds->mMethods[NE_DS_METHOD_QT] = ds_qt;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT] = ds_output_qt;\r\n  ds->mMethods[NE_DS_METHOD_Q1] = ds_q1;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1] = ds_output_q1;\r\n  ds->mMethods[NE_DS_METHOD_QX_P] = ds_qx_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX_P] = ds_output_qx_p;\r\n  ds->mMethods[NE_DS_METHOD_QU_P] = ds_qu_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU_P] = ds_output_qu_p;\r\n  ds->mMethods[NE_DS_METHOD_QT_P] = ds_qt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT_P] = ds_output_qt_p;\r\n  ds->mMethods[NE_DS_METHOD_Q1_P] = ds_q1_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1_P] = ds_output_q1_p;\r\n  ds->mMethods[NE_DS_METHOD_VAR_TOL] = ds_var_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_VAR_TOL] = ds_output_var_tol;\r\n  ds->mMethods[NE_DS_METHOD_EQ_TOL] = ds_eq_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_EQ_TOL] = ds_output_eq_tol;\r\n  ds->mMethods[NE_DS_METHOD_LV] = ds_lv;\r\n  ds->mMakeOutput[NE_DS_METHOD_LV] = ds_output_lv;\r\n  ds->mMethods[NE_DS_METHOD_SLV] = ds_slv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLV] = ds_output_slv;\r\n  ds->mMethods[NE_DS_METHOD_NLDV] = ds_nldv;\r\n  ds->mMakeOutput[NE_DS_METHOD_NLDV] = ds_output_nldv;\r\n  ds->mMethods[NE_DS_METHOD_SCLV] = ds_sclv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SCLV] = ds_output_sclv;\r\n  ds->mMethods[NE_DS_METHOD_IMIN] = ds_imin;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMIN] = ds_output_imin;\r\n  ds->mMethods[NE_DS_METHOD_IMAX] = ds_imax;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMAX] = ds_output_imax;\r\n  ds->mMethods[NE_DS_METHOD_DIMIN] = ds_dimin;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMIN] = ds_output_dimin;\r\n  ds->mMethods[NE_DS_METHOD_DIMAX] = ds_dimax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMAX] = ds_output_dimax;\r\n\r\n  /* equation data */\r\n  ds->mEquationData = s_equation_data;\r\n\r\n  /* cer data */\r\n  ds->mCERData = s_cer_data;\r\n\r\n  /* icr data */\r\n  ds->mICRData = s_icr_data;\r\n\r\n  /* continuous variable data */\r\n  ds->mVariableData = s_variable_data;\r\n\r\n  /* discrete variable data */\r\n  ds->mDiscreteData = s_discrete_data;\r\n\r\n  /* observable data */\r\n  ds->mObservableData = s_observable_data;\r\n\r\n  /* major mode data */\r\n  ds->mMajorModeData = s_major_mode_data;\r\n\r\n  /* zc data */\r\n  ds->mZCData = s_zc_data;\r\n\r\n  /* ranges */\r\n  ds->mRanges = s_range;\r\n\r\n  /* assert data */\r\n  ds->mAssertData = s_assert_data;\r\n\r\n  /* assert ranges */\r\n  ds->mAssertRanges = s_assert_range;\r\n\r\n  /* param assert data */\r\n  ds->mParamAssertData = s_param_assert_data;\r\n\r\n  /* param assert ranges */\r\n  ds->mParamAssertRanges = s_param_assert_range;\r\n\r\n  /* initial assert data */\r\n  ds->mInitialAssertData = s_initial_assert_data;\r\n\r\n  /* initial assert ranges */\r\n  ds->mInitialAssertRanges = s_initial_assert_range;\r\n\r\n  /* equation ranges */\r\n  ds->mEquationRanges = s_equation_range;\r\n\r\n  /* cer ranges */\r\n  ds->mCERRanges = s_cer_range;\r\n\r\n  /* icr ranges */\r\n  ds->mICRRanges = s_icr_range;\r\n\r\n  /* parameters */\r\n  ds->mLogicalParameters = s_logical_parameter_data;\r\n  ds->mIntegerParameters = s_integer_parameter_data;\r\n  ds->mIndexParameters = s_index_parameter_data;\r\n  ds->mRealParameters = s_real_parameter_data;\r\n\r\n  /* constant tables */\r\n  ds->mNumLargeArray = 0;\r\n  return (NeDynamicSystem *)_ds;\r\n}\r\n\r\nstatic int32_T ds_passert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_iassert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cer (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXCER_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddcer (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddcer_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDCER_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_tmax (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_t (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXDELT_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUDELT_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTDELT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mINIT_R;\r\n  out.mX[0] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  D_idx_0 = t1->mD.mX[0];\r\n  out = t2->mUPDATE_R;\r\n  out.mX[0] = D_idx_0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLOCK_R;\r\n  out.mX[0] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  D_idx_0 = t1->mD.mX[0];\r\n  out = t2->mUPDATE2_R;\r\n  out.mX[0] = D_idx_0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLOCK2_R;\r\n  out.mX[0] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfp (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfo (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUF_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 5;\r\n  out.mJc[3] = 5;\r\n  out.mJc[4] = 8;\r\n  out.mJc[5] = 8;\r\n  out.mJc[6] = 8;\r\n  out.mJc[7] = 8;\r\n  out.mJc[8] = 8;\r\n  out.mIr[0] = 2;\r\n  out.mIr[1] = 4;\r\n  out.mIr[2] = 12;\r\n  out.mIr[3] = 13;\r\n  out.mIr[4] = 14;\r\n  out.mIr[5] = 2;\r\n  out.mIr[6] = 13;\r\n  out.mIr[7] = 14;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_a (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mA;\r\n  out.mX[0] = 1.0E-6;\r\n  out.mX[1] = -0.0;\r\n  out.mX[2] = -1.0;\r\n  out.mX[3] = -1.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_a_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mA_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 3;\r\n  out.mJc[4] = 3;\r\n  out.mJc[5] = 3;\r\n  out.mJc[6] = 3;\r\n  out.mJc[7] = 4;\r\n  out.mJc[8] = 4;\r\n  out.mJc[9] = 4;\r\n  out.mJc[10] = 4;\r\n  out.mJc[11] = 4;\r\n  out.mJc[12] = 4;\r\n  out.mJc[13] = 4;\r\n  out.mJc[14] = 4;\r\n  out.mJc[15] = 4;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  out.mIr[2] = 0;\r\n  out.mIr[3] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mB;\r\n  out.mX[0] = -1.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mB_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 1;\r\n  out.mJc[6] = 1;\r\n  out.mJc[7] = 1;\r\n  out.mJc[8] = 1;\r\n  out.mIr[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mC_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUF_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 6;\r\n  out.mJc[3] = 6;\r\n  out.mJc[4] = 9;\r\n  out.mJc[5] = 10;\r\n  out.mJc[6] = 11;\r\n  out.mJc[7] = 12;\r\n  out.mJc[8] = 13;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 4;\r\n  out.mIr[3] = 12;\r\n  out.mIr[4] = 13;\r\n  out.mIr[5] = 14;\r\n  out.mIr[6] = 2;\r\n  out.mIr[7] = 13;\r\n  out.mIr[8] = 14;\r\n  out.mIr[9] = 13;\r\n  out.mIr[10] = 14;\r\n  out.mIr[11] = 11;\r\n  out.mIr[12] = 12;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDWF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPDXF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 29ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = true;\r\n  out.mX[3] = true;\r\n  out.mX[4] = true;\r\n  out.mX[5] = true;\r\n  out.mX[6] = true;\r\n  out.mX[7] = true;\r\n  out.mX[8] = true;\r\n  out.mX[9] = true;\r\n  out.mX[10] = true;\r\n  out.mX[11] = true;\r\n  out.mX[12] = true;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDNF_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_v_x (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mDNF_V_X;\r\n  out.mX[0] = true;\r\n  out.mX[1] = true;\r\n  out.mX[2] = true;\r\n  out.mX[3] = true;\r\n  out.mX[4] = true;\r\n  out.mX[5] = true;\r\n  out.mX[6] = true;\r\n  out.mX[7] = true;\r\n  out.mX[8] = true;\r\n  out.mX[9] = true;\r\n  out.mX[10] = true;\r\n  out.mX[11] = true;\r\n  out.mX[12] = true;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF0;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vpf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVPF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vsf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVSF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_freqs (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ic (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIC;\r\n  out.mX[0] = 0.0;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = 0.0;\r\n  out.mX[3] = 0.0;\r\n  out.mX[4] = 0.0;\r\n  out.mX[5] = 0.0;\r\n  out.mX[6] = 0.0;\r\n  out.mX[7] = 0.0;\r\n  out.mX[8] = 1.0;\r\n  out.mX[9] = 0.0;\r\n  out.mX[10] = 0.0;\r\n  out.mX[11] = 0.0;\r\n  out.mX[12] = 0.0;\r\n  out.mX[13] = 0.0;\r\n  out.mX[14] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_im (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_id (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_il (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICR_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICR_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUICR_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mICRM_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICRM_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICRM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_imin (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMIN;\r\n  out.mX[0] = -pmf_get_inf();\r\n  out.mX[1] = -pmf_get_inf();\r\n  out.mX[2] = -pmf_get_inf();\r\n  out.mX[3] = -pmf_get_inf();\r\n  out.mX[4] = -pmf_get_inf();\r\n  out.mX[5] = -pmf_get_inf();\r\n  out.mX[6] = -pmf_get_inf();\r\n  out.mX[7] = -pmf_get_inf();\r\n  out.mX[8] = -pmf_get_inf();\r\n  out.mX[9] = -pmf_get_inf();\r\n  out.mX[10] = -pmf_get_inf();\r\n  out.mX[11] = -pmf_get_inf();\r\n  out.mX[12] = -pmf_get_inf();\r\n  out.mX[13] = -pmf_get_inf();\r\n  out.mX[14] = -pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_imax (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMAX;\r\n  out.mX[0] = pmf_get_inf();\r\n  out.mX[1] = pmf_get_inf();\r\n  out.mX[2] = pmf_get_inf();\r\n  out.mX[3] = pmf_get_inf();\r\n  out.mX[4] = pmf_get_inf();\r\n  out.mX[5] = pmf_get_inf();\r\n  out.mX[6] = pmf_get_inf();\r\n  out.mX[7] = pmf_get_inf();\r\n  out.mX[8] = pmf_get_inf();\r\n  out.mX[9] = pmf_get_inf();\r\n  out.mX[10] = pmf_get_inf();\r\n  out.mX[11] = pmf_get_inf();\r\n  out.mX[12] = pmf_get_inf();\r\n  out.mX[13] = pmf_get_inf();\r\n  out.mX[14] = pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimin (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mDIMIN;\r\n  out.mX[0] = -pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimax (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mDIMAX;\r\n  out.mX[0] = pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mM;\r\n  out.mX[0] = -0.05;\r\n  out.mX[1] = -5.0E-12;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mM_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 2;\r\n  out.mJc[5] = 2;\r\n  out.mJc[6] = 2;\r\n  out.mJc[7] = 2;\r\n  out.mJc[8] = 2;\r\n  out.mJc[9] = 2;\r\n  out.mJc[10] = 2;\r\n  out.mJc[11] = 2;\r\n  out.mJc[12] = 2;\r\n  out.mJc[13] = 2;\r\n  out.mJc[14] = 2;\r\n  out.mJc[15] = 2;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXM_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUM_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMM;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_l (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_j (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1 (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQX_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQU_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQ1_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_var_tol (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mVAR_TOL;\r\n  out.mX[0] = 1.0E-9;\r\n  out.mX[1] = 1.0E-9;\r\n  out.mX[2] = 1.0E-9;\r\n  out.mX[3] = 1.0E-9;\r\n  out.mX[4] = 1.0E-9;\r\n  out.mX[5] = 1.0E-9;\r\n  out.mX[6] = 1.0E-9;\r\n  out.mX[7] = 1.0E-9;\r\n  out.mX[8] = 1.0E-9;\r\n  out.mX[9] = 1.0E-9;\r\n  out.mX[10] = 1.0E-9;\r\n  out.mX[11] = 1.0E-9;\r\n  out.mX[12] = 1.0E-9;\r\n  out.mX[13] = 1.0E-9;\r\n  out.mX[14] = 1.0E-9;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_eq_tol (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mEQ_TOL;\r\n  out.mX[0] = 1.0E-9;\r\n  out.mX[1] = 1.0E-9;\r\n  out.mX[2] = 1.0E-9;\r\n  out.mX[3] = 1.0E-9;\r\n  out.mX[4] = 1.0E-9;\r\n  out.mX[5] = 1.0E-9;\r\n  out.mX[6] = 1.0E-9;\r\n  out.mX[7] = 1.0E-9;\r\n  out.mX[8] = 1.0E-9;\r\n  out.mX[9] = 1.0E-9;\r\n  out.mX[10] = 1.0E-9;\r\n  out.mX[11] = 1.0E-9;\r\n  out.mX[12] = 1.0E-9;\r\n  out.mX[13] = 1.0E-9;\r\n  out.mX[14] = 1.0E-9;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lv (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_nldv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mNLDV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sclv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSCLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_y (const NeDynamicSystem *sys, const NeDynamicSystemInput *t3,\r\n                     NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T U_idx_1;\r\n  real_T U_idx_3;\r\n  real_T X_idx_2;\r\n  real_T X_idx_4;\r\n  U_idx_1 = t3->mU.mX[1];\r\n  U_idx_3 = t3->mU.mX[3];\r\n  X_idx_2 = t3->mX.mX[2];\r\n  X_idx_4 = t3->mX.mX[4];\r\n  out = t4->mY;\r\n  out.mX[0] = -X_idx_2 + U_idx_1;\r\n  out.mX[1] = X_idx_4;\r\n  out.mX[2] = (X_idx_2 * -0.43755555938442742 + U_idx_1 * 0.43755555938442742) +\r\n    U_idx_3;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t6, NeDsMethodOutput *t7)\r\n{\r\n  PmRealVector out;\r\n  (void)t6;\r\n  out = t7->mDXY;\r\n  out.mX[0] = -1.0;\r\n  out.mX[1] = -0.43755555938442742;\r\n  out.mX[2] = 1.0;\r\n  (void)sys;\r\n  (void)t7;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXY_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 2;\r\n  out.mJc[5] = 3;\r\n  out.mJc[6] = 3;\r\n  out.mJc[7] = 3;\r\n  out.mJc[8] = 3;\r\n  out.mJc[9] = 3;\r\n  out.mJc[10] = 3;\r\n  out.mJc[11] = 3;\r\n  out.mJc[12] = 3;\r\n  out.mJc[13] = 3;\r\n  out.mJc[14] = 3;\r\n  out.mJc[15] = 3;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t7, NeDsMethodOutput *t8)\r\n{\r\n  PmRealVector out;\r\n  (void)t7;\r\n  out = t8->mDUY;\r\n  out.mX[0] = 1.0;\r\n  out.mX[1] = 0.43755555938442742;\r\n  out.mX[2] = 1.0;\r\n  (void)sys;\r\n  (void)t8;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUY_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 3;\r\n  out.mJc[5] = 3;\r\n  out.mJc[6] = 3;\r\n  out.mJc[7] = 3;\r\n  out.mJc[8] = 3;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDUY_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDXY_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUY_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 3;\r\n  out.mJc[5] = 3;\r\n  out.mJc[6] = 3;\r\n  out.mJc[7] = 3;\r\n  out.mJc[8] = 3;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXY_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 2;\r\n  out.mJc[5] = 3;\r\n  out.mJc[6] = 3;\r\n  out.mJc[7] = 3;\r\n  out.mJc[8] = 3;\r\n  out.mJc[9] = 3;\r\n  out.mJc[10] = 3;\r\n  out.mJc[11] = 3;\r\n  out.mJc[12] = 3;\r\n  out.mJc[13] = 3;\r\n  out.mJc[14] = 3;\r\n  out.mJc[15] = 3;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_H\r\n#define SIM0_627956E1_1_DS_H           1\r\n\r\n  extern NeDynamicSystem *SIM0_627956e1_1_dae_ds(PmAllocator *allocator );\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_assert.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_assert.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_assert(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmIntVector out;\r\n  int32_T M_idx_5;\r\n  int32_T M_idx_6;\r\n  int32_T M_idx_7;\r\n  M_idx_5 = t1->mM.mX[5];\r\n  M_idx_6 = t1->mM.mX[6];\r\n  M_idx_7 = t1->mM.mX[7];\r\n  out = t2->mASSERT;\r\n  out.mX[0] = 1;\r\n  out.mX[1] = 1;\r\n  out.mX[2] = 1;\r\n  out.mX[3] = (int32_T)(M_idx_5 != 0);\r\n  out.mX[4] = (int32_T)(M_idx_6 != 0);\r\n  out.mX[5] = (int32_T)(M_idx_7 != 0);\r\n  out.mX[6] = 1;\r\n  out.mX[7] = 1;\r\n  out.mX[8] = 1;\r\n  out.mX[9] = 1;\r\n  out.mX[10] = 1;\r\n  out.mX[11] = 1;\r\n  out.mX[12] = 1;\r\n  out.mX[13] = 1;\r\n  out.mX[14] = 1;\r\n  out.mX[15] = 1;\r\n  out.mX[16] = 1;\r\n  out.mX[17] = 1;\r\n  out.mX[18] = 1;\r\n  out.mX[19] = 1;\r\n  out.mX[20] = 1;\r\n  out.mX[21] = 1;\r\n  out.mX[22] = 1;\r\n  out.mX[23] = 1;\r\n  out.mX[24] = 1;\r\n  out.mX[25] = 1;\r\n  out.mX[26] = 1;\r\n  out.mX[27] = 1;\r\n  out.mX[28] = 1;\r\n  out.mX[29] = 1;\r\n  out.mX[30] = 1;\r\n  out.mX[31] = 1;\r\n  out.mX[32] = 1;\r\n  out.mX[33] = 1;\r\n  out.mX[34] = 1;\r\n  out.mX[35] = 1;\r\n  out.mX[36] = 1;\r\n  out.mX[37] = 1;\r\n  out.mX[38] = 1;\r\n  out.mX[39] = 1;\r\n  out.mX[40] = 1;\r\n  out.mX[41] = 1;\r\n  out.mX[42] = 1;\r\n  out.mX[43] = 1;\r\n  out.mX[44] = 1;\r\n  out.mX[45] = 1;\r\n  out.mX[46] = 1;\r\n  out.mX[47] = 1;\r\n  out.mX[48] = 1;\r\n  out.mX[49] = 1;\r\n  out.mX[50] = 1;\r\n  out.mX[51] = 1;\r\n  out.mX[52] = 1;\r\n  out.mX[53] = 1;\r\n  out.mX[54] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_assert.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_ASSERT_H\r\n#define SIM0_627956E1_1_DS_ASSERT_H    1\r\n\r\n  int32_T SIM0_627956e1_1_ds_assert(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_duf.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_duf.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_duf(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t17, NeDsMethodOutput *t18)\r\n{\r\n  PmRealVector out;\r\n  real_T t6[8];\r\n  real_T t7[5];\r\n  real_T t0;\r\n  real_T t12;\r\n  real_T t14;\r\n  real_T t3;\r\n  real_T t4;\r\n  real_T t5;\r\n  size_t t9;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_8;\r\n  M_idx_1 = t17->mM.mX[1];\r\n  M_idx_2 = t17->mM.mX[2];\r\n  M_idx_3 = t17->mM.mX[3];\r\n  M_idx_4 = t17->mM.mX[4];\r\n  M_idx_8 = t17->mM.mX[8];\r\n  out = t18->mDUF;\r\n  if (M_idx_1 != 0) {\r\n    t0 = 1.0E+6;\r\n  } else if (M_idx_8 != 0) {\r\n    t0 = 0.01;\r\n  } else {\r\n    t0 = 1.0E+6;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t14 = 0.01;\r\n  } else {\r\n    t14 = 1.0E+8;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t12 = 4.3755555938442746E-5;\r\n  } else {\r\n    t12 = 437555.55938442744;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t3 = -0.44759931494036587;\r\n  } else {\r\n    t3 = -1.0043755599693999E+8;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t4 = 0.0001;\r\n  } else {\r\n    t4 = 1.0E+6;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t5 = -1.0001;\r\n  } else {\r\n    t5 = -1.000001E+6;\r\n  }\r\n\r\n  t7[0ULL] = 0.0043755555938442747;\r\n  t7[1ULL] = t0 / 1.0E+6;\r\n  t7[2ULL] = t14 / 1.0E+8;\r\n  t7[3ULL] = t12 / 1.0E+8;\r\n  t7[4ULL] = t3 / 1.0E+8;\r\n  for (t9 = 0ULL; t9 < 5ULL; t9++) {\r\n    t6[t9] = t7[t9];\r\n  }\r\n\r\n  out.mX[0] = t6[0];\r\n  out.mX[1] = t6[1];\r\n  out.mX[2] = t6[2];\r\n  out.mX[3] = t6[3];\r\n  out.mX[4] = t6[4];\r\n  out.mX[5] = 0.01;\r\n  out.mX[6] = t4 / 1.0E+8;\r\n  out.mX[7] = t5 / 1.0E+8;\r\n  (void)sys;\r\n  (void)t18;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_duf.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_DUF_H\r\n#define SIM0_627956E1_1_DS_DUF_H       1\r\n\r\n  int32_T SIM0_627956e1_1_ds_duf(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_dxf.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_dxf.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_dxf(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t39, NeDsMethodOutput *t40)\r\n{\r\n  PmRealVector out;\r\n  real_T t14[29];\r\n  real_T t16[5];\r\n  real_T t18[4];\r\n  real_T t0;\r\n  real_T t11;\r\n  real_T t12;\r\n  real_T t13;\r\n  real_T t2;\r\n  real_T t29;\r\n  real_T t3;\r\n  real_T t36;\r\n  real_T t37;\r\n  real_T t38;\r\n  real_T t4;\r\n  real_T t7;\r\n  real_T t8;\r\n  real_T t9;\r\n  size_t t24;\r\n  int32_T M_idx_0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_0 = t39->mM.mX[0];\r\n  M_idx_1 = t39->mM.mX[1];\r\n  M_idx_2 = t39->mM.mX[2];\r\n  M_idx_3 = t39->mM.mX[3];\r\n  M_idx_4 = t39->mM.mX[4];\r\n  M_idx_8 = t39->mM.mX[8];\r\n  M_idx_9 = t39->mM.mX[9];\r\n  out = t40->mDXF;\r\n  if (M_idx_0 != 0) {\r\n    t0 = -3.3433333333333333;\r\n  } else {\r\n    t0 = -0.01000001;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t29 = -0.0001;\r\n  } else {\r\n    t29 = -1.0E+6;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t2 = 0.0001;\r\n  } else {\r\n    t2 = 1.0E+6;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t3 = -1.0E+6;\r\n  } else if (M_idx_8 != 0) {\r\n    t3 = -1.0E+6;\r\n  } else {\r\n    t3 = M_idx_9 != 0 ? -0.01 : -1.0E+6;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t4 = -0.01;\r\n  } else {\r\n    t4 = -1.0E+8;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t38 = -4.3755555938442746E-5;\r\n  } else {\r\n    t38 = -437555.55938442744;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t37 = 0.44759931494036587;\r\n  } else {\r\n    t37 = 1.0043755599693999E+8;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t7 = -0.0001;\r\n  } else {\r\n    t7 = -1.0E+6;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t8 = 1.0001;\r\n  } else {\r\n    t8 = 1.000001E+6;\r\n  }\r\n\r\n  if (M_idx_0 != 0) {\r\n    t9 = -1.0000033433333333;\r\n  } else {\r\n    t9 = -1.00000001000001;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t36 = -1.0E-10;\r\n  } else {\r\n    t36 = -1.0;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t11 = 1.0E-10;\r\n  } else {\r\n    t11 = 1.0;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t12 = 1.0001;\r\n  } else {\r\n    t12 = 1.000001E+6;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t13 = -0.0001;\r\n  } else {\r\n    t13 = -1.0E+6;\r\n  }\r\n\r\n  t16[0ULL] = -0.0043755555938442747;\r\n  t16[1ULL] = t3 / 1.0E+6;\r\n  t16[2ULL] = t4 / 1.0E+8;\r\n  t16[3ULL] = t38 / 1.0E+8;\r\n  t16[4ULL] = t37 / 1.0E+8;\r\n  t18[0ULL] = -0.01;\r\n  t18[1ULL] = 1.0E-6;\r\n  t18[2ULL] = t7 / 1.0E+8;\r\n  t18[3ULL] = t8 / 1.0E+8;\r\n  t14[0ULL] = -1.0E-6;\r\n  t14[1ULL] = t0;\r\n  t14[2ULL] = t29 / 1.0E+8;\r\n  t14[3ULL] = t2 / 1.0E+8;\r\n  for (t24 = 0ULL; t24 < 5ULL; t24++) {\r\n    t14[t24 + 4ULL] = t16[t24];\r\n  }\r\n\r\n  t14[9ULL] = -1.0E-6;\r\n  t14[10ULL] = 1.0E-8;\r\n  for (t24 = 0ULL; t24 < 4ULL; t24++) {\r\n    t14[t24 + 11ULL] = t18[t24];\r\n  }\r\n\r\n  out.mX[0] = t14[0];\r\n  out.mX[1] = t14[1];\r\n  out.mX[2] = t14[2];\r\n  out.mX[3] = t14[3];\r\n  out.mX[4] = t14[4];\r\n  out.mX[5] = t14[5];\r\n  out.mX[6] = t14[6];\r\n  out.mX[7] = t14[7];\r\n  out.mX[8] = t14[8];\r\n  out.mX[9] = t14[9];\r\n  out.mX[10] = t14[10];\r\n  out.mX[11] = t14[11];\r\n  out.mX[12] = t14[12];\r\n  out.mX[13] = t14[13];\r\n  out.mX[14] = t14[14];\r\n  out.mX[15] = 1.0E-6;\r\n  out.mX[16] = t9;\r\n  out.mX[17] = t36 / 1.0E+8;\r\n  out.mX[18] = t11 / 1.0E+8;\r\n  out.mX[19] = 0.01;\r\n  out.mX[20] = t12 / 1.0E+8;\r\n  out.mX[21] = t13 / 1.0E+8;\r\n  out.mX[22] = 1.0;\r\n  out.mX[23] = 1.0;\r\n  out.mX[24] = 1.0;\r\n  out.mX[25] = 1.0;\r\n  out.mX[26] = 1.0;\r\n  out.mX[27] = 1.0;\r\n  out.mX[28] = 1.0;\r\n  (void)sys;\r\n  (void)t40;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_dxf.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_DXF_H\r\n#define SIM0_627956E1_1_DS_DXF_H       1\r\n\r\n  int32_T SIM0_627956e1_1_ds_dxf(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_dxf_p.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_dxf_p.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_dxf_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXF_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 4;\r\n  out.mJc[3] = 9;\r\n  out.mJc[4] = 11;\r\n  out.mJc[5] = 15;\r\n  out.mJc[6] = 16;\r\n  out.mJc[7] = 19;\r\n  out.mJc[8] = 22;\r\n  out.mJc[9] = 23;\r\n  out.mJc[10] = 24;\r\n  out.mJc[11] = 25;\r\n  out.mJc[12] = 26;\r\n  out.mJc[13] = 27;\r\n  out.mJc[14] = 28;\r\n  out.mJc[15] = 29;\r\n  out.mIr[0] = 5;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 13;\r\n  out.mIr[3] = 14;\r\n  out.mIr[4] = 2;\r\n  out.mIr[5] = 5;\r\n  out.mIr[6] = 12;\r\n  out.mIr[7] = 13;\r\n  out.mIr[8] = 14;\r\n  out.mIr[9] = 5;\r\n  out.mIr[10] = 12;\r\n  out.mIr[11] = 2;\r\n  out.mIr[12] = 5;\r\n  out.mIr[13] = 13;\r\n  out.mIr[14] = 14;\r\n  out.mIr[15] = 4;\r\n  out.mIr[16] = 2;\r\n  out.mIr[17] = 13;\r\n  out.mIr[18] = 14;\r\n  out.mIr[19] = 2;\r\n  out.mIr[20] = 13;\r\n  out.mIr[21] = 14;\r\n  out.mIr[22] = 11;\r\n  out.mIr[23] = 3;\r\n  out.mIr[24] = 6;\r\n  out.mIr[25] = 7;\r\n  out.mIr[26] = 8;\r\n  out.mIr[27] = 9;\r\n  out.mIr[28] = 10;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_dxf_p.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_DXF_P_H\r\n#define SIM0_627956E1_1_DS_DXF_P_H     1\r\n\r\n  int32_T SIM0_627956e1_1_ds_dxf_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_external_struct.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef struct__ExternalFunctionStructTag\r\n#define struct__ExternalFunctionStructTag\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_externals.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":""},{"name":"SIM0_627956e1_1_ds_f.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_f.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_f(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t14, NeDsMethodOutput *t15)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  real_T SIM_Switch2_i;\r\n  real_T U_idx_1;\r\n  real_T U_idx_3;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t1;\r\n  real_T t3;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  int32_T M_idx_0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_14;\r\n  int32_T M_idx_15;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_0 = t14->mM.mX[0];\r\n  M_idx_1 = t14->mM.mX[1];\r\n  M_idx_2 = t14->mM.mX[2];\r\n  M_idx_3 = t14->mM.mX[3];\r\n  M_idx_4 = t14->mM.mX[4];\r\n  M_idx_8 = t14->mM.mX[8];\r\n  M_idx_9 = t14->mM.mX[9];\r\n  M_idx_14 = t14->mM.mX[14];\r\n  M_idx_15 = t14->mM.mX[15];\r\n  U_idx_1 = t14->mU.mX[1];\r\n  U_idx_3 = t14->mU.mX[3];\r\n  X_idx_0 = t14->mX.mX[0];\r\n  X_idx_1 = t14->mX.mX[1];\r\n  X_idx_2 = t14->mX.mX[2];\r\n  X_idx_3 = t14->mX.mX[3];\r\n  X_idx_4 = t14->mX.mX[4];\r\n  X_idx_5 = t14->mX.mX[5];\r\n  X_idx_6 = t14->mX.mX[6];\r\n  X_idx_7 = t14->mX.mX[7];\r\n  X_idx_8 = t14->mX.mX[8];\r\n  X_idx_9 = t14->mX.mX[9];\r\n  X_idx_10 = t14->mX.mX[10];\r\n  X_idx_11 = t14->mX.mX[11];\r\n  X_idx_12 = t14->mX.mX[12];\r\n  X_idx_13 = t14->mX.mX[13];\r\n  X_idx_14 = t14->mX.mX[14];\r\n  D_idx_0 = t14->mD.mX[0];\r\n  out = t15->mF;\r\n  t5 = -X_idx_2 + U_idx_1;\r\n  t1 = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.00000001) +\r\n          X_idx_2 * -0.0043755555938442747) + X_idx_7 * 0.01) + U_idx_1 *\r\n        0.0043755555938442747) + U_idx_3 * 0.01;\r\n  t3 = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t6 = (((((X_idx_1 * 0.01 + X_idx_4 * 0.01) + X_idx_6 * 1.0E-8) + X_idx_2 *\r\n          0.0043755555938442747) + X_idx_7 * -0.01) + U_idx_1 *\r\n        -0.0043755555938442747) + U_idx_3 * -0.01;\r\n  t4 = (-X_idx_0 + -X_idx_3) + X_idx_4;\r\n  SIM_Switch2_i = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.0E-8) +\r\n                     X_idx_2 * -1.0043755555938443) + X_idx_7 * 0.01) + U_idx_1 *\r\n                   1.0043755555938443) + U_idx_3 * 0.01;\r\n  X_idx_1 = ((X_idx_2 * 0.43755555938442742 + U_idx_1 * -0.43755555938442742) +\r\n             -U_idx_3) + X_idx_4;\r\n  if (M_idx_0 != 0) {\r\n    X_idx_6 = t1 - (t3 - 0.59999999819999994) / 0.3;\r\n  } else {\r\n    X_idx_6 = t1 - t3 * 1.0E-8;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t1 = X_idx_5 - -U_idx_1 / 1.0E-6;\r\n  } else if (M_idx_8 != 0) {\r\n    t1 = X_idx_5 - U_idx_1 * -0.01;\r\n  } else {\r\n    t1 = X_idx_5 - -U_idx_1 / 1.0E-6;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    X_idx_0 = t4 - X_idx_2 / 1.0E-6;\r\n  } else if (M_idx_8 != 0) {\r\n    X_idx_0 = t4 - X_idx_2 / 1.0E-6;\r\n  } else if (M_idx_9 != 0) {\r\n    X_idx_0 = t4 - X_idx_2 * 0.01;\r\n  } else {\r\n    X_idx_0 = t4 - X_idx_2 / 1.0E-6;\r\n  }\r\n\r\n  if (D_idx_0 == 1.0) {\r\n    t3 = X_idx_8 - 1.0;\r\n  } else if (D_idx_0 == 2.0) {\r\n    t3 = X_idx_8 - 2.0;\r\n  } else if (D_idx_0 == 3.0) {\r\n    t3 = X_idx_8 - 3.0;\r\n  } else if (M_idx_14 != 0) {\r\n    t3 = X_idx_8 - 1.0;\r\n  } else if (M_idx_15 != 0) {\r\n    t3 = X_idx_8 - 2.0;\r\n  } else {\r\n    t3 = X_idx_8 - 3.0;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t4 = X_idx_3 - t5 * -0.01;\r\n  } else {\r\n    t4 = X_idx_3 - -t5 / 1.0E-8;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t5 = X_idx_7 - t6 * 0.01;\r\n  } else {\r\n    t5 = X_idx_7 - t6 / 1.0E-8;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t6 = X_idx_1 - SIM_Switch2_i * 0.01;\r\n  } else {\r\n    t6 = X_idx_1 - SIM_Switch2_i / 1.0E-8;\r\n  }\r\n\r\n  out.mX[0] = -0.0;\r\n  out.mX[1] = -0.0;\r\n  out.mX[2] = X_idx_6;\r\n  out.mX[3] = X_idx_9;\r\n  out.mX[4] = t1 / 1.0E+6;\r\n  out.mX[5] = X_idx_0 / 1.0E+6;\r\n  out.mX[6] = X_idx_10;\r\n  out.mX[7] = X_idx_11;\r\n  out.mX[8] = X_idx_12;\r\n  out.mX[9] = X_idx_13;\r\n  out.mX[10] = X_idx_14;\r\n  out.mX[11] = t3;\r\n  out.mX[12] = t4 / 1.0E+8;\r\n  out.mX[13] = t5 / 1.0E+8;\r\n  out.mX[14] = t6 / 1.0E+8;\r\n  (void)sys;\r\n  (void)t15;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_f.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_F_H\r\n#define SIM0_627956E1_1_DS_F_H         1\r\n\r\n  int32_T SIM0_627956e1_1_ds_f(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_log.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_log.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_log(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t17, NeDsMethodOutput *t18)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[109];\r\n  real_T D_idx_0;\r\n  real_T SIM_Capacitor_p_v;\r\n  real_T SIM_Controlled_Current_Source_head_v;\r\n  real_T SIM_Diode_i;\r\n  real_T SIM_Diode_p_v;\r\n  real_T SIM_Diode_v;\r\n  real_T SIM_Resistor_n_v;\r\n  real_T SIM_Switch2_i;\r\n  real_T SIM_Switch2_v;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T U_idx_6;\r\n  real_T U_idx_7;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t13;\r\n  real_T t2;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  int32_T b;\r\n  U_idx_0 = t17->mU.mX[0];\r\n  U_idx_1 = t17->mU.mX[1];\r\n  U_idx_2 = t17->mU.mX[2];\r\n  U_idx_3 = t17->mU.mX[3];\r\n  U_idx_4 = t17->mU.mX[4];\r\n  U_idx_5 = t17->mU.mX[5];\r\n  U_idx_6 = t17->mU.mX[6];\r\n  U_idx_7 = t17->mU.mX[7];\r\n  X_idx_0 = t17->mX.mX[0];\r\n  X_idx_1 = t17->mX.mX[1];\r\n  X_idx_2 = t17->mX.mX[2];\r\n  X_idx_3 = t17->mX.mX[3];\r\n  X_idx_4 = t17->mX.mX[4];\r\n  X_idx_5 = t17->mX.mX[5];\r\n  X_idx_6 = t17->mX.mX[6];\r\n  X_idx_7 = t17->mX.mX[7];\r\n  X_idx_8 = t17->mX.mX[8];\r\n  X_idx_9 = t17->mX.mX[9];\r\n  X_idx_10 = t17->mX.mX[10];\r\n  X_idx_11 = t17->mX.mX[11];\r\n  X_idx_12 = t17->mX.mX[12];\r\n  X_idx_13 = t17->mX.mX[13];\r\n  X_idx_14 = t17->mX.mX[14];\r\n  D_idx_0 = t17->mD.mX[0];\r\n  out = t18->mLOG;\r\n  SIM_Capacitor_p_v = X_idx_0 + X_idx_3;\r\n  SIM_Controlled_Current_Source_head_v = -(X_idx_5 - X_idx_4);\r\n  t2 = U_idx_2 - (-X_idx_3);\r\n  t4 = -X_idx_2 + U_idx_1;\r\n  SIM_Diode_i = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.00000001)\r\n                   + X_idx_2 * -0.0043755555938442747) + X_idx_7 * 0.01) +\r\n                 U_idx_1 * 0.0043755555938442747) + U_idx_3 * 0.01;\r\n  t5 = (((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_2 * -0.43755555938442742) +\r\n        U_idx_1 * 0.43755555938442742) + U_idx_3;\r\n  SIM_Diode_p_v = (X_idx_2 * -0.43755555938442742 + U_idx_1 *\r\n                   0.43755555938442742) + U_idx_3;\r\n  SIM_Diode_v = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t6 = (((((X_idx_1 * 0.01 + X_idx_4 * 0.01) + X_idx_6 * 1.0E-8) + X_idx_2 *\r\n          0.0043755555938442747) + X_idx_7 * -0.01) + U_idx_1 *\r\n        -0.0043755555938442747) + U_idx_3 * -0.01;\r\n  SIM_Resistor_n_v = ((((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_2 *\r\n                        -0.43755555938442742) + U_idx_1 * 0.43755555938442742) +\r\n                      U_idx_3) + X_idx_7;\r\n  t13 = (-X_idx_0 + -X_idx_3) + X_idx_4;\r\n  SIM_Switch2_i = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.0E-8) +\r\n                     X_idx_2 * -1.0043755555938443) + X_idx_7 * 0.01) + U_idx_1 *\r\n                   1.0043755555938443) + U_idx_3 * 0.01;\r\n  SIM_Switch2_v = ((X_idx_2 * 0.43755555938442742 + U_idx_1 *\r\n                    -0.43755555938442742) + -U_idx_3) + X_idx_4;\r\n  t0[0ULL] = U_idx_0 + X_idx_2;\r\n  t0[1ULL] = X_idx_3;\r\n  t0[2ULL] = SIM_Capacitor_p_v;\r\n  t0[3ULL] = X_idx_0;\r\n  t0[4ULL] = X_idx_0;\r\n  t0[5ULL] = X_idx_0 * X_idx_0 * 1.0E-9;\r\n  t0[6ULL] = SIM_Controlled_Current_Source_head_v;\r\n  t0[7ULL] = U_idx_1;\r\n  t0[8ULL] = U_idx_1;\r\n  t0[9ULL] = t2;\r\n  t0[10ULL] = t2 - SIM_Controlled_Current_Source_head_v;\r\n  t0[11ULL] = SIM_Capacitor_p_v;\r\n  t0[12ULL] = U_idx_0;\r\n  t0[13ULL] = U_idx_0;\r\n  t0[14ULL] = X_idx_3;\r\n  t0[15ULL] = X_idx_3 - SIM_Capacitor_p_v;\r\n  t0[16ULL] = t4;\r\n  t0[17ULL] = U_idx_3;\r\n  t0[18ULL] = U_idx_3;\r\n  t0[19ULL] = U_idx_3;\r\n  t0[20ULL] = -U_idx_1;\r\n  t0[21ULL] = X_idx_3;\r\n  t0[22ULL] = t2;\r\n  t0[23ULL] = U_idx_2;\r\n  t0[24ULL] = U_idx_2;\r\n  t0[25ULL] = t4;\r\n  t0[26ULL] = t4;\r\n  t0[27ULL] = t4;\r\n  t0[28ULL] = X_idx_6;\r\n  t0[29ULL] = t5;\r\n  t0[30ULL] = SIM_Diode_p_v;\r\n  t0[31ULL] = SIM_Diode_v;\r\n  t0[32ULL] = X_idx_1;\r\n  t0[33ULL] = SIM_Diode_i;\r\n  t0[34ULL] = X_idx_6;\r\n  t0[35ULL] = SIM_Diode_i;\r\n  t0[36ULL] = SIM_Diode_i + X_idx_6;\r\n  t0[37ULL] = SIM_Diode_v;\r\n  t0[38ULL] = t5;\r\n  t0[39ULL] = t5;\r\n  t0[40ULL] = SIM_Diode_p_v;\r\n  t0[41ULL] = SIM_Diode_i * SIM_Diode_v * 0.001 * 1000.0;\r\n  t0[42ULL] = SIM_Diode_v;\r\n  t0[43ULL] = SIM_Diode_v;\r\n  t0[44ULL] = t6;\r\n  t0[45ULL] = SIM_Resistor_n_v;\r\n  t0[46ULL] = X_idx_4;\r\n  t0[47ULL] = t6 * 100.0;\r\n  t0[48ULL] = t6 * t6 * 100.0;\r\n  t0[49ULL] = t4;\r\n  t0[50ULL] = U_idx_3;\r\n  t0[51ULL] = SIM_Diode_p_v;\r\n  t0[52ULL] = t4 * 0.43755555938442742;\r\n  t0[53ULL] = t4 * t4 * 0.43755555938442742;\r\n  t0[54ULL] = X_idx_8;\r\n  t0[55ULL] = -U_idx_1;\r\n  t0[56ULL] = X_idx_2;\r\n  t0[57ULL] = -U_idx_1 + X_idx_2;\r\n  t0[58ULL] = -(X_idx_9 - X_idx_4);\r\n  t0[59ULL] = SIM_Controlled_Current_Source_head_v;\r\n  t0[60ULL] = SIM_Capacitor_p_v;\r\n  t0[61ULL] = -(X_idx_10 - X_idx_4);\r\n  t0[62ULL] = -(X_idx_11 - X_idx_4);\r\n  t0[63ULL] = -(X_idx_12 - X_idx_4);\r\n  t0[64ULL] = -(X_idx_13 - X_idx_4);\r\n  t0[65ULL] = -(X_idx_14 - X_idx_4);\r\n  t0[66ULL] = X_idx_4;\r\n  t0[67ULL] = (-(U_idx_1 * X_idx_5) + X_idx_2 * t13) * 0.001 * 1000.0;\r\n  t0[68ULL] = D_idx_0;\r\n  t0[69ULL] = X_idx_9;\r\n  t0[70ULL] = X_idx_5;\r\n  t0[71ULL] = t13;\r\n  t0[72ULL] = X_idx_10;\r\n  t0[73ULL] = X_idx_11;\r\n  t0[74ULL] = X_idx_12;\r\n  t0[75ULL] = X_idx_13;\r\n  t0[76ULL] = X_idx_14;\r\n  t0[77ULL] = U_idx_6;\r\n  t0[78ULL] = U_idx_2;\r\n  t0[79ULL] = U_idx_4;\r\n  t0[80ULL] = U_idx_5;\r\n  t0[81ULL] = U_idx_6;\r\n  t0[82ULL] = U_idx_7;\r\n  t0[83ULL] = U_idx_1;\r\n  t0[84ULL] = U_idx_0;\r\n  t0[85ULL] = U_idx_3;\r\n  t0[86ULL] = -t4;\r\n  t0[87ULL] = X_idx_3;\r\n  t0[88ULL] = X_idx_3;\r\n  t0[89ULL] = -(t4 * X_idx_3);\r\n  t0[90ULL] = U_idx_7;\r\n  t0[91ULL] = t6;\r\n  t0[92ULL] = t5;\r\n  t0[93ULL] = SIM_Resistor_n_v;\r\n  t0[94ULL] = X_idx_7;\r\n  t0[95ULL] = t6 * X_idx_7;\r\n  t0[96ULL] = U_idx_4;\r\n  t0[97ULL] = SIM_Switch2_i;\r\n  t0[98ULL] = SIM_Diode_p_v;\r\n  t0[99ULL] = X_idx_4;\r\n  t0[100ULL] = SIM_Switch2_v;\r\n  t0[101ULL] = SIM_Switch2_i * SIM_Switch2_v;\r\n  t0[102ULL] = U_idx_5;\r\n  t0[103ULL] = SIM_Diode_p_v;\r\n  t0[104ULL] = SIM_Diode_p_v;\r\n  t0[105ULL] = X_idx_4;\r\n  t0[106ULL] = X_idx_4;\r\n  t0[107ULL] = X_idx_4;\r\n  t0[108ULL] = SIM_Diode_p_v;\r\n  for (b = 0; b < 109; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t18;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_log.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_LOG_H\r\n#define SIM0_627956E1_1_DS_LOG_H       1\r\n\r\n  int32_T SIM0_627956e1_1_ds_log(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_mode.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_mode.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_mode(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmIntVector out;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T U_idx_6;\r\n  real_T U_idx_7;\r\n  real_T X_idx_1;\r\n  real_T X_idx_6;\r\n  real_T X_idx_8;\r\n  U_idx_4 = t1->mU.mX[4];\r\n  U_idx_5 = t1->mU.mX[5];\r\n  U_idx_6 = t1->mU.mX[6];\r\n  U_idx_7 = t1->mU.mX[7];\r\n  X_idx_1 = t1->mX.mX[1];\r\n  X_idx_6 = t1->mX.mX[6];\r\n  X_idx_8 = t1->mX.mX[8];\r\n  out = t2->mMODE;\r\n  out.mX[0] = (int32_T)(X_idx_6 * 1.0E-6 + X_idx_1 > 0.6);\r\n  out.mX[1] = (int32_T)(X_idx_8 == 1.0);\r\n  out.mX[2] = (int32_T)(U_idx_7 > 0.5);\r\n  out.mX[3] = (int32_T)(U_idx_4 > 0.5);\r\n  out.mX[4] = (int32_T)(U_idx_5 > 0.5);\r\n  out.mX[5] = 1;\r\n  out.mX[6] = 1;\r\n  out.mX[7] = 1;\r\n  out.mX[8] = (int32_T)(X_idx_8 == 2.0);\r\n  out.mX[9] = (int32_T)(X_idx_8 == 3.0);\r\n  out.mX[10] = (int32_T)(X_idx_8 == 4.0);\r\n  out.mX[11] = (int32_T)(X_idx_8 == 5.0);\r\n  out.mX[12] = (int32_T)(X_idx_8 == 6.0);\r\n  out.mX[13] = (int32_T)(X_idx_8 == 7.0);\r\n  out.mX[14] = (int32_T)(U_idx_6 < 1.5);\r\n  out.mX[15] = (int32_T)(U_idx_6 < 2.5);\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_mode.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_MODE_H\r\n#define SIM0_627956E1_1_DS_MODE_H      1\r\n\r\n  int32_T SIM0_627956e1_1_ds_mode(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_obs_act.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_act.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t17, NeDsMethodOutput *t18)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[118];\r\n  real_T D_idx_0;\r\n  real_T SIM_Capacitor_p_v;\r\n  real_T SIM_Controlled_Current_Source_head_v;\r\n  real_T SIM_Diode_i;\r\n  real_T SIM_Diode_p_v;\r\n  real_T SIM_Diode_v;\r\n  real_T SIM_Resistor_n_v;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T U_idx_6;\r\n  real_T U_idx_7;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t13;\r\n  real_T t2;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  int32_T b;\r\n  U_idx_0 = t17->mU.mX[0];\r\n  U_idx_1 = t17->mU.mX[1];\r\n  U_idx_2 = t17->mU.mX[2];\r\n  U_idx_3 = t17->mU.mX[3];\r\n  U_idx_4 = t17->mU.mX[4];\r\n  U_idx_5 = t17->mU.mX[5];\r\n  U_idx_6 = t17->mU.mX[6];\r\n  U_idx_7 = t17->mU.mX[7];\r\n  X_idx_0 = t17->mX.mX[0];\r\n  X_idx_1 = t17->mX.mX[1];\r\n  X_idx_2 = t17->mX.mX[2];\r\n  X_idx_3 = t17->mX.mX[3];\r\n  X_idx_4 = t17->mX.mX[4];\r\n  X_idx_5 = t17->mX.mX[5];\r\n  X_idx_6 = t17->mX.mX[6];\r\n  X_idx_7 = t17->mX.mX[7];\r\n  X_idx_8 = t17->mX.mX[8];\r\n  X_idx_9 = t17->mX.mX[9];\r\n  X_idx_10 = t17->mX.mX[10];\r\n  X_idx_11 = t17->mX.mX[11];\r\n  X_idx_12 = t17->mX.mX[12];\r\n  X_idx_13 = t17->mX.mX[13];\r\n  X_idx_14 = t17->mX.mX[14];\r\n  D_idx_0 = t17->mD.mX[0];\r\n  out = t18->mOBS_ACT;\r\n  SIM_Capacitor_p_v = X_idx_0 + X_idx_3;\r\n  SIM_Controlled_Current_Source_head_v = -(X_idx_5 - X_idx_4);\r\n  t2 = U_idx_2 - (-X_idx_3);\r\n  t4 = -X_idx_2 + U_idx_1;\r\n  SIM_Diode_i = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.00000001)\r\n                   + X_idx_2 * -0.0043755555938442747) + X_idx_7 * 0.01) +\r\n                 U_idx_1 * 0.0043755555938442747) + U_idx_3 * 0.01;\r\n  t5 = (((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_2 * -0.43755555938442742) +\r\n        U_idx_1 * 0.43755555938442742) + U_idx_3;\r\n  SIM_Diode_p_v = (X_idx_2 * -0.43755555938442742 + U_idx_1 *\r\n                   0.43755555938442742) + U_idx_3;\r\n  SIM_Diode_v = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t6 = (((((X_idx_1 * 0.01 + X_idx_4 * 0.01) + X_idx_6 * 1.0E-8) + X_idx_2 *\r\n          0.0043755555938442747) + X_idx_7 * -0.01) + U_idx_1 *\r\n        -0.0043755555938442747) + U_idx_3 * -0.01;\r\n  SIM_Resistor_n_v = ((((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_2 *\r\n                        -0.43755555938442742) + U_idx_1 * 0.43755555938442742) +\r\n                      U_idx_3) + X_idx_7;\r\n  t13 = (-X_idx_0 + -X_idx_3) + X_idx_4;\r\n  t0[0ULL] = U_idx_0 + X_idx_2;\r\n  t0[1ULL] = X_idx_3;\r\n  t0[2ULL] = SIM_Capacitor_p_v;\r\n  t0[3ULL] = X_idx_0;\r\n  t0[4ULL] = X_idx_0;\r\n  t0[5ULL] = SIM_Controlled_Current_Source_head_v;\r\n  t0[6ULL] = U_idx_1;\r\n  t0[7ULL] = U_idx_1;\r\n  t0[8ULL] = t2;\r\n  t0[9ULL] = t2 - SIM_Controlled_Current_Source_head_v;\r\n  t0[10ULL] = SIM_Capacitor_p_v;\r\n  t0[11ULL] = U_idx_0;\r\n  t0[12ULL] = U_idx_0;\r\n  t0[13ULL] = X_idx_3;\r\n  t0[14ULL] = X_idx_3 - SIM_Capacitor_p_v;\r\n  t0[15ULL] = t4;\r\n  t0[16ULL] = 0.0;\r\n  t0[17ULL] = U_idx_3;\r\n  t0[18ULL] = U_idx_3;\r\n  t0[19ULL] = U_idx_3;\r\n  t0[20ULL] = -U_idx_1;\r\n  t0[21ULL] = X_idx_3;\r\n  t0[22ULL] = t2;\r\n  t0[23ULL] = U_idx_2;\r\n  t0[24ULL] = U_idx_2;\r\n  t0[25ULL] = t4;\r\n  t0[26ULL] = t4;\r\n  t0[27ULL] = 0.0;\r\n  t0[28ULL] = 0.0;\r\n  t0[29ULL] = t4;\r\n  t0[30ULL] = X_idx_6;\r\n  t0[31ULL] = t5;\r\n  t0[32ULL] = SIM_Diode_p_v;\r\n  t0[33ULL] = SIM_Diode_v;\r\n  t0[34ULL] = X_idx_1;\r\n  t0[35ULL] = 298.15;\r\n  t0[36ULL] = 0.0;\r\n  t0[37ULL] = SIM_Diode_i;\r\n  t0[38ULL] = X_idx_6;\r\n  t0[39ULL] = SIM_Diode_i;\r\n  t0[40ULL] = SIM_Diode_i + X_idx_6;\r\n  t0[41ULL] = SIM_Diode_v;\r\n  t0[42ULL] = t5;\r\n  t0[43ULL] = t5;\r\n  t0[44ULL] = SIM_Diode_p_v;\r\n  t0[45ULL] = SIM_Diode_i * SIM_Diode_v * 0.001 * 1000.0;\r\n  t0[46ULL] = SIM_Diode_v;\r\n  t0[47ULL] = SIM_Diode_v;\r\n  t0[48ULL] = 0.0;\r\n  t0[49ULL] = t6;\r\n  t0[50ULL] = SIM_Resistor_n_v;\r\n  t0[51ULL] = X_idx_4;\r\n  t0[52ULL] = t6 * 100.0;\r\n  t0[53ULL] = t4;\r\n  t0[54ULL] = U_idx_3;\r\n  t0[55ULL] = SIM_Diode_p_v;\r\n  t0[56ULL] = t4 * 0.43755555938442742;\r\n  t0[57ULL] = X_idx_8;\r\n  t0[58ULL] = 0.0;\r\n  t0[59ULL] = -U_idx_1;\r\n  t0[60ULL] = X_idx_2;\r\n  t0[61ULL] = 0.0;\r\n  t0[62ULL] = 0.0;\r\n  t0[63ULL] = 0.0;\r\n  t0[64ULL] = 0.0;\r\n  t0[65ULL] = 0.0;\r\n  t0[66ULL] = -U_idx_1 + X_idx_2;\r\n  t0[67ULL] = -(X_idx_9 - X_idx_4);\r\n  t0[68ULL] = SIM_Controlled_Current_Source_head_v;\r\n  t0[69ULL] = SIM_Capacitor_p_v;\r\n  t0[70ULL] = -(X_idx_10 - X_idx_4);\r\n  t0[71ULL] = -(X_idx_11 - X_idx_4);\r\n  t0[72ULL] = -(X_idx_12 - X_idx_4);\r\n  t0[73ULL] = -(X_idx_13 - X_idx_4);\r\n  t0[74ULL] = -(X_idx_14 - X_idx_4);\r\n  t0[75ULL] = X_idx_4;\r\n  t0[76ULL] = (-(U_idx_1 * X_idx_5) + X_idx_2 * t13) * 0.001 * 1000.0;\r\n  t0[77ULL] = D_idx_0;\r\n  t0[78ULL] = X_idx_9;\r\n  t0[79ULL] = X_idx_5;\r\n  t0[80ULL] = t13;\r\n  t0[81ULL] = X_idx_10;\r\n  t0[82ULL] = X_idx_11;\r\n  t0[83ULL] = X_idx_12;\r\n  t0[84ULL] = X_idx_13;\r\n  t0[85ULL] = X_idx_14;\r\n  t0[86ULL] = U_idx_6;\r\n  t0[87ULL] = U_idx_2;\r\n  t0[88ULL] = U_idx_4;\r\n  t0[89ULL] = U_idx_5;\r\n  t0[90ULL] = U_idx_6;\r\n  t0[91ULL] = U_idx_7;\r\n  t0[92ULL] = U_idx_1;\r\n  t0[93ULL] = U_idx_0;\r\n  t0[94ULL] = U_idx_3;\r\n  t0[95ULL] = -t4;\r\n  t0[96ULL] = 0.0;\r\n  t0[97ULL] = X_idx_3;\r\n  t0[98ULL] = X_idx_3;\r\n  t0[99ULL] = U_idx_7;\r\n  t0[100ULL] = t6;\r\n  t0[101ULL] = t5;\r\n  t0[102ULL] = SIM_Resistor_n_v;\r\n  t0[103ULL] = X_idx_7;\r\n  t0[104ULL] = U_idx_4;\r\n  t0[105ULL] = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.0E-8) +\r\n                  X_idx_2 * -1.0043755555938443) + X_idx_7 * 0.01) + U_idx_1 *\r\n                1.0043755555938443) + U_idx_3 * 0.01;\r\n  t0[106ULL] = SIM_Diode_p_v;\r\n  t0[107ULL] = X_idx_4;\r\n  t0[108ULL] = ((X_idx_2 * 0.43755555938442742 + U_idx_1 * -0.43755555938442742)\r\n                + -U_idx_3) + X_idx_4;\r\n  t0[109ULL] = U_idx_5;\r\n  t0[110ULL] = SIM_Diode_p_v;\r\n  t0[111ULL] = 0.0;\r\n  t0[112ULL] = SIM_Diode_p_v;\r\n  t0[113ULL] = X_idx_4;\r\n  t0[114ULL] = 0.0;\r\n  t0[115ULL] = X_idx_4;\r\n  t0[116ULL] = X_idx_4;\r\n  t0[117ULL] = SIM_Diode_p_v;\r\n  for (b = 0; b < 118; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t18;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_obs_act.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_OBS_ACT_H\r\n#define SIM0_627956E1_1_DS_OBS_ACT_H   1\r\n\r\n  int32_T SIM0_627956e1_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_obs_all.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_all.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t17, NeDsMethodOutput *t18)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[118];\r\n  real_T D_idx_0;\r\n  real_T SIM_Capacitor_p_v;\r\n  real_T SIM_Controlled_Current_Source_head_v;\r\n  real_T SIM_Diode_i;\r\n  real_T SIM_Diode_p_v;\r\n  real_T SIM_Diode_v;\r\n  real_T SIM_Resistor_n_v;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T U_idx_6;\r\n  real_T U_idx_7;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t13;\r\n  real_T t2;\r\n  real_T t4;\r\n  real_T t5;\r\n  real_T t6;\r\n  int32_T b;\r\n  U_idx_0 = t17->mU.mX[0];\r\n  U_idx_1 = t17->mU.mX[1];\r\n  U_idx_2 = t17->mU.mX[2];\r\n  U_idx_3 = t17->mU.mX[3];\r\n  U_idx_4 = t17->mU.mX[4];\r\n  U_idx_5 = t17->mU.mX[5];\r\n  U_idx_6 = t17->mU.mX[6];\r\n  U_idx_7 = t17->mU.mX[7];\r\n  X_idx_0 = t17->mX.mX[0];\r\n  X_idx_1 = t17->mX.mX[1];\r\n  X_idx_2 = t17->mX.mX[2];\r\n  X_idx_3 = t17->mX.mX[3];\r\n  X_idx_4 = t17->mX.mX[4];\r\n  X_idx_5 = t17->mX.mX[5];\r\n  X_idx_6 = t17->mX.mX[6];\r\n  X_idx_7 = t17->mX.mX[7];\r\n  X_idx_8 = t17->mX.mX[8];\r\n  X_idx_9 = t17->mX.mX[9];\r\n  X_idx_10 = t17->mX.mX[10];\r\n  X_idx_11 = t17->mX.mX[11];\r\n  X_idx_12 = t17->mX.mX[12];\r\n  X_idx_13 = t17->mX.mX[13];\r\n  X_idx_14 = t17->mX.mX[14];\r\n  D_idx_0 = t17->mD.mX[0];\r\n  out = t18->mOBS_ALL;\r\n  SIM_Capacitor_p_v = X_idx_0 + X_idx_3;\r\n  SIM_Controlled_Current_Source_head_v = -(X_idx_5 - X_idx_4);\r\n  t2 = U_idx_2 - (-X_idx_3);\r\n  t4 = -X_idx_2 + U_idx_1;\r\n  SIM_Diode_i = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.00000001)\r\n                   + X_idx_2 * -0.0043755555938442747) + X_idx_7 * 0.01) +\r\n                 U_idx_1 * 0.0043755555938442747) + U_idx_3 * 0.01;\r\n  t5 = (((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_2 * -0.43755555938442742) +\r\n        U_idx_1 * 0.43755555938442742) + U_idx_3;\r\n  SIM_Diode_p_v = (X_idx_2 * -0.43755555938442742 + U_idx_1 *\r\n                   0.43755555938442742) + U_idx_3;\r\n  SIM_Diode_v = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t6 = (((((X_idx_1 * 0.01 + X_idx_4 * 0.01) + X_idx_6 * 1.0E-8) + X_idx_2 *\r\n          0.0043755555938442747) + X_idx_7 * -0.01) + U_idx_1 *\r\n        -0.0043755555938442747) + U_idx_3 * -0.01;\r\n  SIM_Resistor_n_v = ((((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_2 *\r\n                        -0.43755555938442742) + U_idx_1 * 0.43755555938442742) +\r\n                      U_idx_3) + X_idx_7;\r\n  t13 = (-X_idx_0 + -X_idx_3) + X_idx_4;\r\n  t0[0ULL] = U_idx_0 + X_idx_2;\r\n  t0[1ULL] = X_idx_3;\r\n  t0[2ULL] = SIM_Capacitor_p_v;\r\n  t0[3ULL] = X_idx_0;\r\n  t0[4ULL] = X_idx_0;\r\n  t0[5ULL] = SIM_Controlled_Current_Source_head_v;\r\n  t0[6ULL] = U_idx_1;\r\n  t0[7ULL] = U_idx_1;\r\n  t0[8ULL] = t2;\r\n  t0[9ULL] = t2 - SIM_Controlled_Current_Source_head_v;\r\n  t0[10ULL] = SIM_Capacitor_p_v;\r\n  t0[11ULL] = U_idx_0;\r\n  t0[12ULL] = U_idx_0;\r\n  t0[13ULL] = X_idx_3;\r\n  t0[14ULL] = X_idx_3 - SIM_Capacitor_p_v;\r\n  t0[15ULL] = t4;\r\n  t0[16ULL] = 0.0;\r\n  t0[17ULL] = U_idx_3;\r\n  t0[18ULL] = U_idx_3;\r\n  t0[19ULL] = U_idx_3;\r\n  t0[20ULL] = -U_idx_1;\r\n  t0[21ULL] = X_idx_3;\r\n  t0[22ULL] = t2;\r\n  t0[23ULL] = U_idx_2;\r\n  t0[24ULL] = U_idx_2;\r\n  t0[25ULL] = t4;\r\n  t0[26ULL] = t4;\r\n  t0[27ULL] = 0.0;\r\n  t0[28ULL] = 0.0;\r\n  t0[29ULL] = t4;\r\n  t0[30ULL] = X_idx_6;\r\n  t0[31ULL] = t5;\r\n  t0[32ULL] = SIM_Diode_p_v;\r\n  t0[33ULL] = SIM_Diode_v;\r\n  t0[34ULL] = X_idx_1;\r\n  t0[35ULL] = 298.15;\r\n  t0[36ULL] = 0.0;\r\n  t0[37ULL] = SIM_Diode_i;\r\n  t0[38ULL] = X_idx_6;\r\n  t0[39ULL] = SIM_Diode_i;\r\n  t0[40ULL] = SIM_Diode_i + X_idx_6;\r\n  t0[41ULL] = SIM_Diode_v;\r\n  t0[42ULL] = t5;\r\n  t0[43ULL] = t5;\r\n  t0[44ULL] = SIM_Diode_p_v;\r\n  t0[45ULL] = SIM_Diode_i * SIM_Diode_v * 0.001 * 1000.0;\r\n  t0[46ULL] = SIM_Diode_v;\r\n  t0[47ULL] = SIM_Diode_v;\r\n  t0[48ULL] = 0.0;\r\n  t0[49ULL] = t6;\r\n  t0[50ULL] = SIM_Resistor_n_v;\r\n  t0[51ULL] = X_idx_4;\r\n  t0[52ULL] = t6 * 100.0;\r\n  t0[53ULL] = t4;\r\n  t0[54ULL] = U_idx_3;\r\n  t0[55ULL] = SIM_Diode_p_v;\r\n  t0[56ULL] = t4 * 0.43755555938442742;\r\n  t0[57ULL] = X_idx_8;\r\n  t0[58ULL] = 0.0;\r\n  t0[59ULL] = -U_idx_1;\r\n  t0[60ULL] = X_idx_2;\r\n  t0[61ULL] = 0.0;\r\n  t0[62ULL] = 0.0;\r\n  t0[63ULL] = 0.0;\r\n  t0[64ULL] = 0.0;\r\n  t0[65ULL] = 0.0;\r\n  t0[66ULL] = -U_idx_1 + X_idx_2;\r\n  t0[67ULL] = -(X_idx_9 - X_idx_4);\r\n  t0[68ULL] = SIM_Controlled_Current_Source_head_v;\r\n  t0[69ULL] = SIM_Capacitor_p_v;\r\n  t0[70ULL] = -(X_idx_10 - X_idx_4);\r\n  t0[71ULL] = -(X_idx_11 - X_idx_4);\r\n  t0[72ULL] = -(X_idx_12 - X_idx_4);\r\n  t0[73ULL] = -(X_idx_13 - X_idx_4);\r\n  t0[74ULL] = -(X_idx_14 - X_idx_4);\r\n  t0[75ULL] = X_idx_4;\r\n  t0[76ULL] = (-(U_idx_1 * X_idx_5) + X_idx_2 * t13) * 0.001 * 1000.0;\r\n  t0[77ULL] = D_idx_0;\r\n  t0[78ULL] = X_idx_9;\r\n  t0[79ULL] = X_idx_5;\r\n  t0[80ULL] = t13;\r\n  t0[81ULL] = X_idx_10;\r\n  t0[82ULL] = X_idx_11;\r\n  t0[83ULL] = X_idx_12;\r\n  t0[84ULL] = X_idx_13;\r\n  t0[85ULL] = X_idx_14;\r\n  t0[86ULL] = U_idx_6;\r\n  t0[87ULL] = U_idx_2;\r\n  t0[88ULL] = U_idx_4;\r\n  t0[89ULL] = U_idx_5;\r\n  t0[90ULL] = U_idx_6;\r\n  t0[91ULL] = U_idx_7;\r\n  t0[92ULL] = U_idx_1;\r\n  t0[93ULL] = U_idx_0;\r\n  t0[94ULL] = U_idx_3;\r\n  t0[95ULL] = -t4;\r\n  t0[96ULL] = 0.0;\r\n  t0[97ULL] = X_idx_3;\r\n  t0[98ULL] = X_idx_3;\r\n  t0[99ULL] = U_idx_7;\r\n  t0[100ULL] = t6;\r\n  t0[101ULL] = t5;\r\n  t0[102ULL] = SIM_Resistor_n_v;\r\n  t0[103ULL] = X_idx_7;\r\n  t0[104ULL] = U_idx_4;\r\n  t0[105ULL] = (((((X_idx_1 * -0.01 + X_idx_4 * -0.01) + X_idx_6 * -1.0E-8) +\r\n                  X_idx_2 * -1.0043755555938443) + X_idx_7 * 0.01) + U_idx_1 *\r\n                1.0043755555938443) + U_idx_3 * 0.01;\r\n  t0[106ULL] = SIM_Diode_p_v;\r\n  t0[107ULL] = X_idx_4;\r\n  t0[108ULL] = ((X_idx_2 * 0.43755555938442742 + U_idx_1 * -0.43755555938442742)\r\n                + -U_idx_3) + X_idx_4;\r\n  t0[109ULL] = U_idx_5;\r\n  t0[110ULL] = SIM_Diode_p_v;\r\n  t0[111ULL] = 0.0;\r\n  t0[112ULL] = SIM_Diode_p_v;\r\n  t0[113ULL] = X_idx_4;\r\n  t0[114ULL] = 0.0;\r\n  t0[115ULL] = X_idx_4;\r\n  t0[116ULL] = X_idx_4;\r\n  t0[117ULL] = SIM_Diode_p_v;\r\n  for (b = 0; b < 118; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t18;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_obs_all.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_OBS_ALL_H\r\n#define SIM0_627956E1_1_DS_OBS_ALL_H   1\r\n\r\n  int32_T SIM0_627956e1_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_obs_exp.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_exp.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_obs_exp(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static real_T _cg_const_1[118] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 298.15, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0 };\r\n\r\n  PmRealVector out;\r\n  real_T t0[118];\r\n  int32_T b;\r\n  (void)t1;\r\n  out = t2->mOBS_EXP;\r\n  for (b = 0; b < 118; b++) {\r\n    t0[b] = _cg_const_1[b];\r\n  }\r\n\r\n  for (b = 0; b < 118; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_obs_exp.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_OBS_EXP_H\r\n#define SIM0_627956E1_1_DS_OBS_EXP_H   1\r\n\r\n  int32_T SIM0_627956e1_1_ds_obs_exp(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_obs_il.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_obs_il.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static boolean_T _cg_const_1[118] = { false, true, true, true, true, true,\r\n    false, false, false, false, true, false, false, true, true, false, true,\r\n    false, false, false, false, true, false, false, false, false, false, true,\r\n    true, false, true, false, false, true, true, true, true, false, true, false,\r\n    false, true, false, false, false, false, true, true, true, false, false,\r\n    true, false, false, false, false, false, true, true, false, true, true, true,\r\n    true, true, true, false, true, true, true, true, true, true, true, true,\r\n    true, false, false, true, true, true, true, true, true, true, true, false,\r\n    false, false, false, false, false, false, false, false, false, true, true,\r\n    true, false, false, false, false, true, false, false, false, true, false,\r\n    false, false, true, false, true, true, true, true, false };\r\n\r\n  PmBoolVector out;\r\n  int32_T b;\r\n  boolean_T t0[118];\r\n  (void)t1;\r\n  out = t2->mOBS_IL;\r\n  for (b = 0; b < 118; b++) {\r\n    t0[b] = _cg_const_1[b];\r\n  }\r\n\r\n  for (b = 0; b < 118; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_obs_il.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_OBS_IL_H\r\n#define SIM0_627956E1_1_DS_OBS_IL_H    1\r\n\r\n  int32_T SIM0_627956e1_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_sys_struct.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef struct__NeDynamicSystemTag\r\n#define struct__NeDynamicSystemTag\r\n\r\ntypedef struct _NeDynamicSystemTag {\r\n  NeDynamicSystem mBase;\r\n  int32_T mRefCnt;\r\n  PmAllocator mAlloc;\r\n} _NeDynamicSystem;\r\n\r\n#else\r\n\r\ntypedef struct _NeDynamicSystemTag _NeDynamicSystem;\r\n\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_tdxf_p.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_tdxf_p.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_tdxf_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXF_P;\r\n  out.mNumCol = 15ULL;\r\n  out.mNumRow = 15ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mJc[2] = 6;\r\n  out.mJc[3] = 12;\r\n  out.mJc[4] = 14;\r\n  out.mJc[5] = 18;\r\n  out.mJc[6] = 19;\r\n  out.mJc[7] = 23;\r\n  out.mJc[8] = 26;\r\n  out.mJc[9] = 35;\r\n  out.mJc[10] = 36;\r\n  out.mJc[11] = 37;\r\n  out.mJc[12] = 38;\r\n  out.mJc[13] = 39;\r\n  out.mJc[14] = 40;\r\n  out.mJc[15] = 41;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 5;\r\n  out.mIr[2] = 1;\r\n  out.mIr[3] = 2;\r\n  out.mIr[4] = 13;\r\n  out.mIr[5] = 14;\r\n  out.mIr[6] = 0;\r\n  out.mIr[7] = 2;\r\n  out.mIr[8] = 5;\r\n  out.mIr[9] = 12;\r\n  out.mIr[10] = 13;\r\n  out.mIr[11] = 14;\r\n  out.mIr[12] = 5;\r\n  out.mIr[13] = 12;\r\n  out.mIr[14] = 2;\r\n  out.mIr[15] = 5;\r\n  out.mIr[16] = 13;\r\n  out.mIr[17] = 14;\r\n  out.mIr[18] = 4;\r\n  out.mIr[19] = 1;\r\n  out.mIr[20] = 2;\r\n  out.mIr[21] = 13;\r\n  out.mIr[22] = 14;\r\n  out.mIr[23] = 2;\r\n  out.mIr[24] = 13;\r\n  out.mIr[25] = 14;\r\n  out.mIr[26] = 3;\r\n  out.mIr[27] = 4;\r\n  out.mIr[28] = 5;\r\n  out.mIr[29] = 6;\r\n  out.mIr[30] = 7;\r\n  out.mIr[31] = 8;\r\n  out.mIr[32] = 9;\r\n  out.mIr[33] = 10;\r\n  out.mIr[34] = 11;\r\n  out.mIr[35] = 3;\r\n  out.mIr[36] = 6;\r\n  out.mIr[37] = 7;\r\n  out.mIr[38] = 8;\r\n  out.mIr[39] = 9;\r\n  out.mIr[40] = 10;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_tdxf_p.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_TDXF_P_H\r\n#define SIM0_627956E1_1_DS_TDXF_P_H    1\r\n\r\n  int32_T SIM0_627956e1_1_ds_tdxf_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_ds_zc.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_sys_struct.h\"\r\n#include \"SIM0_627956e1_1_ds_zc.h\"\r\n#include \"SIM0_627956e1_1_ds.h\"\r\n#include \"SIM0_627956e1_1_ds_externals.h\"\r\n#include \"SIM0_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T SIM0_627956e1_1_ds_zc(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T U_idx_6;\r\n  real_T U_idx_7;\r\n  real_T X_idx_1;\r\n  real_T X_idx_6;\r\n  real_T X_idx_8;\r\n  real_T t0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_10;\r\n  int32_T M_idx_11;\r\n  int32_T M_idx_12;\r\n  int32_T M_idx_14;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_1 = t3->mM.mX[1];\r\n  M_idx_8 = t3->mM.mX[8];\r\n  M_idx_9 = t3->mM.mX[9];\r\n  M_idx_10 = t3->mM.mX[10];\r\n  M_idx_11 = t3->mM.mX[11];\r\n  M_idx_12 = t3->mM.mX[12];\r\n  M_idx_14 = t3->mM.mX[14];\r\n  U_idx_4 = t3->mU.mX[4];\r\n  U_idx_5 = t3->mU.mX[5];\r\n  U_idx_6 = t3->mU.mX[6];\r\n  U_idx_7 = t3->mU.mX[7];\r\n  X_idx_1 = t3->mX.mX[1];\r\n  X_idx_6 = t3->mX.mX[6];\r\n  X_idx_8 = t3->mX.mX[8];\r\n  D_idx_0 = t3->mD.mX[0];\r\n  out = t4->mZC;\r\n  if ((!(D_idx_0 == 1.0)) && (!(D_idx_0 == 2.0)) && (!(D_idx_0 == 3.0))) {\r\n    t0 = 1.5 - U_idx_6;\r\n  } else {\r\n    t0 = 0.0;\r\n  }\r\n\r\n  if ((!(D_idx_0 == 1.0)) && (!(D_idx_0 == 2.0)) && (!(D_idx_0 == 3.0)) &&\r\n      (M_idx_14 == 0)) {\r\n    U_idx_6 = 2.5 - U_idx_6;\r\n  } else {\r\n    U_idx_6 = 0.0;\r\n  }\r\n\r\n  out.mX[0] = (X_idx_6 * 1.0E-6 + X_idx_1) - 0.6;\r\n  out.mX[1] = (real_T)(X_idx_8 == 1.0);\r\n  out.mX[2] = (real_T)((M_idx_1 == 0) && (X_idx_8 == 2.0));\r\n  out.mX[3] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (X_idx_8 == 3.0));\r\n  out.mX[4] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (X_idx_8 == 4.0));\r\n  out.mX[5] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (M_idx_10 == 0) && (X_idx_8 == 5.0));\r\n  out.mX[6] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (M_idx_10 == 0) && (M_idx_11 == 0) && (X_idx_8 == 6.0));\r\n  out.mX[7] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (M_idx_10 == 0) && (M_idx_11 == 0) && (M_idx_12 == 0) &&\r\n                       (X_idx_8 == 7.0));\r\n  out.mX[8] = t0;\r\n  out.mX[9] = U_idx_6;\r\n  out.mX[10] = 1.0;\r\n  out.mX[11] = 1.0;\r\n  out.mX[12] = 1.0;\r\n  out.mX[13] = U_idx_7 - 0.5;\r\n  out.mX[14] = U_idx_4 - 0.5;\r\n  out.mX[15] = U_idx_5 - 0.5;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"SIM0_627956e1_1_ds_zc.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SIM0_627956E1_1_DS_ZC_H\r\n#define SIM0_627956E1_1_DS_ZC_H        1\r\n\r\n  int32_T SIM0_627956e1_1_ds_zc(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"SIM0_627956e1_1_gateway.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'SIM0/SIM/Solver Configuration'.\r\n */\r\n\r\n#ifdef MATLAB_MEX_FILE\r\n#include \"tmwtypes.h\"\r\n#else\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"nesl_rtw.h\"\r\n#include \"SIM0_627956e1_1.h\"\r\n#include \"SIM0_627956e1_1_gateway.h\"\r\n\r\nvoid SIM0_627956e1_1_gateway(void)\r\n{\r\n  NeModelParameters modelparams = { (NeSolverType) 0, 0.001, 0.001, 0.001, 0, 0,\r\n    (NeModifyAbsTol) 0, 0.001, 0, 0, 0, 0, (SscLoggingSetting) 0, 571633359, 1,\r\n  };\r\n\r\n  NeSolverParameters solverparams = { 0, 0, 1, 0, 0, 0.001, 0.001, 1e-09, 0, 0,\r\n    100, 0, 1, (NeIndexReductionMethod) 1, 0, 1e-09, 1, (NeLocalSolverChoice) 0,\r\n    0.2, 1, 3, 2, 0, 2, (NeLinearAlgebraChoice) 0, 0,\r\n    (NeEquationFormulationChoice) 0, 1024, 1, 0.001, (NePartitionStorageMethod)\r\n    0, 1024, (NePartitionMethod) 0, };\r\n\r\n  const NeOutputParameters* outputparameters = NULL;\r\n  NeDae* dae;\r\n  size_t numOutputs = 0;\r\n  int* rtpDaes = NULL;\r\n  int* rtwLogDaes = NULL;\r\n\r\n  {\r\n    static const NeOutputParameters outputparameters_init[] = { { 0, 0, }, { 0,\r\n        1, }, { 0, 2, }, };\r\n\r\n    outputparameters = outputparameters_init;\r\n    numOutputs = sizeof(outputparameters_init)/sizeof(outputparameters_init[0]);\r\n  }\r\n\r\n  SIM0_627956e1_1_dae(&dae,\r\n                      &modelparams,\r\n                      &solverparams);\r\n  nesl_register_simulator_group(\"SIM0/SIM/Solver Configuration_1\",\r\n    1,\r\n    &dae,\r\n    &solverparams,\r\n    &modelparams,\r\n    numOutputs,\r\n    outputparameters,\r\n    0,\r\n    rtpDaes,\r\n    0,\r\n    rtwLogDaes);\r\n}\r\n"},{"name":"SIM0_627956e1_1_gateway.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __SIM0_627956e1_1_gateway_h__\r\n#define __SIM0_627956e1_1_gateway_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void SIM0_627956e1_1_gateway(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif\r\n"},{"name":"ssc_ml_fun.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\SIM0_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SSC_ML_FUN_H\r\n#define SSC_ML_FUN_H                   1\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n};\r\n\r\n#endif\r\n"}]};