var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"model/CBR","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CBR_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include <stddef.h>\r\n#include <stdio.h>\r\n#include \"CBR.h\"\r\n\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(CBR_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n  CBR_step();\r\n  OverrunFlag = false;\r\n}\r\n\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  (void)(argc);\r\n  (void)(argv);\r\n  CBR_initialize();\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(CBR_M) == (NULL)) {\r\n  }\r\n\r\n  CBR_terminate();\r\n  return 0;\r\n}\r\n"},{"name":"CBR.c","type":"source","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CBR_ert_rtw","tag":"","groupDisplay":"Model files","code":"#include \"CBR.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"CBR_private.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <string.h>\r\n#include \"sort_iw8mDS81.h\"\r\n#include \"look1_binlxpw.h\"\r\n\r\n#define CBR_IN_CB_state_               ((uint8_T)1U)\r\n#define CBR_IN_CC_state_               ((uint8_T)2U)\r\n#define CBR_IN_CV_state_               ((uint8_T)3U)\r\n#define CBR_IN_Entry_                  ((uint8_T)4U)\r\n\r\nDW_CBR_T CBR_DW;\r\nExtU_CBR_T CBR_U;\r\nExtY_CBR_T CBR_Y;\r\nstatic RT_MODEL_CBR_T CBR_M_;\r\nRT_MODEL_CBR_T *const CBR_M = &CBR_M_;\r\nvoid CBR_MATLABFunction1(const real_T rtu_u[126], real_T *rty_y)\r\n{\r\n  real_T y;\r\n  int32_T k;\r\n  y = rtu_u[0];\r\n  for (k = 0; k < 125; k++) {\r\n    y += rtu_u[k + 1];\r\n  }\r\n\r\n  *rty_y = y / 126.0;\r\n}\r\n\r\nvoid CBR_step(void)\r\n{\r\n  real_T rtb_ocvz[126];\r\n  real_T a;\r\n  real_T rtb_y;\r\n  real_T rtb_y_e;\r\n  real_T rtb_y_f;\r\n  real_T rtb_y_k;\r\n  real_T t;\r\n  int32_T iidx[126];\r\n  int32_T idx;\r\n  int32_T k;\r\n  CBR_Y.Current = CBR_DW.Memory_PreviousInput;\r\n  for (idx = 0; idx < 126; idx++) {\r\n    CBR_Y.Balances[idx] = CBR_DW.Memory1_PreviousInput[idx];\r\n    rtb_ocvz[idx] = look1_binlxpw(CBR_U.SOCs[idx], CBR_P.soc, CBR_P.ocv, 12U);\r\n  }\r\n\r\n  if (!rtIsNaN(CBR_U.Voltages[0])) {\r\n    idx = 1;\r\n  } else {\r\n    boolean_T exitg1;\r\n    idx = 0;\r\n    k = 2;\r\n    exitg1 = false;\r\n    while ((!exitg1) && (k < 127)) {\r\n      if (!rtIsNaN(CBR_U.Voltages[k - 1])) {\r\n        idx = k;\r\n        exitg1 = true;\r\n      } else {\r\n        k++;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (idx == 0) {\r\n    rtb_y_k = CBR_U.Voltages[0];\r\n  } else {\r\n    rtb_y_k = CBR_U.Voltages[idx - 1];\r\n    while (idx + 1 <= 126) {\r\n      if (rtb_y_k < CBR_U.Voltages[idx]) {\r\n        rtb_y_k = CBR_U.Voltages[idx];\r\n      }\r\n\r\n      idx++;\r\n    }\r\n  }\r\n\r\n  rtb_y = 0.0;\r\n  rtb_y_e = CBR_U.Voltages[0];\r\n  for (idx = 0; idx < 125; idx++) {\r\n    rtb_y_e += CBR_U.Voltages[idx + 1];\r\n  }\r\n\r\n  rtb_y_e /= 126.0;\r\n  for (k = 0; k < 126; k++) {\r\n    t = CBR_U.Voltages[k] - rtb_y_e;\r\n    rtb_y += t * t;\r\n  }\r\n\r\n  real_T rtb_Rsz1;\r\n  rtb_y /= 125.0;\r\n  CBR_MATLABFunction1(rtb_ocvz, &rtb_y_e);\r\n  rtb_y_e = CBR_P.U_sought - rtb_y_e;\r\n  CBR_MATLABFunction1(CBR_U.SOCs, &rtb_y_f);\r\n  rtb_Rsz1 = look1_binlxpw(rtb_y_f, CBR_P.soc, CBR_P.Rs, 12U);\r\n  t = look1_binlxpw(rtb_y_f, CBR_P.soc, CBR_P.tau, 12U);\r\n  a = rtb_Rsz1 * t;\r\n  rtb_y_f = (rtb_Rsz1 + look1_binlxpw(rtb_y_f, CBR_P.soc, CBR_P.Rp, 12U)) *\r\n    CBR_P.Ts;\r\n  t = (((2.0 * t + CBR_P.Ts) * rtb_y_e + (CBR_P.Ts - 2.0 * t) *\r\n        CBR_DW.Memory5_PreviousInput) - (rtb_y_f - 2.0 * a) *\r\n       CBR_DW.Memory6_PreviousInput) / (2.0 * a + rtb_y_f);\r\n  if (CBR_DW.is_active_c5_CBR == 0U) {\r\n    CBR_DW.is_active_c5_CBR = 1U;\r\n    CBR_DW.is_c5_CBR = CBR_IN_Entry_;\r\n    rtb_y_k = 0.0;\r\n    rtb_y = 0.0;\r\n    a = 0.0;\r\n  } else {\r\n    switch (CBR_DW.is_c5_CBR) {\r\n     case CBR_IN_CB_state_:\r\n      if (rtb_y < CBR_P.U_tol) {\r\n        CBR_DW.is_c5_CBR = CBR_IN_Entry_;\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 0.0;\r\n        a = 0.0;\r\n      } else if (rtb_y_k < CBR_P.U_sought - CBR_P.U_CC) {\r\n        CBR_DW.is_c5_CBR = CBR_IN_CC_state_;\r\n        rtb_y_k = 1.0;\r\n        rtb_y = 0.0;\r\n        a = 0.0;\r\n      } else {\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 0.0;\r\n        a = 1.0;\r\n      }\r\n      break;\r\n\r\n     case CBR_IN_CC_state_:\r\n      if (rtb_y_k > CBR_P.U_sought - CBR_P.U_CC) {\r\n        CBR_DW.is_c5_CBR = CBR_IN_CV_state_;\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 1.0;\r\n        a = 0.0;\r\n      } else {\r\n        rtb_y_k = 1.0;\r\n        rtb_y = 0.0;\r\n        a = 0.0;\r\n      }\r\n      break;\r\n\r\n     case CBR_IN_CV_state_:\r\n      if (t * t < CBR_P.I_CV * CBR_P.I_CV) {\r\n        CBR_DW.is_c5_CBR = CBR_IN_CB_state_;\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 0.0;\r\n        a = 1.0;\r\n      } else {\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 1.0;\r\n        a = 0.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      if (rtb_y_k < CBR_P.U_sought - CBR_P.U_CC) {\r\n        CBR_DW.is_c5_CBR = CBR_IN_CC_state_;\r\n        rtb_y_k = 1.0;\r\n        rtb_y = 0.0;\r\n        a = 0.0;\r\n      } else if (rtb_y > CBR_P.U_tol) {\r\n        CBR_DW.is_c5_CBR = CBR_IN_CB_state_;\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 0.0;\r\n        a = 1.0;\r\n      } else {\r\n        rtb_y_k = 0.0;\r\n        rtb_y = 0.0;\r\n        a = 0.0;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (idx = 0; idx < 126; idx++) {\r\n    CBR_DW.Memory1_PreviousInput[idx] = CBR_U.Voltages[idx] * 0.0;\r\n  }\r\n\r\n  if (a != 0.0) {\r\n    memcpy(&rtb_ocvz[0], &CBR_U.Voltages[0], 126U * sizeof(real_T));\r\n    sort_iw8mDS81(rtb_ocvz, iidx);\r\n    for (idx = 0; idx < 126; idx++) {\r\n      rtb_ocvz[idx] = iidx[idx];\r\n    }\r\n\r\n    for (k = 0; k < 36; k++) {\r\n      CBR_DW.Memory1_PreviousInput[(int32_T)rtb_ocvz[k] - 1] = 1.0;\r\n    }\r\n  }\r\n\r\n  CBR_DW.Memory_PreviousInput = rtb_y_k * CBR_P.C_r + rtb_y * t;\r\n  CBR_DW.Memory6_PreviousInput = t;\r\n  CBR_DW.Memory5_PreviousInput = rtb_y_e;\r\n}\r\n\r\nvoid CBR_initialize(void)\r\n{\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  {\r\n    int32_T i;\r\n    CBR_DW.Memory_PreviousInput = CBR_P.Memory_InitialCondition;\r\n    for (i = 0; i < 126; i++) {\r\n      CBR_DW.Memory1_PreviousInput[i] = CBR_P.Memory1_InitialCondition;\r\n    }\r\n\r\n    CBR_DW.Memory6_PreviousInput = CBR_P.Memory6_InitialCondition;\r\n    CBR_DW.Memory5_PreviousInput = CBR_P.Memory5_InitialCondition;\r\n  }\r\n}\r\n\r\nvoid CBR_terminate(void)\r\n{\r\n}\r\n"},{"name":"CBR.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CBR_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_CBR_h_\r\n#define RTW_HEADER_CBR_h_\r\n#ifndef CBR_COMMON_INCLUDES_\r\n#define CBR_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"CBR_types.h\"\r\n#include \"rtGetInf.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\ntypedef struct {\r\n  real_T Memory_PreviousInput;\r\n  real_T Memory1_PreviousInput[126];\r\n  real_T Memory6_PreviousInput;\r\n  real_T Memory5_PreviousInput;\r\n  uint8_T is_active_c5_CBR;\r\n  uint8_T is_c5_CBR;\r\n} DW_CBR_T;\r\n\r\ntypedef struct {\r\n  real_T Voltages[126];\r\n  real_T SOCs[126];\r\n} ExtU_CBR_T;\r\n\r\ntypedef struct {\r\n  real_T Current;\r\n  real_T Balances[126];\r\n} ExtY_CBR_T;\r\n\r\nstruct P_CBR_T_ {\r\n  real_T C_r;\r\n  real_T I_CV;\r\n  real_T Rp[13];\r\n  real_T Rs[13];\r\n  real_T Ts;\r\n  real_T U_CC;\r\n  real_T U_sought;\r\n  real_T U_tol;\r\n  real_T ocv[13];\r\n  real_T soc[13];\r\n  real_T tau[13];\r\n  real_T Memory_InitialCondition;\r\n  real_T Memory1_InitialCondition;\r\n  real_T Memory6_InitialCondition;\r\n  real_T Memory5_InitialCondition;\r\n};\r\n\r\nstruct tag_RTM_CBR_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\nextern P_CBR_T CBR_P;\r\nextern DW_CBR_T CBR_DW;\r\nextern ExtU_CBR_T CBR_U;\r\nextern ExtY_CBR_T CBR_Y;\r\nextern void CBR_initialize(void);\r\nextern void CBR_step(void);\r\nextern void CBR_terminate(void);\r\nextern RT_MODEL_CBR_T *const CBR_M;\r\n\r\n#endif\r\n\r\n"},{"name":"CBR_private.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CBR_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_CBR_private_h_\r\n#define RTW_HEADER_CBR_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"CBR.h\"\r\n\r\nextern void CBR_MATLABFunction1(const real_T rtu_u[126], real_T *rty_y);\r\n\r\n#endif\r\n\r\n"},{"name":"CBR_types.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CBR_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_CBR_types_h_\r\n#define RTW_HEADER_CBR_types_h_\r\n\r\ntypedef struct P_CBR_T_ P_CBR_T;\r\ntypedef struct tag_RTM_CBR_T RT_MODEL_CBR_T;\r\n\r\n#endif\r\n\r\n"},{"name":"CBR_data.c","type":"source","group":"data","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CBR_ert_rtw","tag":"","groupDisplay":"Data files","code":"#include \"CBR.h\"\r\n\r\nP_CBR_T CBR_P = {\r\n\r\n  6.6,\r\n\r\n  1.0,\r\n\r\n\r\n  { 0.0013284973182, 0.00132849731829051, 0.00133071540686515,\r\n    0.00133106364620441, 0.00133282418704394, 0.00133927918011939,\r\n    0.00135371077616641, 0.00137940112592065, 0.00141963238011775,\r\n    0.00147768668949337, 0.00155684620478314, 0.00166039307672272,\r\n    0.00179160945604776 },\r\n\r\n\r\n  { 0.0044622496006, 0.00446224960061823, 0.00395928973129493,\r\n    0.00365723545490869, 0.00346135878439388, 0.00332839611795259,\r\n    0.00323577769308545, 0.00317057626115591, 0.00312485453442757,\r\n    0.00309346940400882, 0.00307294184679812, 0.00306083426030356,\r\n    0.00305538791678206 },\r\n\r\n  0.2,\r\n\r\n  0.06,\r\n\r\n  4.15,\r\n\r\n  5.0E-7,\r\n\r\n\r\n  { 0.0, 2.99808472821531, 3.29015678205606, 3.51449858492796, 3.66802196422992,\r\n    3.76050972589663, 3.81021773542304, 3.83947699888896, 3.87029574398353,\r\n    3.91996150102984, 3.99664318400941, 4.09499317158672, 4.19174938813381 },\r\n\r\n\r\n  { 0.0, 0.01, 0.0909090909090909, 0.181818181818182, 0.272727272727273,\r\n    0.363636363636364, 0.454545454545455, 0.545454545454545, 0.636363636363636,\r\n    0.727272727272727, 0.818181818181818, 0.909090909090909, 1.0 },\r\n\r\n\r\n  { 950.87194683, 950.871946837005, 952.459545918238, 952.715608141667,\r\n    956.801088701637, 1116.9800008749899, 2163.29230815358, 2204.3466729378397,\r\n    1183.99583949683, 1060.79424954235, 1114.3206284707098, 1188.42633649718,\r\n    1282.34445639369 },\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0\r\n};\r\n"},{"name":"look1_binlxpw.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"look1_binlxpw.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nreal_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n                     uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T yL_0d0;\r\n  uint32_T iLeft;\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n    bpIdx = maxIndex >> 1U;\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while (iRght - iLeft > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = (iRght + iLeft) >> 1U;\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  yL_0d0 = table[iLeft];\r\n  return (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n"},{"name":"look1_binlxpw.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_look1_binlxpw_h_\r\n#define RTW_HEADER_look1_binlxpw_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T maxIndex);\r\n\r\n#endif\r\n\r\n"},{"name":"merge_SqkScL3b.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"merge_SqkScL3b.h\"\r\n\r\nvoid merge_SqkScL3b(int32_T idx[126], real_T x[126], int32_T offset, int32_T np,\r\n                    int32_T nq, int32_T iwork[126], real_T xwork[126])\r\n{\r\n  int32_T q;\r\n  if ((np != 0) && (nq != 0)) {\r\n    int32_T iout;\r\n    int32_T n;\r\n    int32_T n_tmp;\r\n    n_tmp = np + nq;\r\n    for (q = 0; q < n_tmp; q++) {\r\n      iout = offset + q;\r\n      iwork[q] = idx[iout];\r\n      xwork[q] = x[iout];\r\n    }\r\n\r\n    n = 0;\r\n    q = np;\r\n    iout = offset - 1;\r\n    int32_T exitg1;\r\n    do {\r\n      exitg1 = 0;\r\n      iout++;\r\n      if (xwork[n] >= xwork[q]) {\r\n        idx[iout] = iwork[n];\r\n        x[iout] = xwork[n];\r\n        if (n + 1 < np) {\r\n          n++;\r\n        } else {\r\n          exitg1 = 1;\r\n        }\r\n      } else {\r\n        idx[iout] = iwork[q];\r\n        x[iout] = xwork[q];\r\n        if (q + 1 < n_tmp) {\r\n          q++;\r\n        } else {\r\n          q = iout - n;\r\n          while (n + 1 <= np) {\r\n            iout = (q + n) + 1;\r\n            idx[iout] = iwork[n];\r\n            x[iout] = xwork[n];\r\n            n++;\r\n          }\r\n\r\n          exitg1 = 1;\r\n        }\r\n      }\r\n    } while (exitg1 == 0);\r\n  }\r\n}\r\n"},{"name":"merge_SqkScL3b.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_merge_SqkScL3b_h_\r\n#define RTW_HEADER_merge_SqkScL3b_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void merge_SqkScL3b(int32_T idx[126], real_T x[126], int32_T offset,\r\n  int32_T np, int32_T nq, int32_T iwork[126], real_T xwork[126]);\r\n\r\n#endif\r\n\r\n"},{"name":"rtGetInf.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif\r\n\r\n"},{"name":"rtGetNaN.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif\r\n\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif\r\n\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n"},{"name":"sort_iw8mDS81.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"sort_iw8mDS81.h\"\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"merge_SqkScL3b.h\"\r\n\r\nvoid sort_iw8mDS81(real_T x[126], int32_T idx[126])\r\n{\r\n  real_T xwork[126];\r\n  real_T x4[4];\r\n  int32_T iwork[126];\r\n  int32_T i;\r\n  int32_T i1;\r\n  int32_T i2;\r\n  int32_T ib;\r\n  int32_T nNaNs;\r\n  int8_T idx4[4];\r\n  int8_T perm[4];\r\n  x4[0] = 0.0;\r\n  idx4[0] = 0;\r\n  x4[1] = 0.0;\r\n  idx4[1] = 0;\r\n  x4[2] = 0.0;\r\n  idx4[2] = 0;\r\n  x4[3] = 0.0;\r\n  idx4[3] = 0;\r\n  memset(&idx[0], 0, 126U * sizeof(int32_T));\r\n  memset(&xwork[0], 0, 126U * sizeof(real_T));\r\n  nNaNs = 0;\r\n  ib = -1;\r\n  for (i = 0; i < 126; i++) {\r\n    if (rtIsNaN(x[i])) {\r\n      idx[125 - nNaNs] = i + 1;\r\n      xwork[125 - nNaNs] = x[i];\r\n      nNaNs++;\r\n    } else {\r\n      ib++;\r\n      idx4[ib] = (int8_T)(i + 1);\r\n      x4[ib] = x[i];\r\n      if (ib + 1 == 4) {\r\n        real_T tmp;\r\n        real_T tmp_0;\r\n        int32_T i3;\r\n        int32_T i4;\r\n        ib = i - nNaNs;\r\n        if (x4[0] >= x4[1]) {\r\n          i1 = 1;\r\n          i2 = 2;\r\n        } else {\r\n          i1 = 2;\r\n          i2 = 1;\r\n        }\r\n\r\n        if (x4[2] >= x4[3]) {\r\n          i3 = 3;\r\n          i4 = 4;\r\n        } else {\r\n          i3 = 4;\r\n          i4 = 3;\r\n        }\r\n\r\n        tmp = x4[i1 - 1];\r\n        tmp_0 = x4[i3 - 1];\r\n        if (tmp >= tmp_0) {\r\n          tmp = x4[i2 - 1];\r\n          if (tmp >= tmp_0) {\r\n            perm[0] = (int8_T)i1;\r\n            perm[1] = (int8_T)i2;\r\n            perm[2] = (int8_T)i3;\r\n            perm[3] = (int8_T)i4;\r\n          } else if (tmp >= x4[i4 - 1]) {\r\n            perm[0] = (int8_T)i1;\r\n            perm[1] = (int8_T)i3;\r\n            perm[2] = (int8_T)i2;\r\n            perm[3] = (int8_T)i4;\r\n          } else {\r\n            perm[0] = (int8_T)i1;\r\n            perm[1] = (int8_T)i3;\r\n            perm[2] = (int8_T)i4;\r\n            perm[3] = (int8_T)i2;\r\n          }\r\n        } else {\r\n          tmp_0 = x4[i4 - 1];\r\n          if (tmp >= tmp_0) {\r\n            if (x4[i2 - 1] >= tmp_0) {\r\n              perm[0] = (int8_T)i3;\r\n              perm[1] = (int8_T)i1;\r\n              perm[2] = (int8_T)i2;\r\n              perm[3] = (int8_T)i4;\r\n            } else {\r\n              perm[0] = (int8_T)i3;\r\n              perm[1] = (int8_T)i1;\r\n              perm[2] = (int8_T)i4;\r\n              perm[3] = (int8_T)i2;\r\n            }\r\n          } else {\r\n            perm[0] = (int8_T)i3;\r\n            perm[1] = (int8_T)i4;\r\n            perm[2] = (int8_T)i1;\r\n            perm[3] = (int8_T)i2;\r\n          }\r\n        }\r\n\r\n        idx[ib - 3] = idx4[perm[0] - 1];\r\n        idx[ib - 2] = idx4[perm[1] - 1];\r\n        idx[ib - 1] = idx4[perm[2] - 1];\r\n        idx[ib] = idx4[perm[3] - 1];\r\n        x[ib - 3] = x4[perm[0] - 1];\r\n        x[ib - 2] = x4[perm[1] - 1];\r\n        x[ib - 1] = x4[perm[2] - 1];\r\n        x[ib] = x4[perm[3] - 1];\r\n        ib = -1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (ib + 1 > 0) {\r\n    perm[1] = 0;\r\n    perm[2] = 0;\r\n    perm[3] = 0;\r\n    switch (ib + 1) {\r\n     case 1:\r\n      perm[0] = 1;\r\n      break;\r\n\r\n     case 2:\r\n      if (x4[0] >= x4[1]) {\r\n        perm[0] = 1;\r\n        perm[1] = 2;\r\n      } else {\r\n        perm[0] = 2;\r\n        perm[1] = 1;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      if (x4[0] >= x4[1]) {\r\n        if (x4[1] >= x4[2]) {\r\n          perm[0] = 1;\r\n          perm[1] = 2;\r\n          perm[2] = 3;\r\n        } else if (x4[0] >= x4[2]) {\r\n          perm[0] = 1;\r\n          perm[1] = 3;\r\n          perm[2] = 2;\r\n        } else {\r\n          perm[0] = 3;\r\n          perm[1] = 1;\r\n          perm[2] = 2;\r\n        }\r\n      } else if (x4[0] >= x4[2]) {\r\n        perm[0] = 2;\r\n        perm[1] = 1;\r\n        perm[2] = 3;\r\n      } else if (x4[1] >= x4[2]) {\r\n        perm[0] = 2;\r\n        perm[1] = 3;\r\n        perm[2] = 1;\r\n      } else {\r\n        perm[0] = 3;\r\n        perm[1] = 2;\r\n        perm[2] = 1;\r\n      }\r\n      break;\r\n    }\r\n\r\n    for (i = 0; i <= ib; i++) {\r\n      i1 = perm[i] - 1;\r\n      i2 = ((i - nNaNs) - ib) + 125;\r\n      idx[i2] = idx4[i1];\r\n      x[i2] = x4[i1];\r\n    }\r\n  }\r\n\r\n  i = (nNaNs >> 1) + 126;\r\n  for (ib = 126; ib - 126 <= i - 127; ib++) {\r\n    i2 = ib - nNaNs;\r\n    i1 = idx[i2];\r\n    idx[i2] = idx[251 - ib];\r\n    idx[251 - ib] = i1;\r\n    x[i2] = xwork[251 - ib];\r\n    x[251 - ib] = xwork[i2];\r\n  }\r\n\r\n  if ((nNaNs & 1U) != 0U) {\r\n    ib = i - nNaNs;\r\n    x[ib] = xwork[ib];\r\n  }\r\n\r\n  memset(&iwork[0], 0, 126U * sizeof(int32_T));\r\n  if (126 - nNaNs > 1) {\r\n    memset(&iwork[0], 0, 126U * sizeof(int32_T));\r\n    ib = (126 - nNaNs) >> 2;\r\n    i = 4;\r\n    while (ib > 1) {\r\n      if ((ib & 1U) != 0U) {\r\n        ib--;\r\n        i1 = i * ib;\r\n        i2 = 126 - (nNaNs + i1);\r\n        if (i2 > i) {\r\n          merge_SqkScL3b(idx, x, i1, i, i2 - i, iwork, xwork);\r\n        }\r\n      }\r\n\r\n      i1 = i << 1;\r\n      ib >>= 1;\r\n      for (i2 = 0; i2 < ib; i2++) {\r\n        merge_SqkScL3b(idx, x, i2 * i1, i, i, iwork, xwork);\r\n      }\r\n\r\n      i = i1;\r\n    }\r\n\r\n    if (126 - nNaNs > i) {\r\n      merge_SqkScL3b(idx, x, 0, i, 126 - (nNaNs + i), iwork, xwork);\r\n    }\r\n  }\r\n\r\n  if ((nNaNs > 0) && (126 - nNaNs > 0)) {\r\n    for (i = 0; i < nNaNs; i++) {\r\n      ib = (i - nNaNs) + 126;\r\n      xwork[i] = x[ib];\r\n      iwork[i] = idx[ib];\r\n    }\r\n\r\n    for (i = 125 - nNaNs; i + 1 > 0; i--) {\r\n      ib = nNaNs + i;\r\n      x[ib] = x[i];\r\n      idx[ib] = idx[i];\r\n    }\r\n\r\n    for (i = 0; i < nNaNs; i++) {\r\n      x[i] = xwork[i];\r\n      idx[i] = iwork[i];\r\n    }\r\n  }\r\n}\r\n"},{"name":"sort_iw8mDS81.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_sort_iw8mDS81_h_\r\n#define RTW_HEADER_sort_iw8mDS81_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void sort_iw8mDS81(real_T x[126], int32_T idx[126]);\r\n\r\n#endif\r\n\r\n"}]};