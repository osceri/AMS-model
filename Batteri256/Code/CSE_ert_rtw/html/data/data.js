var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"model/CSE","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CSE_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include <stddef.h>\r\n#include <stdio.h>\r\n#include \"CSE.h\"\r\n\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(CSE_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n  CSE_step();\r\n  OverrunFlag = false;\r\n}\r\n\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  (void)(argc);\r\n  (void)(argv);\r\n  CSE_initialize();\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(CSE_M) == (NULL)) {\r\n  }\r\n\r\n  CSE_terminate();\r\n  return 0;\r\n}\r\n"},{"name":"CSE.c","type":"source","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CSE_ert_rtw","tag":"","groupDisplay":"Model files","code":"#include \"CSE.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"CSE_private.h\"\r\n#include <math.h>\r\n#include \"trisolve_BC1XmAGq.h\"\r\n#include \"UTMeanCovSqrt_C2vgLQ4W.h\"\r\n#include <string.h>\r\n#include \"qr_DvOBrgQi.h\"\r\n#include \"svd_u3DvUgOe.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rotate_LZ7ctbe0.h\"\r\n#include \"qr_5a2P8Gh6.h\"\r\n#include \"UTMeanCovSqrt_C6QfB9Td.h\"\r\n#include \"xnrm2_Mnmxg9YT.h\"\r\n#include \"rt_hypotd_snf.h\"\r\n#include \"look1_binlxpw.h\"\r\n\r\nDW_CSE_T CSE_DW;\r\nExtU_CSE_T CSE_U;\r\nExtY_CSE_T CSE_Y;\r\nstatic RT_MODEL_CSE_T CSE_M_;\r\nRT_MODEL_CSE_T *const CSE_M = &CSE_M_;\r\nstatic void UKFCorrectorAdditive_getPredict(real_T Rs, const real_T X1[3], const\r\n  real_T S[9], real_T alpha, real_T beta, real_T kappa, real_T *Ymean, real_T\r\n  Pxy[3], real_T *Sy);\r\nvoid CSE_S_x(const real_T rtu_x[3], real_T rty_x_next[3])\r\n{\r\n  real_T rtb_Divide;\r\n  real_T tmp;\r\n  rtb_Divide = rtu_x[1] / rtu_x[2];\r\n  tmp = exp(-CSE_P.Ts / look1_binlxpw(rtb_Divide, CSE_P.soc, CSE_P.tau, 12U));\r\n  rty_x_next[0] = (1.0 - tmp) * CSE_U.current * look1_binlxpw(rtb_Divide,\r\n    CSE_P.soc, CSE_P.Rp, 12U) + tmp * rtu_x[0];\r\n  rty_x_next[1] = CSE_U.current * CSE_P.Ts + rtu_x[1];\r\n  rty_x_next[2] = rtu_x[2];\r\n}\r\n\r\nvoid CSE_M_x(const real_T rtu_x[3], real_T *rty_y)\r\n{\r\n  real_T rtb_Divide;\r\n  rtb_Divide = rtu_x[1] / rtu_x[2];\r\n  *rty_y = (CSE_U.current * look1_binlxpw(rtb_Divide, CSE_P.soc, CSE_P.Rs, 12U)\r\n            + look1_binlxpw(rtb_Divide, CSE_P.soc, CSE_P.ocv, 12U)) + rtu_x[0];\r\n}\r\n\r\nstatic void UKFCorrectorAdditive_getPredict(real_T Rs, const real_T X1[3], const\r\n  real_T S[9], real_T alpha, real_T beta, real_T kappa, real_T *Ymean, real_T\r\n  Pxy[3], real_T *Sy)\r\n{\r\n  real_T X2[18];\r\n  real_T Y2[6];\r\n  real_T Y2_0[6];\r\n  real_T Wcov[2];\r\n  real_T Wmean[2];\r\n  real_T tempY;\r\n  real_T tempY_tmp;\r\n  int32_T knt;\r\n  int32_T knt_0;\r\n  tempY_tmp = alpha * alpha;\r\n  tempY = (kappa + 3.0) * tempY_tmp;\r\n  Wmean[0] = 1.0 - 3.0 / tempY;\r\n  Wmean[1] = 1.0 / (2.0 * tempY);\r\n  Wcov[0] = ((1.0 - tempY_tmp) + beta) + Wmean[0];\r\n  Wcov[1] = Wmean[1];\r\n  if (Wmean[0] != 0.0) {\r\n    real_T Wcov_0;\r\n    *Sy = Wmean[0];\r\n    tempY_tmp = Wmean[0];\r\n    Wmean[0] /= Wmean[0];\r\n    Wcov[0] /= *Sy;\r\n    Wcov_0 = Wmean[1];\r\n    Wmean[1] /= tempY_tmp;\r\n    Wcov[1] = Wcov_0 / *Sy;\r\n  } else {\r\n    *Sy = 1.0;\r\n  }\r\n\r\n  tempY = sqrt(tempY);\r\n  for (knt = 0; knt < 9; knt++) {\r\n    tempY_tmp = tempY * S[knt];\r\n    X2[knt] = tempY_tmp;\r\n    X2[knt + 9] = -tempY_tmp;\r\n  }\r\n\r\n  knt_0 = 0;\r\n  for (knt = 0; knt < 6; knt++) {\r\n    X2[knt_0] += X1[0];\r\n    X2[knt_0 + 1] += X1[1];\r\n    X2[knt_0 + 2] += X1[2];\r\n    knt_0 += 3;\r\n  }\r\n\r\n  knt_0 = 0;\r\n  for (knt = 0; knt < 6; knt++) {\r\n    CSE_M_x(&X2[knt_0], &Y2[knt]);\r\n    knt_0 += 3;\r\n  }\r\n\r\n  CSE_M_x(X1, &tempY);\r\n  for (knt = 0; knt < 6; knt++) {\r\n    Y2_0[knt] = (Y2[knt] - tempY) + tempY;\r\n  }\r\n\r\n  UTMeanCovSqrt_C6QfB9Td(Wmean, Wcov, *Sy, tempY, Y2_0, X1, X2, Ymean,\r\n    &tempY_tmp, Pxy);\r\n  Wmean[0] = tempY_tmp;\r\n  Wmean[1] = Rs;\r\n  *Sy = tempY_tmp;\r\n  tempY = xnrm2_Mnmxg9YT(1, Wmean, 2);\r\n  if (tempY != 0.0) {\r\n    tempY = rt_hypotd_snf(tempY_tmp, tempY);\r\n    if (tempY_tmp >= 0.0) {\r\n      tempY = -tempY;\r\n    }\r\n\r\n    if (fabs(tempY) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        Wmean[1] *= 9.9792015476736E+291;\r\n        tempY *= 9.9792015476736E+291;\r\n        *Sy *= 9.9792015476736E+291;\r\n      } while ((fabs(tempY) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      tempY = rt_hypotd_snf(*Sy, xnrm2_Mnmxg9YT(1, Wmean, 2));\r\n      if (*Sy >= 0.0) {\r\n        tempY = -tempY;\r\n      }\r\n\r\n      for (knt_0 = 0; knt_0 < knt; knt_0++) {\r\n        tempY *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      *Sy = tempY;\r\n    } else {\r\n      *Sy = tempY;\r\n    }\r\n  }\r\n}\r\n\r\nvoid CSE_step(void)\r\n{\r\n  real_T X2state[18];\r\n  real_T Y2[18];\r\n  real_T R[9];\r\n  real_T R_0[9];\r\n  real_T Ss[9];\r\n  real_T tempY_0[9];\r\n  real_T C[3];\r\n  real_T K[3];\r\n  real_T s[3];\r\n  real_T tempY[3];\r\n  real_T s_0;\r\n  real_T temp;\r\n  int32_T aoffset;\r\n  int32_T coffset;\r\n  int32_T iAcol;\r\n  int32_T iAcol_0;\r\n  static const real_T Wmean[2] = { 1.0, -0.1666668333335 };\r\n\r\n  static const real_T Wcov[2] = { 0.999996999998, -0.1666668333335 };\r\n\r\n  if (CSE_P.Enable1_Value) {\r\n    boolean_T errorCondition;\r\n    boolean_T guard1 = false;\r\n    CSE_M_x(CSE_DW.x, &s_0);\r\n    UKFCorrectorAdditive_getPredict(CSE_P.R1_Value, CSE_DW.x, CSE_DW.P, 0.001,\r\n      2.0, 0.0, &s_0, tempY, &temp);\r\n    s_0 = CSE_U.y - s_0;\r\n    iAcol_0 = 0;\r\n    for (iAcol = 0; iAcol < 3; iAcol++) {\r\n      R[iAcol_0] = CSE_DW.P[iAcol];\r\n      R[iAcol_0 + 1] = CSE_DW.P[iAcol + 3];\r\n      R[iAcol_0 + 2] = CSE_DW.P[iAcol + 6];\r\n      C[iAcol] = tempY[iAcol];\r\n      iAcol_0 += 3;\r\n    }\r\n\r\n    trisolve_BC1XmAGq(temp, C);\r\n    K[0] = C[0];\r\n    K[1] = C[1];\r\n    K[2] = C[2];\r\n    trisolve_BC1XmAGq(temp, K);\r\n    tempY[0] = K[0] * temp;\r\n    for (iAcol = 0; iAcol < 2; iAcol++) {\r\n      R[iAcol + 1] = 0.0;\r\n    }\r\n\r\n    tempY[1] = K[1] * temp;\r\n    R[5] = 0.0;\r\n    tempY[2] = K[2] * temp;\r\n    errorCondition = (R[0] == 0.0);\r\n    if (!errorCondition) {\r\n      errorCondition = (R[4] == 0.0);\r\n    }\r\n\r\n    if (!errorCondition) {\r\n      errorCondition = (R[8] == 0.0);\r\n    }\r\n\r\n    guard1 = false;\r\n    if (errorCondition) {\r\n      guard1 = true;\r\n    } else {\r\n      real_T absxk;\r\n      real_T scale;\r\n      real_T t;\r\n      C[2] = tempY[2];\r\n      C[0] = tempY[0] / R[0];\r\n      C[1] = (tempY[1] - C[0] * R[3]) / R[4];\r\n      temp = tempY[2];\r\n      for (iAcol_0 = 0; iAcol_0 < 2; iAcol_0++) {\r\n        temp -= R[iAcol_0 + 6] * C[iAcol_0];\r\n      }\r\n\r\n      C[2] = temp / R[8];\r\n      scale = 3.3121686421112381E-170;\r\n      absxk = fabs(C[0]);\r\n      if (absxk > 3.3121686421112381E-170) {\r\n        temp = 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / 3.3121686421112381E-170;\r\n        temp = t * t;\r\n      }\r\n\r\n      absxk = fabs(C[1]);\r\n      if (absxk > scale) {\r\n        t = scale / absxk;\r\n        temp = temp * t * t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / scale;\r\n        temp += t * t;\r\n      }\r\n\r\n      absxk = fabs(C[2]);\r\n      if (absxk > scale) {\r\n        t = scale / absxk;\r\n        temp = temp * t * t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / scale;\r\n        temp += t * t;\r\n      }\r\n\r\n      temp = scale * sqrt(temp);\r\n      if (temp >= 1.0) {\r\n        guard1 = true;\r\n      } else {\r\n        rotate_LZ7ctbe0(sqrt(1.0 - temp * temp), C[2], &tempY[2], &s[2], &temp);\r\n        C[2] = 0.0;\r\n        rotate_LZ7ctbe0(temp, C[1], &tempY[1], &s[1], &temp);\r\n        C[1] = 0.0;\r\n        rotate_LZ7ctbe0(temp, C[0], &tempY[0], &s[0], &temp);\r\n        C[0] = 0.0;\r\n        for (iAcol_0 = 0; iAcol_0 + 1 > 0; iAcol_0--) {\r\n          temp = s[iAcol_0] * R[iAcol_0];\r\n          R[iAcol_0] = tempY[iAcol_0] * R[iAcol_0] - s[iAcol_0] * C[0];\r\n          C[0] = tempY[iAcol_0] * C[0] + temp;\r\n        }\r\n\r\n        for (iAcol_0 = 1; iAcol_0 + 1 > 0; iAcol_0--) {\r\n          temp = R[iAcol_0 + 3];\r\n          R[iAcol_0 + 3] = temp * tempY[iAcol_0] - s[iAcol_0] * C[1];\r\n          C[1] = tempY[iAcol_0] * C[1] + temp * s[iAcol_0];\r\n        }\r\n\r\n        for (iAcol_0 = 2; iAcol_0 + 1 > 0; iAcol_0--) {\r\n          temp = R[iAcol_0 + 6];\r\n          R[iAcol_0 + 6] = temp * tempY[iAcol_0] - s[iAcol_0] * C[2];\r\n          C[2] = tempY[iAcol_0] * C[2] + temp * s[iAcol_0];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (guard1) {\r\n      int32_T R_tmp;\r\n      boolean_T exitg2;\r\n      iAcol_0 = 0;\r\n      for (iAcol = 0; iAcol < 3; iAcol++) {\r\n        coffset = 0;\r\n        for (aoffset = 0; aoffset < 3; aoffset++) {\r\n          R_tmp = coffset + iAcol;\r\n          R_0[R_tmp] = 0.0;\r\n          R_0[R_tmp] += R[iAcol_0] * R[coffset];\r\n          R_0[R_tmp] += R[iAcol_0 + 1] * R[coffset + 1];\r\n          R_0[R_tmp] += R[iAcol_0 + 2] * R[coffset + 2];\r\n          tempY_0[aoffset + iAcol_0] = tempY[aoffset] * tempY[iAcol];\r\n          coffset += 3;\r\n        }\r\n\r\n        iAcol_0 += 3;\r\n      }\r\n\r\n      errorCondition = true;\r\n      for (iAcol = 0; iAcol < 9; iAcol++) {\r\n        temp = R_0[iAcol] - tempY_0[iAcol];\r\n        if (errorCondition && (rtIsInf(temp) || rtIsNaN(temp))) {\r\n          errorCondition = false;\r\n        }\r\n\r\n        Ss[iAcol] = temp;\r\n      }\r\n\r\n      if (errorCondition) {\r\n        svd_u3DvUgOe(Ss, tempY_0, s, R_0);\r\n      } else {\r\n        s[0] = (rtNaN);\r\n        s[1] = (rtNaN);\r\n        s[2] = (rtNaN);\r\n        for (iAcol_0 = 0; iAcol_0 < 9; iAcol_0++) {\r\n          R_0[iAcol_0] = (rtNaN);\r\n        }\r\n      }\r\n\r\n      memset(&Ss[0], 0, 9U * sizeof(real_T));\r\n      Ss[0] = s[0];\r\n      Ss[4] = s[1];\r\n      Ss[8] = s[2];\r\n      for (iAcol_0 = 0; iAcol_0 < 9; iAcol_0++) {\r\n        Ss[iAcol_0] = sqrt(Ss[iAcol_0]);\r\n      }\r\n\r\n      iAcol_0 = 0;\r\n      for (iAcol = 0; iAcol < 3; iAcol++) {\r\n        coffset = 0;\r\n        for (aoffset = 0; aoffset < 3; aoffset++) {\r\n          R_tmp = coffset + iAcol;\r\n          R[R_tmp] = 0.0;\r\n          R[R_tmp] += Ss[iAcol_0] * R_0[aoffset];\r\n          R[R_tmp] += Ss[iAcol_0 + 1] * R_0[aoffset + 3];\r\n          R[R_tmp] += Ss[iAcol_0 + 2] * R_0[aoffset + 6];\r\n          coffset += 3;\r\n        }\r\n\r\n        iAcol_0 += 3;\r\n      }\r\n\r\n      errorCondition = true;\r\n      iAcol = 0;\r\n      exitg2 = false;\r\n      while ((!exitg2) && (iAcol < 3)) {\r\n        int32_T exitg1;\r\n        iAcol_0 = iAcol + 1;\r\n        do {\r\n          exitg1 = 0;\r\n          if (iAcol_0 + 1 < 4) {\r\n            if (!(R[3 * iAcol + iAcol_0] == 0.0)) {\r\n              errorCondition = false;\r\n              exitg1 = 1;\r\n            } else {\r\n              iAcol_0++;\r\n            }\r\n          } else {\r\n            iAcol++;\r\n            exitg1 = 2;\r\n          }\r\n        } while (exitg1 == 0);\r\n\r\n        if (exitg1 == 1) {\r\n          exitg2 = true;\r\n        }\r\n      }\r\n\r\n      if (!errorCondition) {\r\n        memcpy(&R_0[0], &R[0], 9U * sizeof(real_T));\r\n        qr_5a2P8Gh6(R_0, tempY_0, R);\r\n      }\r\n    }\r\n\r\n    iAcol_0 = 0;\r\n    for (iAcol = 0; iAcol < 3; iAcol++) {\r\n      CSE_DW.P[iAcol_0] = R[iAcol];\r\n      CSE_DW.P[iAcol_0 + 1] = R[iAcol + 3];\r\n      CSE_DW.P[iAcol_0 + 2] = R[iAcol + 6];\r\n      CSE_DW.x[iAcol] += K[iAcol] * s_0;\r\n      iAcol_0 += 3;\r\n    }\r\n  }\r\n\r\n  CSE_Y.soc = CSE_DW.x[1] / CSE_DW.x[2];\r\n  CSE_Y.capacity = CSE_DW.x[2];\r\n  CSE_S_x(CSE_DW.x, tempY);\r\n  for (iAcol_0 = 0; iAcol_0 < 9; iAcol_0++) {\r\n    s_0 = 0.0017320508075688774 * CSE_DW.P[iAcol_0];\r\n    X2state[iAcol_0] = s_0;\r\n    X2state[iAcol_0 + 9] = -s_0;\r\n  }\r\n\r\n  iAcol_0 = 0;\r\n  for (iAcol = 0; iAcol < 6; iAcol++) {\r\n    X2state[iAcol_0] += CSE_DW.x[0];\r\n    X2state[iAcol_0 + 1] += CSE_DW.x[1];\r\n    X2state[iAcol_0 + 2] += CSE_DW.x[2];\r\n    iAcol_0 += 3;\r\n  }\r\n\r\n  iAcol_0 = 0;\r\n  for (iAcol = 0; iAcol < 6; iAcol++) {\r\n    CSE_S_x(&X2state[iAcol_0], &Y2[iAcol_0]);\r\n    iAcol_0 += 3;\r\n  }\r\n\r\n  CSE_S_x(CSE_DW.x, tempY);\r\n  for (iAcol_0 = 0; iAcol_0 < 3; iAcol_0++) {\r\n    C[iAcol_0] = CSE_DW.x[iAcol_0];\r\n  }\r\n\r\n  UTMeanCovSqrt_C2vgLQ4W(Wmean, Wcov, -999999.0, tempY, Y2, C, X2state, CSE_DW.x,\r\n    Ss, R);\r\n  memset(&R[0], 0, 9U * sizeof(real_T));\r\n  R[0] = 1.0;\r\n  R[4] = 1.0;\r\n  R[8] = 1.0;\r\n  for (iAcol_0 = 0; iAcol_0 < 3; iAcol_0++) {\r\n    coffset = iAcol_0 * 3;\r\n    for (iAcol = 0; iAcol < 3; iAcol++) {\r\n      aoffset = iAcol * 3;\r\n      R_0[coffset + iAcol] = (Ss[aoffset + 1] * R[iAcol_0 + 3] + Ss[aoffset] *\r\n        R[iAcol_0]) + Ss[aoffset + 2] * R[iAcol_0 + 6];\r\n    }\r\n  }\r\n\r\n  iAcol_0 = 0;\r\n  iAcol = 0;\r\n  for (coffset = 0; coffset < 3; coffset++) {\r\n    Y2[iAcol_0] = R_0[iAcol];\r\n    Y2[iAcol_0 + 3] = CSE_P.Q_Value[coffset];\r\n    Y2[iAcol_0 + 1] = R_0[iAcol + 1];\r\n    Y2[iAcol_0 + 4] = CSE_P.Q_Value[coffset + 3];\r\n    Y2[iAcol_0 + 2] = R_0[iAcol + 2];\r\n    Y2[iAcol_0 + 5] = CSE_P.Q_Value[coffset + 6];\r\n    iAcol_0 += 6;\r\n    iAcol += 3;\r\n  }\r\n\r\n  qr_DvOBrgQi(Y2, X2state, R);\r\n  iAcol_0 = 0;\r\n  for (iAcol = 0; iAcol < 3; iAcol++) {\r\n    CSE_DW.P[iAcol_0] = R[iAcol];\r\n    CSE_DW.P[iAcol_0 + 1] = R[iAcol + 3];\r\n    CSE_DW.P[iAcol_0 + 2] = R[iAcol + 6];\r\n    iAcol_0 += 3;\r\n  }\r\n}\r\n\r\nvoid CSE_initialize(void)\r\n{\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n  memcpy(&CSE_DW.P[0], &CSE_P.DataStoreMemoryP_InitialValue[0], 9U * sizeof\r\n         (real_T));\r\n  CSE_DW.x[0] = CSE_P.DataStoreMemoryx_InitialValue[0];\r\n  CSE_DW.x[1] = CSE_P.DataStoreMemoryx_InitialValue[1];\r\n  CSE_DW.x[2] = CSE_P.DataStoreMemoryx_InitialValue[2];\r\n}\r\n\r\nvoid CSE_terminate(void)\r\n{\r\n}\r\n"},{"name":"CSE.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CSE_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_CSE_h_\r\n#define RTW_HEADER_CSE_h_\r\n#ifndef CSE_COMMON_INCLUDES_\r\n#define CSE_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"CSE_types.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetInf.h\"\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\ntypedef struct {\r\n  real_T P[9];\r\n  real_T x[3];\r\n} DW_CSE_T;\r\n\r\ntypedef struct {\r\n  real_T current;\r\n  real_T y;\r\n} ExtU_CSE_T;\r\n\r\ntypedef struct {\r\n  real_T soc;\r\n  real_T capacity;\r\n} ExtY_CSE_T;\r\n\r\nstruct P_CSE_T_ {\r\n  real_T Rp[13];\r\n  real_T Rs[13];\r\n  real_T Ts;\r\n  real_T ocv[13];\r\n  real_T soc[13];\r\n  real_T tau[13];\r\n  real_T R1_Value;\r\n  real_T MeasurementFcn1Inputs_Value;\r\n  real_T Q_Value[9];\r\n  real_T StateTransitionFcnInputs_Value;\r\n  real_T DataStoreMemoryP_InitialValue[9];\r\n  real_T DataStoreMemoryx_InitialValue[3];\r\n  boolean_T yBlockOrdering_Y0;\r\n  boolean_T BlockOrdering_Value;\r\n  boolean_T Enable1_Value;\r\n};\r\n\r\nstruct tag_RTM_CSE_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\nextern P_CSE_T CSE_P;\r\nextern DW_CSE_T CSE_DW;\r\nextern ExtU_CSE_T CSE_U;\r\nextern ExtY_CSE_T CSE_Y;\r\nextern void CSE_initialize(void);\r\nextern void CSE_step(void);\r\nextern void CSE_terminate(void);\r\nextern RT_MODEL_CSE_T *const CSE_M;\r\n\r\n#endif\r\n\r\n"},{"name":"CSE_private.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CSE_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_CSE_private_h_\r\n#define RTW_HEADER_CSE_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"CSE.h\"\r\n\r\nextern void CSE_S_x(const real_T rtu_x[3], real_T rty_x_next[3]);\r\nextern void CSE_M_x(const real_T rtu_x[3], real_T *rty_y);\r\n\r\n#endif\r\n\r\n"},{"name":"CSE_types.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CSE_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_CSE_types_h_\r\n#define RTW_HEADER_CSE_types_h_\r\n\r\ntypedef struct P_CSE_T_ P_CSE_T;\r\ntypedef struct tag_RTM_CSE_T RT_MODEL_CSE_T;\r\n\r\n#endif\r\n\r\n"},{"name":"CSE_data.c","type":"source","group":"data","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\CSE_ert_rtw","tag":"","groupDisplay":"Data files","code":"#include \"CSE.h\"\r\n\r\nP_CSE_T CSE_P = {\r\n\r\n  { 0.0013284973182, 0.00132849731829051, 0.00133071540686515,\r\n    0.00133106364620441, 0.00133282418704394, 0.00133927918011939,\r\n    0.00135371077616641, 0.00137940112592065, 0.00141963238011775,\r\n    0.00147768668949337, 0.00155684620478314, 0.00166039307672272,\r\n    0.00179160945604776 },\r\n\r\n\r\n  { 0.0044622496006, 0.00446224960061823, 0.00395928973129493,\r\n    0.00365723545490869, 0.00346135878439388, 0.00332839611795259,\r\n    0.00323577769308545, 0.00317057626115591, 0.00312485453442757,\r\n    0.00309346940400882, 0.00307294184679812, 0.00306083426030356,\r\n    0.00305538791678206 },\r\n\r\n  0.2,\r\n\r\n\r\n  { 0.0, 2.99808472821531, 3.29015678205606, 3.51449858492796, 3.66802196422992,\r\n    3.76050972589663, 3.81021773542304, 3.83947699888896, 3.87029574398353,\r\n    3.91996150102984, 3.99664318400941, 4.09499317158672, 4.19174938813381 },\r\n\r\n\r\n  { 0.0, 0.01, 0.0909090909090909, 0.181818181818182, 0.272727272727273,\r\n    0.363636363636364, 0.454545454545455, 0.545454545454545, 0.636363636363636,\r\n    0.727272727272727, 0.818181818181818, 0.909090909090909, 1.0 },\r\n\r\n\r\n  { 950.87194683, 950.871946837005, 952.459545918238, 952.715608141667,\r\n    956.801088701637, 1116.9800008749899, 2163.29230815358, 2204.3466729378397,\r\n    1183.99583949683, 1060.79424954235, 1114.3206284707098, 1188.42633649718,\r\n    1282.34445639369 },\r\n\r\n  0.031622776601683791,\r\n\r\n  0.0,\r\n\r\n\r\n  { 0.0, 0.0, 0.15414279094398156, 0.0, 0.10899541274750969, 0.0, 0.0, 0.0, 0.0\r\n  },\r\n\r\n  0.0,\r\n\r\n\r\n  { 0.0, 0.0, 0.4874423042781576, 0.0, 0.34467375879228174, 0.0, 0.0, 0.0, 0.0 },\r\n\r\n\r\n  { 0.0, 11880.0, 23760.0 },\r\n\r\n  false,\r\n\r\n  true,\r\n\r\n  true\r\n};\r\n"},{"name":"UTMeanCovSqrt_C2vgLQ4W.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"UTMeanCovSqrt_C2vgLQ4W.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <math.h>\r\n#include \"qr_DvOBrgQi.h\"\r\n#include \"rotate_LZ7ctbe0.h\"\r\n#include \"svd_u3DvUgOe.h\"\r\n#include <string.h>\r\n#include \"qr_5a2P8Gh6.h\"\r\n\r\nvoid UTMeanCovSqrt_C2vgLQ4W(const real_T meanWeights[2], const real_T\r\n  covWeights[2], real_T OOM, real_T Y1[3], real_T Y2[18], const real_T X1[3],\r\n  real_T X2[18], real_T Ymean[3], real_T Sy[9], real_T Pxy[9])\r\n{\r\n  real_T a__1[18];\r\n  real_T temp_0[18];\r\n  real_T Ss[9];\r\n  real_T Sy_0[9];\r\n  real_T Y1_0[9];\r\n  real_T c[3];\r\n  real_T s[3];\r\n  real_T x[3];\r\n  real_T absxk;\r\n  real_T b_t;\r\n  real_T covWeights_0;\r\n  real_T covWeights_1;\r\n  real_T scale;\r\n  real_T signOOM;\r\n  real_T temp;\r\n  int32_T Sy_tmp;\r\n  int32_T i;\r\n  int32_T iAcol;\r\n  int32_T i_0;\r\n  int32_T i_1;\r\n  int32_T kk;\r\n  Ymean[0] = Y1[0] * meanWeights[0];\r\n  Ymean[1] = meanWeights[0] * Y1[1];\r\n  Ymean[2] = meanWeights[0] * Y1[2];\r\n  iAcol = 0;\r\n  for (kk = 0; kk < 6; kk++) {\r\n    Ymean[0] += Y2[iAcol] * meanWeights[1];\r\n    Ymean[1] += Y2[iAcol + 1] * meanWeights[1];\r\n    Ymean[2] += Y2[iAcol + 2] * meanWeights[1];\r\n    iAcol += 3;\r\n  }\r\n\r\n  signOOM = Ymean[0] * OOM;\r\n  scale = Y1[0] - signOOM;\r\n  Ymean[0] = signOOM;\r\n  Y1[0] = scale;\r\n  signOOM = Ymean[1] * OOM;\r\n  absxk = Y1[1] - signOOM;\r\n  Ymean[1] = signOOM;\r\n  Y1[1] = absxk;\r\n  signOOM = Ymean[2] * OOM;\r\n  b_t = Y1[2] - signOOM;\r\n  Ymean[2] = signOOM;\r\n  Y1[2] = b_t;\r\n  iAcol = 0;\r\n  for (kk = 0; kk < 6; kk++) {\r\n    Y2[iAcol] -= Ymean[0];\r\n    Y2[iAcol + 1] -= Ymean[1];\r\n    Y2[iAcol + 2] -= signOOM;\r\n    iAcol += 3;\r\n  }\r\n\r\n  if (rtIsNaN(OOM)) {\r\n    signOOM = OOM;\r\n  } else if (OOM < 0.0) {\r\n    signOOM = -1.0;\r\n  } else {\r\n    signOOM = (OOM > 0.0);\r\n  }\r\n\r\n  covWeights_0 = signOOM * covWeights[0];\r\n  covWeights_1 = signOOM * covWeights[1];\r\n  OOM *= signOOM;\r\n  signOOM = sqrt(OOM);\r\n  temp = sqrt(covWeights_1);\r\n  kk = 0;\r\n  for (iAcol = 0; iAcol < 3; iAcol++) {\r\n    i_1 = 0;\r\n    for (i = 0; i < 6; i++) {\r\n      temp_0[i + kk] = Y2[i_1 + iAcol] * temp;\r\n      i_1 += 3;\r\n    }\r\n\r\n    kk += 6;\r\n  }\r\n\r\n  qr_DvOBrgQi(temp_0, a__1, Sy);\r\n  if (!rtIsNaN(covWeights_0)) {\r\n    if (covWeights_0 < 0.0) {\r\n      covWeights_0 = -1.0;\r\n    } else {\r\n      covWeights_0 = (covWeights_0 > 0.0);\r\n    }\r\n  }\r\n\r\n  if (covWeights_0 == 1.0) {\r\n    for (iAcol = 0; iAcol < 2; iAcol++) {\r\n      Sy[iAcol + 1] = 0.0;\r\n    }\r\n\r\n    Sy[5] = 0.0;\r\n    c[2] = 0.0;\r\n    s[2] = 0.0;\r\n    rotate_LZ7ctbe0(Sy[0], scale, &c[0], &s[0], &Sy[0]);\r\n    temp = c[0] * absxk - s[0] * Sy[3];\r\n    Sy[3] = c[0] * Sy[3] + s[0] * absxk;\r\n    rotate_LZ7ctbe0(Sy[4], temp, &c[1], &s[1], &Sy[4]);\r\n    temp = b_t;\r\n    for (iAcol = 0; iAcol < 2; iAcol++) {\r\n      scale = s[iAcol] * temp;\r\n      absxk = Sy[iAcol + 6];\r\n      temp = c[iAcol] * temp - absxk * s[iAcol];\r\n      Sy[iAcol + 6] = absxk * c[iAcol] + scale;\r\n    }\r\n\r\n    rotate_LZ7ctbe0(Sy[8], temp, &c[2], &s[2], &Sy[8]);\r\n    kk = 0;\r\n    for (iAcol = 0; iAcol < 3; iAcol++) {\r\n      Sy_0[kk] = Sy[iAcol];\r\n      Sy_0[kk + 1] = Sy[iAcol + 3];\r\n      Sy_0[kk + 2] = Sy[iAcol + 6];\r\n      kk += 3;\r\n    }\r\n\r\n    for (kk = 0; kk < 9; kk++) {\r\n      Sy[kk] = signOOM * Sy_0[kk];\r\n    }\r\n  } else {\r\n    boolean_T errorCondition;\r\n    boolean_T guard1 = false;\r\n    for (iAcol = 0; iAcol < 2; iAcol++) {\r\n      Sy[iAcol + 1] = 0.0;\r\n    }\r\n\r\n    Sy[5] = 0.0;\r\n    errorCondition = (Sy[0] == 0.0);\r\n    if (!errorCondition) {\r\n      errorCondition = (Sy[4] == 0.0);\r\n    }\r\n\r\n    if (!errorCondition) {\r\n      errorCondition = (Sy[8] == 0.0);\r\n    }\r\n\r\n    guard1 = false;\r\n    if (errorCondition) {\r\n      guard1 = true;\r\n    } else {\r\n      x[2] = b_t;\r\n      x[0] = scale / Sy[0];\r\n      x[1] = (absxk - x[0] * Sy[3]) / Sy[4];\r\n      temp = b_t;\r\n      for (kk = 0; kk < 2; kk++) {\r\n        temp -= Sy[kk + 6] * x[kk];\r\n      }\r\n\r\n      x[2] = temp / Sy[8];\r\n      scale = 3.3121686421112381E-170;\r\n      absxk = fabs(x[0]);\r\n      if (absxk > 3.3121686421112381E-170) {\r\n        temp = 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        b_t = absxk / 3.3121686421112381E-170;\r\n        temp = b_t * b_t;\r\n      }\r\n\r\n      absxk = fabs(x[1]);\r\n      if (absxk > scale) {\r\n        b_t = scale / absxk;\r\n        temp = temp * b_t * b_t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        b_t = absxk / scale;\r\n        temp += b_t * b_t;\r\n      }\r\n\r\n      absxk = fabs(x[2]);\r\n      if (absxk > scale) {\r\n        b_t = scale / absxk;\r\n        temp = temp * b_t * b_t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        b_t = absxk / scale;\r\n        temp += b_t * b_t;\r\n      }\r\n\r\n      temp = scale * sqrt(temp);\r\n      if (temp >= 1.0) {\r\n        guard1 = true;\r\n      } else {\r\n        rotate_LZ7ctbe0(sqrt(1.0 - temp * temp), x[2], &c[2], &s[2], &temp);\r\n        x[2] = 0.0;\r\n        rotate_LZ7ctbe0(temp, x[1], &c[1], &s[1], &temp);\r\n        x[1] = 0.0;\r\n        rotate_LZ7ctbe0(temp, x[0], &c[0], &s[0], &temp);\r\n        x[0] = 0.0;\r\n        for (iAcol = 0; iAcol + 1 > 0; iAcol--) {\r\n          temp = s[iAcol] * Sy[iAcol];\r\n          Sy[iAcol] = c[iAcol] * Sy[iAcol] - s[iAcol] * x[0];\r\n          x[0] = c[iAcol] * x[0] + temp;\r\n        }\r\n\r\n        for (iAcol = 1; iAcol + 1 > 0; iAcol--) {\r\n          absxk = Sy[iAcol + 3];\r\n          Sy[iAcol + 3] = absxk * c[iAcol] - s[iAcol] * x[1];\r\n          x[1] = c[iAcol] * x[1] + absxk * s[iAcol];\r\n        }\r\n\r\n        for (iAcol = 2; iAcol + 1 > 0; iAcol--) {\r\n          absxk = Sy[iAcol + 6];\r\n          Sy[iAcol + 6] = absxk * c[iAcol] - s[iAcol] * x[2];\r\n          x[2] = c[iAcol] * x[2] + absxk * s[iAcol];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (guard1) {\r\n      boolean_T exitg2;\r\n      kk = 0;\r\n      for (iAcol = 0; iAcol < 3; iAcol++) {\r\n        i_1 = 0;\r\n        for (i = 0; i < 3; i++) {\r\n          Sy_tmp = i_1 + iAcol;\r\n          Sy_0[Sy_tmp] = 0.0;\r\n          Sy_0[Sy_tmp] += Sy[kk] * Sy[i_1];\r\n          Sy_0[Sy_tmp] += Sy[kk + 1] * Sy[i_1 + 1];\r\n          Sy_0[Sy_tmp] += Sy[kk + 2] * Sy[i_1 + 2];\r\n          Y1_0[i + kk] = Y1[i] * Y1[iAcol];\r\n          i_1 += 3;\r\n        }\r\n\r\n        kk += 3;\r\n      }\r\n\r\n      errorCondition = true;\r\n      for (iAcol = 0; iAcol < 9; iAcol++) {\r\n        temp = Sy_0[iAcol] - Y1_0[iAcol];\r\n        if (errorCondition && (rtIsInf(temp) || rtIsNaN(temp))) {\r\n          errorCondition = false;\r\n        }\r\n\r\n        Ss[iAcol] = temp;\r\n      }\r\n\r\n      if (errorCondition) {\r\n        svd_u3DvUgOe(Ss, Y1_0, s, Sy_0);\r\n      } else {\r\n        s[0] = (rtNaN);\r\n        s[1] = (rtNaN);\r\n        s[2] = (rtNaN);\r\n        for (kk = 0; kk < 9; kk++) {\r\n          Sy_0[kk] = (rtNaN);\r\n        }\r\n      }\r\n\r\n      memset(&Ss[0], 0, 9U * sizeof(real_T));\r\n      Ss[0] = s[0];\r\n      Ss[4] = s[1];\r\n      Ss[8] = s[2];\r\n      for (kk = 0; kk < 9; kk++) {\r\n        Ss[kk] = sqrt(Ss[kk]);\r\n      }\r\n\r\n      kk = 0;\r\n      for (iAcol = 0; iAcol < 3; iAcol++) {\r\n        i_1 = 0;\r\n        for (i = 0; i < 3; i++) {\r\n          Sy_tmp = i_1 + iAcol;\r\n          Sy[Sy_tmp] = 0.0;\r\n          Sy[Sy_tmp] += Ss[kk] * Sy_0[i];\r\n          Sy[Sy_tmp] += Ss[kk + 1] * Sy_0[i + 3];\r\n          Sy[Sy_tmp] += Ss[kk + 2] * Sy_0[i + 6];\r\n          i_1 += 3;\r\n        }\r\n\r\n        kk += 3;\r\n      }\r\n\r\n      errorCondition = true;\r\n      kk = 0;\r\n      exitg2 = false;\r\n      while ((!exitg2) && (kk < 3)) {\r\n        int32_T exitg1;\r\n        iAcol = kk + 1;\r\n        do {\r\n          exitg1 = 0;\r\n          if (iAcol + 1 < 4) {\r\n            if (!(Sy[3 * kk + iAcol] == 0.0)) {\r\n              errorCondition = false;\r\n              exitg1 = 1;\r\n            } else {\r\n              iAcol++;\r\n            }\r\n          } else {\r\n            kk++;\r\n            exitg1 = 2;\r\n          }\r\n        } while (exitg1 == 0);\r\n\r\n        if (exitg1 == 1) {\r\n          exitg2 = true;\r\n        }\r\n      }\r\n\r\n      if (!errorCondition) {\r\n        memcpy(&Sy_0[0], &Sy[0], 9U * sizeof(real_T));\r\n        qr_5a2P8Gh6(Sy_0, Y1_0, Sy);\r\n      }\r\n    }\r\n\r\n    kk = 0;\r\n    for (iAcol = 0; iAcol < 3; iAcol++) {\r\n      Sy_0[kk] = Sy[iAcol];\r\n      Sy_0[kk + 1] = Sy[iAcol + 3];\r\n      Sy_0[kk + 2] = Sy[iAcol + 6];\r\n      kk += 3;\r\n    }\r\n\r\n    for (kk = 0; kk < 9; kk++) {\r\n      Sy[kk] = signOOM * Sy_0[kk];\r\n    }\r\n  }\r\n\r\n  iAcol = 0;\r\n  for (kk = 0; kk < 6; kk++) {\r\n    X2[iAcol] -= X1[0];\r\n    X2[iAcol + 1] -= X1[1];\r\n    X2[iAcol + 2] -= X1[2];\r\n    iAcol += 3;\r\n  }\r\n\r\n  signOOM = covWeights_1 * OOM;\r\n  for (kk = 0; kk < 3; kk++) {\r\n    iAcol = 0;\r\n    for (i_1 = 0; i_1 < 3; i_1++) {\r\n      Sy_tmp = iAcol + kk;\r\n      Ss[Sy_tmp] = 0.0;\r\n      i = 0;\r\n      for (i_0 = 0; i_0 < 6; i_0++) {\r\n        Ss[Sy_tmp] += X2[i + kk] * Y2[i + i_1];\r\n        i += 3;\r\n      }\r\n\r\n      iAcol += 3;\r\n    }\r\n  }\r\n\r\n  for (kk = 0; kk < 9; kk++) {\r\n    Pxy[kk] = Ss[kk] * signOOM;\r\n  }\r\n}\r\n"},{"name":"UTMeanCovSqrt_C2vgLQ4W.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_UTMeanCovSqrt_C2vgLQ4W_h_\r\n#define RTW_HEADER_UTMeanCovSqrt_C2vgLQ4W_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void UTMeanCovSqrt_C2vgLQ4W(const real_T meanWeights[2], const real_T\r\n  covWeights[2], real_T OOM, real_T Y1[3], real_T Y2[18], const real_T X1[3],\r\n  real_T X2[18], real_T Ymean[3], real_T Sy[9], real_T Pxy[9]);\r\n\r\n#endif\r\n\r\n"},{"name":"UTMeanCovSqrt_C6QfB9Td.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"UTMeanCovSqrt_C6QfB9Td.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <math.h>\r\n#include \"xnrm2_7bm34mDQ.h\"\r\n#include \"rt_hypotd_snf.h\"\r\n#include \"cholUpdateFactor_HBMX5a5h.h\"\r\n#include \"rotate_LZ7ctbe0.h\"\r\n\r\nvoid UTMeanCovSqrt_C6QfB9Td(const real_T meanWeights[2], const real_T\r\n  covWeights[2], real_T OOM, real_T Y1, real_T Y2[6], const real_T X1[3], real_T\r\n  X2[18], real_T *Ymean, real_T *Sy, real_T Pxy[3])\r\n{\r\n  real_T A[6];\r\n  real_T X2_0[3];\r\n  real_T covWeights_0;\r\n  real_T covWeights_1;\r\n  real_T signOOM;\r\n  real_T xnorm;\r\n  int32_T b_k;\r\n  int32_T i;\r\n  int32_T knt;\r\n  *Ymean = Y1 * meanWeights[0];\r\n  for (knt = 0; knt < 6; knt++) {\r\n    *Ymean += Y2[knt] * meanWeights[1];\r\n  }\r\n\r\n  *Ymean *= OOM;\r\n  Y1 -= *Ymean;\r\n  for (knt = 0; knt < 6; knt++) {\r\n    Y2[knt] -= *Ymean;\r\n  }\r\n\r\n  if (rtIsNaN(OOM)) {\r\n    signOOM = OOM;\r\n  } else if (OOM < 0.0) {\r\n    signOOM = -1.0;\r\n  } else {\r\n    signOOM = (OOM > 0.0);\r\n  }\r\n\r\n  covWeights_0 = signOOM * covWeights[0];\r\n  covWeights_1 = signOOM * covWeights[1];\r\n  OOM *= signOOM;\r\n  signOOM = sqrt(covWeights_1);\r\n  for (knt = 0; knt < 6; knt++) {\r\n    A[knt] = signOOM * Y2[knt];\r\n  }\r\n\r\n  signOOM = A[0];\r\n  xnorm = xnrm2_7bm34mDQ(5, A, 2);\r\n  if (xnorm != 0.0) {\r\n    xnorm = rt_hypotd_snf(A[0], xnorm);\r\n    if (A[0] >= 0.0) {\r\n      xnorm = -xnorm;\r\n    }\r\n\r\n    if (fabs(xnorm) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        for (b_k = 1; b_k < 6; b_k++) {\r\n          A[b_k] *= 9.9792015476736E+291;\r\n        }\r\n\r\n        xnorm *= 9.9792015476736E+291;\r\n        signOOM *= 9.9792015476736E+291;\r\n      } while ((fabs(xnorm) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      xnorm = rt_hypotd_snf(signOOM, xnrm2_7bm34mDQ(5, A, 2));\r\n      if (signOOM >= 0.0) {\r\n        xnorm = -xnorm;\r\n      }\r\n\r\n      for (b_k = 0; b_k < knt; b_k++) {\r\n        xnorm *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      signOOM = xnorm;\r\n    } else {\r\n      signOOM = xnorm;\r\n    }\r\n  }\r\n\r\n  if (!rtIsNaN(covWeights_0)) {\r\n    if (covWeights_0 < 0.0) {\r\n      covWeights_0 = -1.0;\r\n    } else {\r\n      covWeights_0 = (covWeights_0 > 0.0);\r\n    }\r\n  }\r\n\r\n  if (covWeights_0 == 1.0) {\r\n    rotate_LZ7ctbe0(signOOM, Y1, &signOOM, &xnorm, &covWeights_0);\r\n    *Sy = sqrt(OOM) * covWeights_0;\r\n  } else {\r\n    cholUpdateFactor_HBMX5a5h(&signOOM, Y1);\r\n    *Sy = sqrt(OOM) * signOOM;\r\n  }\r\n\r\n  b_k = 0;\r\n  for (knt = 0; knt < 6; knt++) {\r\n    X2[b_k] -= X1[0];\r\n    X2[b_k + 1] -= X1[1];\r\n    X2[b_k + 2] -= X1[2];\r\n    b_k += 3;\r\n  }\r\n\r\n  signOOM = covWeights_1 * OOM;\r\n  for (knt = 0; knt < 3; knt++) {\r\n    X2_0[knt] = 0.0;\r\n    b_k = 0;\r\n    for (i = 0; i < 6; i++) {\r\n      X2_0[knt] += X2[b_k + knt] * Y2[i];\r\n      b_k += 3;\r\n    }\r\n\r\n    Pxy[knt] = X2_0[knt] * signOOM;\r\n  }\r\n}\r\n"},{"name":"UTMeanCovSqrt_C6QfB9Td.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_UTMeanCovSqrt_C6QfB9Td_h_\r\n#define RTW_HEADER_UTMeanCovSqrt_C6QfB9Td_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void UTMeanCovSqrt_C6QfB9Td(const real_T meanWeights[2], const real_T\r\n  covWeights[2], real_T OOM, real_T Y1, real_T Y2[6], const real_T X1[3], real_T\r\n  X2[18], real_T *Ymean, real_T *Sy, real_T Pxy[3]);\r\n\r\n#endif\r\n\r\n"},{"name":"cholUpdateFactor_HBMX5a5h.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"cholUpdateFactor_HBMX5a5h.h\"\r\n#include <math.h>\r\n#include \"rotate_LZ7ctbe0.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n\r\nvoid cholUpdateFactor_HBMX5a5h(real_T *S, real_T U)\r\n{\r\n  real_T R;\r\n  real_T alpha;\r\n  real_T c;\r\n  real_T nrmx;\r\n  real_T s;\r\n  int8_T p;\r\n  R = *S;\r\n  p = 0;\r\n  if (*S == 0.0) {\r\n    p = 2;\r\n  } else {\r\n    s = U / *S;\r\n    nrmx = fabs(s);\r\n    if (nrmx >= 1.0) {\r\n      p = 1;\r\n    } else {\r\n      rotate_LZ7ctbe0(sqrt(1.0 - nrmx * nrmx), s, &R, &c, &alpha);\r\n      R = R * *S - c * 0.0;\r\n    }\r\n  }\r\n\r\n  *S = R;\r\n  if (p != 0) {\r\n    s = R * R - U * U;\r\n    if ((!rtIsInf(s)) && (!rtIsNaN(s))) {\r\n      nrmx = 1.0;\r\n      if (s != 0.0) {\r\n        s = fabs(s);\r\n      }\r\n    } else {\r\n      s = (rtNaN);\r\n      nrmx = (rtNaN);\r\n    }\r\n\r\n    *S = nrmx * sqrt(s);\r\n  }\r\n}\r\n"},{"name":"cholUpdateFactor_HBMX5a5h.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_cholUpdateFactor_HBMX5a5h_h_\r\n#define RTW_HEADER_cholUpdateFactor_HBMX5a5h_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void cholUpdateFactor_HBMX5a5h(real_T *S, real_T U);\r\n\r\n#endif\r\n\r\n"},{"name":"look1_binlxpw.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"look1_binlxpw.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nreal_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n                     uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T yL_0d0;\r\n  uint32_T iLeft;\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n    bpIdx = maxIndex >> 1U;\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while (iRght - iLeft > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = (iRght + iLeft) >> 1U;\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  yL_0d0 = table[iLeft];\r\n  return (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n"},{"name":"look1_binlxpw.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_look1_binlxpw_h_\r\n#define RTW_HEADER_look1_binlxpw_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T maxIndex);\r\n\r\n#endif\r\n\r\n"},{"name":"qr_5a2P8Gh6.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"qr_5a2P8Gh6.h\"\r\n#include <string.h>\r\n#include \"xnrm2_xDOlDEtw.h\"\r\n#include \"rt_hypotd_snf.h\"\r\n#include <math.h>\r\n#include \"xgemv_fRiR1I1O.h\"\r\n#include \"xgerc_tNNiazQU.h\"\r\n\r\nvoid qr_5a2P8Gh6(const real_T A[9], real_T Q[9], real_T R[9])\r\n{\r\n  real_T b_A[9];\r\n  real_T work[3];\r\n  real_T atmp;\r\n  real_T beta1;\r\n  real_T tau_idx_0;\r\n  real_T tau_idx_1;\r\n  int32_T b_coltop;\r\n  int32_T c_lastc;\r\n  int32_T coltop;\r\n  int32_T exitg1;\r\n  int32_T knt;\r\n  boolean_T exitg2;\r\n  memcpy(&b_A[0], &A[0], 9U * sizeof(real_T));\r\n  tau_idx_0 = 0.0;\r\n  work[0] = 0.0;\r\n  tau_idx_1 = 0.0;\r\n  work[1] = 0.0;\r\n  work[2] = 0.0;\r\n  atmp = b_A[0];\r\n  beta1 = xnrm2_xDOlDEtw(2, b_A, 2);\r\n  if (beta1 != 0.0) {\r\n    beta1 = rt_hypotd_snf(b_A[0], beta1);\r\n    if (b_A[0] >= 0.0) {\r\n      beta1 = -beta1;\r\n    }\r\n\r\n    if (fabs(beta1) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        for (b_coltop = 1; b_coltop < 3; b_coltop++) {\r\n          b_A[b_coltop] *= 9.9792015476736E+291;\r\n        }\r\n\r\n        beta1 *= 9.9792015476736E+291;\r\n        atmp *= 9.9792015476736E+291;\r\n      } while ((fabs(beta1) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      beta1 = rt_hypotd_snf(atmp, xnrm2_xDOlDEtw(2, b_A, 2));\r\n      if (atmp >= 0.0) {\r\n        beta1 = -beta1;\r\n      }\r\n\r\n      tau_idx_0 = (beta1 - atmp) / beta1;\r\n      atmp = 1.0 / (atmp - beta1);\r\n      for (b_coltop = 1; b_coltop < 3; b_coltop++) {\r\n        b_A[b_coltop] *= atmp;\r\n      }\r\n\r\n      for (c_lastc = 0; c_lastc < knt; c_lastc++) {\r\n        beta1 *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      atmp = beta1;\r\n    } else {\r\n      tau_idx_0 = (beta1 - b_A[0]) / beta1;\r\n      atmp = 1.0 / (b_A[0] - beta1);\r\n      for (c_lastc = 1; c_lastc < 3; c_lastc++) {\r\n        b_A[c_lastc] *= atmp;\r\n      }\r\n\r\n      atmp = beta1;\r\n    }\r\n  }\r\n\r\n  b_A[0] = 1.0;\r\n  if (tau_idx_0 != 0.0) {\r\n    knt = 3;\r\n    c_lastc = 2;\r\n    while ((knt > 0) && (b_A[c_lastc] == 0.0)) {\r\n      knt--;\r\n      c_lastc--;\r\n    }\r\n\r\n    c_lastc = 2;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (c_lastc > 0)) {\r\n      b_coltop = (c_lastc - 1) * 3 + 3;\r\n      coltop = b_coltop;\r\n      do {\r\n        exitg1 = 0;\r\n        if (coltop + 1 <= b_coltop + knt) {\r\n          if (b_A[coltop] != 0.0) {\r\n            exitg1 = 1;\r\n          } else {\r\n            coltop++;\r\n          }\r\n        } else {\r\n          c_lastc--;\r\n          exitg1 = 2;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      if (exitg1 == 1) {\r\n        exitg2 = true;\r\n      }\r\n    }\r\n  } else {\r\n    knt = 0;\r\n    c_lastc = 0;\r\n  }\r\n\r\n  if (knt > 0) {\r\n    xgemv_fRiR1I1O(knt, c_lastc, b_A, 4, b_A, 1, work);\r\n    xgerc_tNNiazQU(knt, c_lastc, -tau_idx_0, 1, work, b_A, 4);\r\n  }\r\n\r\n  b_A[0] = atmp;\r\n  atmp = b_A[4];\r\n  beta1 = xnrm2_xDOlDEtw(1, b_A, 6);\r\n  if (beta1 != 0.0) {\r\n    beta1 = rt_hypotd_snf(b_A[4], beta1);\r\n    if (b_A[4] >= 0.0) {\r\n      beta1 = -beta1;\r\n    }\r\n\r\n    if (fabs(beta1) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        for (b_coltop = 5; b_coltop < 6; b_coltop++) {\r\n          b_A[b_coltop] *= 9.9792015476736E+291;\r\n        }\r\n\r\n        beta1 *= 9.9792015476736E+291;\r\n        atmp *= 9.9792015476736E+291;\r\n      } while ((fabs(beta1) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      beta1 = rt_hypotd_snf(atmp, xnrm2_xDOlDEtw(1, b_A, 6));\r\n      if (atmp >= 0.0) {\r\n        beta1 = -beta1;\r\n      }\r\n\r\n      tau_idx_1 = (beta1 - atmp) / beta1;\r\n      atmp = 1.0 / (atmp - beta1);\r\n      for (b_coltop = 5; b_coltop < 6; b_coltop++) {\r\n        b_A[b_coltop] *= atmp;\r\n      }\r\n\r\n      for (c_lastc = 0; c_lastc < knt; c_lastc++) {\r\n        beta1 *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      atmp = beta1;\r\n    } else {\r\n      tau_idx_1 = (beta1 - b_A[4]) / beta1;\r\n      atmp = 1.0 / (b_A[4] - beta1);\r\n      for (c_lastc = 5; c_lastc < 6; c_lastc++) {\r\n        b_A[c_lastc] *= atmp;\r\n      }\r\n\r\n      atmp = beta1;\r\n    }\r\n  }\r\n\r\n  b_A[4] = 1.0;\r\n  if (tau_idx_1 != 0.0) {\r\n    knt = 2;\r\n    c_lastc = 5;\r\n    while ((knt > 0) && (b_A[c_lastc] == 0.0)) {\r\n      knt--;\r\n      c_lastc--;\r\n    }\r\n\r\n    c_lastc = 1;\r\n    coltop = 7;\r\n    do {\r\n      exitg1 = 0;\r\n      if (coltop + 1 <= knt + 7) {\r\n        if (b_A[coltop] != 0.0) {\r\n          exitg1 = 1;\r\n        } else {\r\n          coltop++;\r\n        }\r\n      } else {\r\n        c_lastc = 0;\r\n        exitg1 = 1;\r\n      }\r\n    } while (exitg1 == 0);\r\n  } else {\r\n    knt = 0;\r\n    c_lastc = 0;\r\n  }\r\n\r\n  if (knt > 0) {\r\n    xgemv_fRiR1I1O(knt, c_lastc, b_A, 8, b_A, 5, work);\r\n    xgerc_tNNiazQU(knt, c_lastc, -tau_idx_1, 5, work, b_A, 8);\r\n  }\r\n\r\n  b_A[4] = atmp;\r\n  R[0] = b_A[0];\r\n  for (c_lastc = 1; c_lastc + 1 < 4; c_lastc++) {\r\n    R[c_lastc] = 0.0;\r\n  }\r\n\r\n  work[0] = 0.0;\r\n  for (c_lastc = 0; c_lastc < 2; c_lastc++) {\r\n    R[c_lastc + 3] = b_A[c_lastc + 3];\r\n  }\r\n\r\n  while (c_lastc + 1 < 4) {\r\n    R[c_lastc + 3] = 0.0;\r\n    c_lastc++;\r\n  }\r\n\r\n  work[1] = 0.0;\r\n  for (c_lastc = 0; c_lastc < 3; c_lastc++) {\r\n    R[c_lastc + 6] = b_A[c_lastc + 6];\r\n  }\r\n\r\n  work[2] = 0.0;\r\n  b_A[8] = 1.0;\r\n  for (c_lastc = 0; c_lastc < 2; c_lastc++) {\r\n    b_A[7 - c_lastc] = 0.0;\r\n  }\r\n\r\n  b_A[4] = 1.0;\r\n  if (tau_idx_1 != 0.0) {\r\n    b_coltop = 7;\r\n    while ((c_lastc > 0) && (b_A[b_coltop - 2] == 0.0)) {\r\n      c_lastc--;\r\n      b_coltop--;\r\n    }\r\n\r\n    b_coltop = 1;\r\n    knt = 8;\r\n    do {\r\n      exitg1 = 0;\r\n      if (knt <= c_lastc + 7) {\r\n        if (b_A[knt - 1] != 0.0) {\r\n          exitg1 = 1;\r\n        } else {\r\n          knt++;\r\n        }\r\n      } else {\r\n        b_coltop = 0;\r\n        exitg1 = 1;\r\n      }\r\n    } while (exitg1 == 0);\r\n  } else {\r\n    c_lastc = 0;\r\n    b_coltop = 0;\r\n  }\r\n\r\n  if (c_lastc > 0) {\r\n    xgemv_fRiR1I1O(c_lastc, b_coltop, b_A, 8, b_A, 5, work);\r\n    xgerc_tNNiazQU(c_lastc, b_coltop, -tau_idx_1, 5, work, b_A, 8);\r\n  }\r\n\r\n  for (b_coltop = 5; b_coltop < 6; b_coltop++) {\r\n    b_A[b_coltop] *= -tau_idx_1;\r\n  }\r\n\r\n  b_A[4] = 1.0 - tau_idx_1;\r\n  b_A[3] = 0.0;\r\n  b_A[0] = 1.0;\r\n  if (tau_idx_0 != 0.0) {\r\n    c_lastc = 3;\r\n    b_coltop = 4;\r\n    while ((c_lastc > 0) && (b_A[b_coltop - 2] == 0.0)) {\r\n      c_lastc--;\r\n      b_coltop--;\r\n    }\r\n\r\n    b_coltop = 2;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (b_coltop > 0)) {\r\n      coltop = (b_coltop - 1) * 3 + 4;\r\n      knt = coltop;\r\n      do {\r\n        exitg1 = 0;\r\n        if (knt <= (coltop + c_lastc) - 1) {\r\n          if (b_A[knt - 1] != 0.0) {\r\n            exitg1 = 1;\r\n          } else {\r\n            knt++;\r\n          }\r\n        } else {\r\n          b_coltop--;\r\n          exitg1 = 2;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      if (exitg1 == 1) {\r\n        exitg2 = true;\r\n      }\r\n    }\r\n  } else {\r\n    c_lastc = 0;\r\n    b_coltop = 0;\r\n  }\r\n\r\n  if (c_lastc > 0) {\r\n    xgemv_fRiR1I1O(c_lastc, b_coltop, b_A, 4, b_A, 1, work);\r\n    xgerc_tNNiazQU(c_lastc, b_coltop, -tau_idx_0, 1, work, b_A, 4);\r\n  }\r\n\r\n  for (b_coltop = 1; b_coltop < 3; b_coltop++) {\r\n    b_A[b_coltop] *= -tau_idx_0;\r\n  }\r\n\r\n  b_A[0] = 1.0 - tau_idx_0;\r\n  c_lastc = 0;\r\n  for (b_coltop = 0; b_coltop < 3; b_coltop++) {\r\n    Q[c_lastc] = b_A[c_lastc];\r\n    Q[c_lastc + 1] = b_A[c_lastc + 1];\r\n    Q[c_lastc + 2] = b_A[c_lastc + 2];\r\n    c_lastc += 3;\r\n  }\r\n}\r\n"},{"name":"qr_5a2P8Gh6.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_qr_5a2P8Gh6_h_\r\n#define RTW_HEADER_qr_5a2P8Gh6_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void qr_5a2P8Gh6(const real_T A[9], real_T Q[9], real_T R[9]);\r\n\r\n#endif\r\n\r\n"},{"name":"qr_DvOBrgQi.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"qr_DvOBrgQi.h\"\r\n#include <string.h>\r\n#include \"xnrm2_nLdASVZH.h\"\r\n#include \"rt_hypotd_snf.h\"\r\n#include <math.h>\r\n#include \"xgemv_NQlWbt2i.h\"\r\n#include \"xgerc_R09LiDgJ.h\"\r\n\r\nvoid qr_DvOBrgQi(const real_T A[18], real_T Q[18], real_T R[9])\r\n{\r\n  real_T b_A[18];\r\n  real_T work[3];\r\n  real_T atmp;\r\n  real_T beta1;\r\n  real_T tau_idx_0;\r\n  real_T tau_idx_1;\r\n  real_T tau_idx_2;\r\n  int32_T b_coltop;\r\n  int32_T c_lastc;\r\n  int32_T coltop;\r\n  int32_T exitg1;\r\n  int32_T knt;\r\n  boolean_T exitg2;\r\n  memcpy(&b_A[0], &A[0], 18U * sizeof(real_T));\r\n  work[0] = 0.0;\r\n  work[1] = 0.0;\r\n  work[2] = 0.0;\r\n  atmp = b_A[0];\r\n  tau_idx_0 = 0.0;\r\n  beta1 = xnrm2_nLdASVZH(5, b_A, 2);\r\n  if (beta1 != 0.0) {\r\n    beta1 = rt_hypotd_snf(b_A[0], beta1);\r\n    if (b_A[0] >= 0.0) {\r\n      beta1 = -beta1;\r\n    }\r\n\r\n    if (fabs(beta1) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        for (b_coltop = 1; b_coltop < 6; b_coltop++) {\r\n          b_A[b_coltop] *= 9.9792015476736E+291;\r\n        }\r\n\r\n        beta1 *= 9.9792015476736E+291;\r\n        atmp *= 9.9792015476736E+291;\r\n      } while ((fabs(beta1) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      beta1 = rt_hypotd_snf(atmp, xnrm2_nLdASVZH(5, b_A, 2));\r\n      if (atmp >= 0.0) {\r\n        beta1 = -beta1;\r\n      }\r\n\r\n      tau_idx_0 = (beta1 - atmp) / beta1;\r\n      atmp = 1.0 / (atmp - beta1);\r\n      for (b_coltop = 1; b_coltop < 6; b_coltop++) {\r\n        b_A[b_coltop] *= atmp;\r\n      }\r\n\r\n      for (c_lastc = 0; c_lastc < knt; c_lastc++) {\r\n        beta1 *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      atmp = beta1;\r\n    } else {\r\n      tau_idx_0 = (beta1 - b_A[0]) / beta1;\r\n      atmp = 1.0 / (b_A[0] - beta1);\r\n      for (c_lastc = 1; c_lastc < 6; c_lastc++) {\r\n        b_A[c_lastc] *= atmp;\r\n      }\r\n\r\n      atmp = beta1;\r\n    }\r\n  }\r\n\r\n  b_A[0] = 1.0;\r\n  if (tau_idx_0 != 0.0) {\r\n    knt = 6;\r\n    c_lastc = 5;\r\n    while ((knt > 0) && (b_A[c_lastc] == 0.0)) {\r\n      knt--;\r\n      c_lastc--;\r\n    }\r\n\r\n    c_lastc = 2;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (c_lastc > 0)) {\r\n      b_coltop = (c_lastc - 1) * 6 + 6;\r\n      coltop = b_coltop;\r\n      do {\r\n        exitg1 = 0;\r\n        if (coltop + 1 <= b_coltop + knt) {\r\n          if (b_A[coltop] != 0.0) {\r\n            exitg1 = 1;\r\n          } else {\r\n            coltop++;\r\n          }\r\n        } else {\r\n          c_lastc--;\r\n          exitg1 = 2;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      if (exitg1 == 1) {\r\n        exitg2 = true;\r\n      }\r\n    }\r\n  } else {\r\n    knt = 0;\r\n    c_lastc = 0;\r\n  }\r\n\r\n  if (knt > 0) {\r\n    xgemv_NQlWbt2i(knt, c_lastc, b_A, 7, b_A, 1, work);\r\n    xgerc_R09LiDgJ(knt, c_lastc, -tau_idx_0, 1, work, b_A, 7);\r\n  }\r\n\r\n  b_A[0] = atmp;\r\n  atmp = b_A[7];\r\n  tau_idx_1 = 0.0;\r\n  beta1 = xnrm2_nLdASVZH(4, b_A, 9);\r\n  if (beta1 != 0.0) {\r\n    beta1 = rt_hypotd_snf(b_A[7], beta1);\r\n    if (b_A[7] >= 0.0) {\r\n      beta1 = -beta1;\r\n    }\r\n\r\n    if (fabs(beta1) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        for (b_coltop = 8; b_coltop < 12; b_coltop++) {\r\n          b_A[b_coltop] *= 9.9792015476736E+291;\r\n        }\r\n\r\n        beta1 *= 9.9792015476736E+291;\r\n        atmp *= 9.9792015476736E+291;\r\n      } while ((fabs(beta1) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      beta1 = rt_hypotd_snf(atmp, xnrm2_nLdASVZH(4, b_A, 9));\r\n      if (atmp >= 0.0) {\r\n        beta1 = -beta1;\r\n      }\r\n\r\n      tau_idx_1 = (beta1 - atmp) / beta1;\r\n      atmp = 1.0 / (atmp - beta1);\r\n      for (b_coltop = 8; b_coltop < 12; b_coltop++) {\r\n        b_A[b_coltop] *= atmp;\r\n      }\r\n\r\n      for (c_lastc = 0; c_lastc < knt; c_lastc++) {\r\n        beta1 *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      atmp = beta1;\r\n    } else {\r\n      tau_idx_1 = (beta1 - b_A[7]) / beta1;\r\n      atmp = 1.0 / (b_A[7] - beta1);\r\n      for (c_lastc = 8; c_lastc < 12; c_lastc++) {\r\n        b_A[c_lastc] *= atmp;\r\n      }\r\n\r\n      atmp = beta1;\r\n    }\r\n  }\r\n\r\n  b_A[7] = 1.0;\r\n  if (tau_idx_1 != 0.0) {\r\n    knt = 5;\r\n    c_lastc = 11;\r\n    while ((knt > 0) && (b_A[c_lastc] == 0.0)) {\r\n      knt--;\r\n      c_lastc--;\r\n    }\r\n\r\n    c_lastc = 1;\r\n    coltop = 13;\r\n    do {\r\n      exitg1 = 0;\r\n      if (coltop + 1 <= knt + 13) {\r\n        if (b_A[coltop] != 0.0) {\r\n          exitg1 = 1;\r\n        } else {\r\n          coltop++;\r\n        }\r\n      } else {\r\n        c_lastc = 0;\r\n        exitg1 = 1;\r\n      }\r\n    } while (exitg1 == 0);\r\n  } else {\r\n    knt = 0;\r\n    c_lastc = 0;\r\n  }\r\n\r\n  if (knt > 0) {\r\n    xgemv_NQlWbt2i(knt, c_lastc, b_A, 14, b_A, 8, work);\r\n    xgerc_R09LiDgJ(knt, c_lastc, -tau_idx_1, 8, work, b_A, 14);\r\n  }\r\n\r\n  b_A[7] = atmp;\r\n  atmp = b_A[14];\r\n  tau_idx_2 = 0.0;\r\n  beta1 = xnrm2_nLdASVZH(3, b_A, 16);\r\n  if (beta1 != 0.0) {\r\n    beta1 = rt_hypotd_snf(b_A[14], beta1);\r\n    if (b_A[14] >= 0.0) {\r\n      beta1 = -beta1;\r\n    }\r\n\r\n    if (fabs(beta1) < 1.0020841800044864E-292) {\r\n      knt = 0;\r\n      do {\r\n        knt++;\r\n        for (b_coltop = 15; b_coltop < 18; b_coltop++) {\r\n          b_A[b_coltop] *= 9.9792015476736E+291;\r\n        }\r\n\r\n        beta1 *= 9.9792015476736E+291;\r\n        atmp *= 9.9792015476736E+291;\r\n      } while ((fabs(beta1) < 1.0020841800044864E-292) && (knt < 20));\r\n\r\n      beta1 = rt_hypotd_snf(atmp, xnrm2_nLdASVZH(3, b_A, 16));\r\n      if (atmp >= 0.0) {\r\n        beta1 = -beta1;\r\n      }\r\n\r\n      tau_idx_2 = (beta1 - atmp) / beta1;\r\n      atmp = 1.0 / (atmp - beta1);\r\n      for (b_coltop = 15; b_coltop < 18; b_coltop++) {\r\n        b_A[b_coltop] *= atmp;\r\n      }\r\n\r\n      for (c_lastc = 0; c_lastc < knt; c_lastc++) {\r\n        beta1 *= 1.0020841800044864E-292;\r\n      }\r\n\r\n      atmp = beta1;\r\n    } else {\r\n      tau_idx_2 = (beta1 - b_A[14]) / beta1;\r\n      atmp = 1.0 / (b_A[14] - beta1);\r\n      for (c_lastc = 15; c_lastc < 18; c_lastc++) {\r\n        b_A[c_lastc] *= atmp;\r\n      }\r\n\r\n      atmp = beta1;\r\n    }\r\n  }\r\n\r\n  b_A[14] = atmp;\r\n  R[0] = b_A[0];\r\n  for (c_lastc = 1; c_lastc + 1 < 4; c_lastc++) {\r\n    R[c_lastc] = 0.0;\r\n  }\r\n\r\n  work[0] = 0.0;\r\n  for (c_lastc = 0; c_lastc < 2; c_lastc++) {\r\n    R[c_lastc + 3] = b_A[c_lastc + 6];\r\n  }\r\n\r\n  while (c_lastc + 1 < 4) {\r\n    R[c_lastc + 3] = 0.0;\r\n    c_lastc++;\r\n  }\r\n\r\n  work[1] = 0.0;\r\n  for (c_lastc = 0; c_lastc < 3; c_lastc++) {\r\n    R[c_lastc + 6] = b_A[c_lastc + 12];\r\n  }\r\n\r\n  work[2] = 0.0;\r\n  for (b_coltop = 15; b_coltop < 18; b_coltop++) {\r\n    b_A[b_coltop] *= -tau_idx_2;\r\n  }\r\n\r\n  b_A[14] = 1.0 - tau_idx_2;\r\n  for (c_lastc = 0; c_lastc < 2; c_lastc++) {\r\n    b_A[13 - c_lastc] = 0.0;\r\n  }\r\n\r\n  b_A[7] = 1.0;\r\n  if (tau_idx_1 != 0.0) {\r\n    c_lastc = 5;\r\n    b_coltop = 13;\r\n    while ((c_lastc > 0) && (b_A[b_coltop - 2] == 0.0)) {\r\n      c_lastc--;\r\n      b_coltop--;\r\n    }\r\n\r\n    b_coltop = 1;\r\n    knt = 14;\r\n    do {\r\n      exitg1 = 0;\r\n      if (knt <= c_lastc + 13) {\r\n        if (b_A[knt - 1] != 0.0) {\r\n          exitg1 = 1;\r\n        } else {\r\n          knt++;\r\n        }\r\n      } else {\r\n        b_coltop = 0;\r\n        exitg1 = 1;\r\n      }\r\n    } while (exitg1 == 0);\r\n  } else {\r\n    c_lastc = 0;\r\n    b_coltop = 0;\r\n  }\r\n\r\n  if (c_lastc > 0) {\r\n    xgemv_NQlWbt2i(c_lastc, b_coltop, b_A, 14, b_A, 8, work);\r\n    xgerc_R09LiDgJ(c_lastc, b_coltop, -tau_idx_1, 8, work, b_A, 14);\r\n  }\r\n\r\n  for (b_coltop = 8; b_coltop < 12; b_coltop++) {\r\n    b_A[b_coltop] *= -tau_idx_1;\r\n  }\r\n\r\n  b_A[7] = 1.0 - tau_idx_1;\r\n  b_A[6] = 0.0;\r\n  b_A[0] = 1.0;\r\n  if (tau_idx_0 != 0.0) {\r\n    c_lastc = 6;\r\n    b_coltop = 7;\r\n    while ((c_lastc > 0) && (b_A[b_coltop - 2] == 0.0)) {\r\n      c_lastc--;\r\n      b_coltop--;\r\n    }\r\n\r\n    b_coltop = 2;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (b_coltop > 0)) {\r\n      coltop = (b_coltop - 1) * 6 + 7;\r\n      knt = coltop;\r\n      do {\r\n        exitg1 = 0;\r\n        if (knt <= (coltop + c_lastc) - 1) {\r\n          if (b_A[knt - 1] != 0.0) {\r\n            exitg1 = 1;\r\n          } else {\r\n            knt++;\r\n          }\r\n        } else {\r\n          b_coltop--;\r\n          exitg1 = 2;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      if (exitg1 == 1) {\r\n        exitg2 = true;\r\n      }\r\n    }\r\n  } else {\r\n    c_lastc = 0;\r\n    b_coltop = 0;\r\n  }\r\n\r\n  if (c_lastc > 0) {\r\n    xgemv_NQlWbt2i(c_lastc, b_coltop, b_A, 7, b_A, 1, work);\r\n    xgerc_R09LiDgJ(c_lastc, b_coltop, -tau_idx_0, 1, work, b_A, 7);\r\n  }\r\n\r\n  for (b_coltop = 1; b_coltop < 6; b_coltop++) {\r\n    b_A[b_coltop] *= -tau_idx_0;\r\n  }\r\n\r\n  b_A[0] = 1.0 - tau_idx_0;\r\n  b_coltop = 0;\r\n  for (coltop = 0; coltop < 3; coltop++) {\r\n    for (c_lastc = 0; c_lastc < 6; c_lastc++) {\r\n      knt = c_lastc + b_coltop;\r\n      Q[knt] = b_A[knt];\r\n    }\r\n\r\n    b_coltop += 6;\r\n  }\r\n}\r\n"},{"name":"qr_DvOBrgQi.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_qr_DvOBrgQi_h_\r\n#define RTW_HEADER_qr_DvOBrgQi_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void qr_DvOBrgQi(const real_T A[18], real_T Q[18], real_T R[9]);\r\n\r\n#endif\r\n\r\n"},{"name":"rotate_LZ7ctbe0.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"rotate_LZ7ctbe0.h\"\r\n#include <math.h>\r\n#include \"rt_hypotd_snf.h\"\r\n\r\nvoid rotate_LZ7ctbe0(real_T x, real_T y, real_T *c, real_T *s, real_T *r)\r\n{\r\n  real_T absx;\r\n  real_T absy;\r\n  absx = fabs(x);\r\n  absy = fabs(y);\r\n  if (absy == 0.0) {\r\n    *c = 1.0;\r\n    *s = 0.0;\r\n    *r = x;\r\n  } else if (absx == 0.0) {\r\n    *c = 0.0;\r\n    *s = 1.0;\r\n    *r = y;\r\n  } else {\r\n    real_T rho;\r\n    real_T xx;\r\n    real_T yy;\r\n    absy += absx;\r\n    xx = x / absy;\r\n    yy = y / absy;\r\n    absx = fabs(xx);\r\n    rho = rt_hypotd_snf(absx, fabs(yy));\r\n    *c = absx / rho;\r\n    xx /= absx;\r\n    *s = xx * yy / rho;\r\n    *r = rho * absy * xx;\r\n  }\r\n}\r\n"},{"name":"rotate_LZ7ctbe0.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rotate_LZ7ctbe0_h_\r\n#define RTW_HEADER_rotate_LZ7ctbe0_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void rotate_LZ7ctbe0(real_T x, real_T y, real_T *c, real_T *s, real_T *r);\r\n\r\n#endif\r\n\r\n"},{"name":"rtGetInf.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif\r\n\r\n"},{"name":"rtGetNaN.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif\r\n\r\n"},{"name":"rt_hypotd_snf.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"rt_hypotd_snf.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n\r\nreal_T rt_hypotd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T a;\r\n  real_T y;\r\n  a = fabs(u0);\r\n  y = fabs(u1);\r\n  if (a < y) {\r\n    a /= y;\r\n    y *= sqrt(a * a + 1.0);\r\n  } else if (a > y) {\r\n    y /= a;\r\n    y = sqrt(y * y + 1.0) * a;\r\n  } else if (!rtIsNaN(y)) {\r\n    y = a * 1.4142135623730951;\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"rt_hypotd_snf.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rt_hypotd_snf_h_\r\n#define RTW_HEADER_rt_hypotd_snf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rt_hypotd_snf(real_T u0, real_T u1);\r\n\r\n#endif\r\n\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif\r\n\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n"},{"name":"svd_u3DvUgOe.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"svd_u3DvUgOe.h\"\r\n#include \"xnrm2_xDOlDEtw.h\"\r\n#include <math.h>\r\n#include \"xscal_59GtRAwv.h\"\r\n#include \"xnrm2_Rlk0oxWw.h\"\r\n#include \"xdotc_mznw4aLl.h\"\r\n#include \"xaxpy_guu0hJif.h\"\r\n#include \"xscal_PLmmUlD2.h\"\r\n#include \"xaxpy_OQ28XA21.h\"\r\n#include \"xaxpy_Wxch84Fl.h\"\r\n#include \"xscal_eaAxXsvQ.h\"\r\n#include \"xrotg_XzIjz1eG.h\"\r\n#include \"xrot_i7f01JoJ.h\"\r\n#include \"xswap_JoAqPjUv.h\"\r\n\r\nvoid svd_u3DvUgOe(const real_T A[9], real_T U[9], real_T s[3], real_T V[9])\r\n{\r\n  real_T b_A[9];\r\n  real_T b_s[3];\r\n  real_T e[3];\r\n  real_T work[3];\r\n  real_T nrm;\r\n  real_T rt;\r\n  real_T smm1;\r\n  real_T sqds;\r\n  real_T ztest;\r\n  int32_T d;\r\n  int32_T kase;\r\n  int32_T m;\r\n  int32_T qjj;\r\n  int32_T qq;\r\n  boolean_T apply_transform;\r\n  e[0] = 0.0;\r\n  work[0] = 0.0;\r\n  e[1] = 0.0;\r\n  work[1] = 0.0;\r\n  e[2] = 0.0;\r\n  work[2] = 0.0;\r\n  for (qq = 0; qq < 9; qq++) {\r\n    b_A[qq] = A[qq];\r\n    U[qq] = 0.0;\r\n    V[qq] = 0.0;\r\n  }\r\n\r\n  qq = 0;\r\n  apply_transform = false;\r\n  nrm = xnrm2_xDOlDEtw(3, b_A, 1);\r\n  if (nrm > 0.0) {\r\n    apply_transform = true;\r\n    if (b_A[0] < 0.0) {\r\n      b_s[0] = -nrm;\r\n    } else {\r\n      b_s[0] = nrm;\r\n    }\r\n\r\n    if (fabs(b_s[0]) >= 1.0020841800044864E-292) {\r\n      xscal_59GtRAwv(3, 1.0 / b_s[0], b_A, 1);\r\n    } else {\r\n      for (qjj = 0; qjj < 3; qjj++) {\r\n        b_A[qjj] /= b_s[0];\r\n      }\r\n    }\r\n\r\n    b_A[0]++;\r\n    b_s[0] = -b_s[0];\r\n  } else {\r\n    b_s[0] = 0.0;\r\n  }\r\n\r\n  for (d = 1; d + 1 < 4; d++) {\r\n    qjj = 3 * d;\r\n    if (apply_transform) {\r\n      xaxpy_guu0hJif(3, -(xdotc_mznw4aLl(3, b_A, 1, b_A, qjj + 1) / b_A[0]), 1,\r\n                     b_A, qjj + 1);\r\n    }\r\n\r\n    e[d] = b_A[qjj];\r\n  }\r\n\r\n  while (qq + 1 < 4) {\r\n    U[qq] = b_A[qq];\r\n    qq++;\r\n  }\r\n\r\n  nrm = xnrm2_Rlk0oxWw(2, e, 2);\r\n  if (nrm == 0.0) {\r\n    e[0] = 0.0;\r\n  } else {\r\n    if (e[1] < 0.0) {\r\n      e[0] = -nrm;\r\n    } else {\r\n      e[0] = nrm;\r\n    }\r\n\r\n    nrm = e[0];\r\n    if (fabs(e[0]) >= 1.0020841800044864E-292) {\r\n      xscal_PLmmUlD2(2, 1.0 / e[0], e, 2);\r\n    } else {\r\n      for (qq = 1; qq < 3; qq++) {\r\n        e[qq] /= nrm;\r\n      }\r\n    }\r\n\r\n    e[1]++;\r\n    e[0] = -e[0];\r\n    for (qq = 2; qq < 4; qq++) {\r\n      work[qq - 1] = 0.0;\r\n    }\r\n\r\n    for (qq = 1; qq + 1 < 4; qq++) {\r\n      xaxpy_OQ28XA21(2, e[qq], b_A, 3 * qq + 2, work, 2);\r\n    }\r\n\r\n    for (qq = 1; qq + 1 < 4; qq++) {\r\n      xaxpy_Wxch84Fl(2, -e[qq] / e[1], work, 2, b_A, 3 * qq + 2);\r\n    }\r\n  }\r\n\r\n  for (qq = 1; qq + 1 < 4; qq++) {\r\n    V[qq] = e[qq];\r\n  }\r\n\r\n  apply_transform = false;\r\n  nrm = xnrm2_xDOlDEtw(2, b_A, 5);\r\n  if (nrm > 0.0) {\r\n    apply_transform = true;\r\n    if (b_A[4] < 0.0) {\r\n      b_s[1] = -nrm;\r\n    } else {\r\n      b_s[1] = nrm;\r\n    }\r\n\r\n    if (fabs(b_s[1]) >= 1.0020841800044864E-292) {\r\n      xscal_59GtRAwv(2, 1.0 / b_s[1], b_A, 5);\r\n    } else {\r\n      for (qjj = 4; qjj < 6; qjj++) {\r\n        b_A[qjj] /= b_s[1];\r\n      }\r\n    }\r\n\r\n    b_A[4]++;\r\n    b_s[1] = -b_s[1];\r\n  } else {\r\n    b_s[1] = 0.0;\r\n  }\r\n\r\n  for (d = 2; d + 1 < 4; d++) {\r\n    qjj = 3 * d + 1;\r\n    if (apply_transform) {\r\n      xaxpy_guu0hJif(2, -(xdotc_mznw4aLl(2, b_A, 5, b_A, qjj + 1) / b_A[4]), 5,\r\n                     b_A, qjj + 1);\r\n    }\r\n\r\n    e[d] = b_A[qjj];\r\n  }\r\n\r\n  for (qq = 1; qq + 1 < 4; qq++) {\r\n    U[qq + 3] = b_A[qq + 3];\r\n  }\r\n\r\n  m = 1;\r\n  b_s[2] = b_A[8];\r\n  U[6] = 0.0;\r\n  U[7] = 0.0;\r\n  U[8] = 1.0;\r\n  for (d = 1; d >= 0; d--) {\r\n    qq = 3 * d + d;\r\n    if (b_s[d] != 0.0) {\r\n      for (kase = d + 1; kase + 1 < 4; kase++) {\r\n        qjj = (3 * kase + d) + 1;\r\n        xaxpy_guu0hJif(3 - d, -(xdotc_mznw4aLl(3 - d, U, qq + 1, U, qjj) / U[qq]),\r\n                       qq + 1, U, qjj);\r\n      }\r\n\r\n      for (qjj = d; qjj + 1 < 4; qjj++) {\r\n        kase = 3 * d + qjj;\r\n        U[kase] = -U[kase];\r\n      }\r\n\r\n      U[qq]++;\r\n      if (d - 1 >= 0) {\r\n        U[3 * d] = 0.0;\r\n      }\r\n    } else {\r\n      U[3 * d] = 0.0;\r\n      U[3 * d + 1] = 0.0;\r\n      U[3 * d + 2] = 0.0;\r\n      U[qq] = 1.0;\r\n    }\r\n  }\r\n\r\n  for (qq = 2; qq >= 0; qq--) {\r\n    if ((qq + 1 <= 1) && (e[0] != 0.0)) {\r\n      for (d = 2; d < 4; d++) {\r\n        qjj = (d - 1) * 3 + 2;\r\n        xaxpy_guu0hJif(2, -(xdotc_mznw4aLl(2, V, 2, V, qjj) / V[1]), 2, V, qjj);\r\n      }\r\n    }\r\n\r\n    V[3 * qq] = 0.0;\r\n    V[3 * qq + 1] = 0.0;\r\n    V[3 * qq + 2] = 0.0;\r\n    V[qq + 3 * qq] = 1.0;\r\n  }\r\n\r\n  ztest = e[0];\r\n  if (b_s[0] != 0.0) {\r\n    rt = fabs(b_s[0]);\r\n    nrm = b_s[0] / rt;\r\n    b_s[0] = rt;\r\n    ztest = e[0] / nrm;\r\n    xscal_eaAxXsvQ(nrm, U, 1);\r\n  }\r\n\r\n  if (ztest != 0.0) {\r\n    rt = fabs(ztest);\r\n    nrm = rt / ztest;\r\n    ztest = rt;\r\n    b_s[1] *= nrm;\r\n    xscal_eaAxXsvQ(nrm, V, 4);\r\n  }\r\n\r\n  e[0] = ztest;\r\n  ztest = b_A[7];\r\n  if (b_s[1] != 0.0) {\r\n    rt = fabs(b_s[1]);\r\n    nrm = b_s[1] / rt;\r\n    b_s[1] = rt;\r\n    ztest = b_A[7] / nrm;\r\n    xscal_eaAxXsvQ(nrm, U, 4);\r\n  }\r\n\r\n  if (ztest != 0.0) {\r\n    rt = fabs(ztest);\r\n    nrm = rt / ztest;\r\n    ztest = rt;\r\n    b_s[2] = b_A[8] * nrm;\r\n    xscal_eaAxXsvQ(nrm, V, 7);\r\n  }\r\n\r\n  e[1] = ztest;\r\n  if (b_s[2] != 0.0) {\r\n    rt = fabs(b_s[2]);\r\n    nrm = b_s[2] / rt;\r\n    b_s[2] = rt;\r\n    xscal_eaAxXsvQ(nrm, U, 7);\r\n  }\r\n\r\n  e[2] = 0.0;\r\n  qq = 0;\r\n  nrm = fmax(fmax(fmax(b_s[0], e[0]), fmax(b_s[1], ztest)), fmax(b_s[2], 0.0));\r\n  while ((m + 2 > 0) && (qq < 75)) {\r\n    kase = m + 1;\r\n    int32_T exitg1;\r\n    do {\r\n      exitg1 = 0;\r\n      d = kase;\r\n      if (kase == 0) {\r\n        exitg1 = 1;\r\n      } else {\r\n        rt = fabs(e[kase - 1]);\r\n        if (rt <= (fabs(b_s[kase - 1]) + fabs(b_s[kase])) *\r\n            2.2204460492503131E-16) {\r\n          e[kase - 1] = 0.0;\r\n          exitg1 = 1;\r\n        } else if ((rt <= 1.0020841800044864E-292) || ((qq > 20) && (rt <=\r\n                     2.2204460492503131E-16 * nrm))) {\r\n          e[kase - 1] = 0.0;\r\n          exitg1 = 1;\r\n        } else {\r\n          kase--;\r\n        }\r\n      }\r\n    } while (exitg1 == 0);\r\n\r\n    if (m + 1 == kase) {\r\n      kase = 4;\r\n    } else {\r\n      int32_T k_ii;\r\n      boolean_T exitg2;\r\n      qjj = m + 2;\r\n      k_ii = m + 2;\r\n      exitg2 = false;\r\n      while ((!exitg2) && (k_ii >= kase)) {\r\n        qjj = k_ii;\r\n        if (k_ii == kase) {\r\n          exitg2 = true;\r\n        } else {\r\n          rt = 0.0;\r\n          if (k_ii < m + 2) {\r\n            rt = fabs(e[k_ii - 1]);\r\n          }\r\n\r\n          if (k_ii > kase + 1) {\r\n            rt += fabs(e[k_ii - 2]);\r\n          }\r\n\r\n          ztest = fabs(b_s[k_ii - 1]);\r\n          if ((ztest <= 2.2204460492503131E-16 * rt) || (ztest <=\r\n               1.0020841800044864E-292)) {\r\n            b_s[k_ii - 1] = 0.0;\r\n            exitg2 = true;\r\n          } else {\r\n            k_ii--;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (qjj == kase) {\r\n        kase = 3;\r\n      } else if (m + 2 == qjj) {\r\n        kase = 1;\r\n      } else {\r\n        kase = 2;\r\n        d = qjj;\r\n      }\r\n    }\r\n\r\n    switch (kase) {\r\n     case 1:\r\n      rt = e[m];\r\n      e[m] = 0.0;\r\n      for (qjj = m; qjj + 1 >= d + 1; qjj--) {\r\n        xrotg_XzIjz1eG(&b_s[qjj], &rt, &ztest, &sqds);\r\n        if (qjj + 1 > d + 1) {\r\n          rt = -sqds * e[0];\r\n          e[0] *= ztest;\r\n        }\r\n\r\n        xrot_i7f01JoJ(V, 3 * qjj + 1, 3 * (m + 1) + 1, ztest, sqds);\r\n      }\r\n      break;\r\n\r\n     case 2:\r\n      rt = e[d - 1];\r\n      e[d - 1] = 0.0;\r\n      for (qjj = d; qjj < m + 2; qjj++) {\r\n        xrotg_XzIjz1eG(&b_s[qjj], &rt, &ztest, &sqds);\r\n        rt = -sqds * e[qjj];\r\n        e[qjj] *= ztest;\r\n        xrot_i7f01JoJ(U, 3 * qjj + 1, 3 * (d - 1) + 1, ztest, sqds);\r\n      }\r\n      break;\r\n\r\n     case 3:\r\n      {\r\n        real_T emm1;\r\n        real_T shift;\r\n        sqds = b_s[m + 1];\r\n        ztest = fmax(fmax(fmax(fmax(fabs(sqds), fabs(b_s[m])), fabs(e[m])), fabs\r\n                          (b_s[d])), fabs(e[d]));\r\n        rt = sqds / ztest;\r\n        smm1 = b_s[m] / ztest;\r\n        emm1 = e[m] / ztest;\r\n        sqds = b_s[d] / ztest;\r\n        smm1 = ((smm1 + rt) * (smm1 - rt) + emm1 * emm1) / 2.0;\r\n        emm1 *= rt;\r\n        emm1 *= emm1;\r\n        if ((smm1 != 0.0) || (emm1 != 0.0)) {\r\n          shift = sqrt(smm1 * smm1 + emm1);\r\n          if (smm1 < 0.0) {\r\n            shift = -shift;\r\n          }\r\n\r\n          shift = emm1 / (smm1 + shift);\r\n        } else {\r\n          shift = 0.0;\r\n        }\r\n\r\n        rt = (sqds + rt) * (sqds - rt) + shift;\r\n        ztest = e[d] / ztest * sqds;\r\n        for (qjj = d + 1; qjj <= m + 1; qjj++) {\r\n          xrotg_XzIjz1eG(&rt, &ztest, &sqds, &smm1);\r\n          if (qjj > d + 1) {\r\n            e[0] = rt;\r\n          }\r\n\r\n          rt = e[qjj - 1];\r\n          emm1 = b_s[qjj - 1];\r\n          e[qjj - 1] = rt * sqds - emm1 * smm1;\r\n          ztest = smm1 * b_s[qjj];\r\n          b_s[qjj] *= sqds;\r\n          xrot_i7f01JoJ(V, 3 * (qjj - 1) + 1, 3 * qjj + 1, sqds, smm1);\r\n          b_s[qjj - 1] = emm1 * sqds + rt * smm1;\r\n          xrotg_XzIjz1eG(&b_s[qjj - 1], &ztest, &sqds, &smm1);\r\n          rt = e[qjj - 1] * sqds + smm1 * b_s[qjj];\r\n          b_s[qjj] = e[qjj - 1] * -smm1 + sqds * b_s[qjj];\r\n          ztest = smm1 * e[qjj];\r\n          e[qjj] *= sqds;\r\n          xrot_i7f01JoJ(U, 3 * (qjj - 1) + 1, 3 * qjj + 1, sqds, smm1);\r\n        }\r\n\r\n        e[m] = rt;\r\n        qq++;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      if (b_s[d] < 0.0) {\r\n        b_s[d] = -b_s[d];\r\n        xscal_eaAxXsvQ(-1.0, V, 3 * d + 1);\r\n      }\r\n\r\n      qq = d + 1;\r\n      while ((d + 1 < 3) && (b_s[d] < b_s[qq])) {\r\n        rt = b_s[d];\r\n        b_s[d] = b_s[qq];\r\n        b_s[qq] = rt;\r\n        xswap_JoAqPjUv(V, 3 * d + 1, 3 * (d + 1) + 1);\r\n        xswap_JoAqPjUv(U, 3 * d + 1, 3 * (d + 1) + 1);\r\n        d = qq;\r\n        qq++;\r\n      }\r\n\r\n      qq = 0;\r\n      m--;\r\n      break;\r\n    }\r\n  }\r\n\r\n  s[0] = b_s[0];\r\n  s[1] = b_s[1];\r\n  s[2] = b_s[2];\r\n}\r\n"},{"name":"svd_u3DvUgOe.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_svd_u3DvUgOe_h_\r\n#define RTW_HEADER_svd_u3DvUgOe_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void svd_u3DvUgOe(const real_T A[9], real_T U[9], real_T s[3], real_T V[9]);\r\n\r\n#endif\r\n\r\n"},{"name":"trisolve_BC1XmAGq.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"trisolve_BC1XmAGq.h\"\r\n\r\nvoid trisolve_BC1XmAGq(real_T A, real_T B[3])\r\n{\r\n  if (B[0] != 0.0) {\r\n    B[0] /= A;\r\n  }\r\n\r\n  if (B[1] != 0.0) {\r\n    B[1] /= A;\r\n  }\r\n\r\n  if (B[2] != 0.0) {\r\n    B[2] /= A;\r\n  }\r\n}\r\n"},{"name":"trisolve_BC1XmAGq.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_trisolve_BC1XmAGq_h_\r\n#define RTW_HEADER_trisolve_BC1XmAGq_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void trisolve_BC1XmAGq(real_T A, real_T B[3]);\r\n\r\n#endif\r\n\r\n"},{"name":"xaxpy_OQ28XA21.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xaxpy_OQ28XA21.h\"\r\n\r\nvoid xaxpy_OQ28XA21(int32_T n, real_T a, const real_T x[9], int32_T ix0, real_T\r\n                    y[3], int32_T iy0)\r\n{\r\n  int32_T k;\r\n  if ((n >= 1) && (!(a == 0.0))) {\r\n    int32_T ix;\r\n    int32_T iy;\r\n    ix = ix0 - 1;\r\n    iy = iy0 - 1;\r\n    for (k = 0; k < n; k++) {\r\n      y[iy] += a * x[ix];\r\n      ix++;\r\n      iy++;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xaxpy_OQ28XA21.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xaxpy_OQ28XA21_h_\r\n#define RTW_HEADER_xaxpy_OQ28XA21_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xaxpy_OQ28XA21(int32_T n, real_T a, const real_T x[9], int32_T ix0,\r\n  real_T y[3], int32_T iy0);\r\n\r\n#endif\r\n\r\n"},{"name":"xaxpy_Wxch84Fl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xaxpy_Wxch84Fl.h\"\r\n\r\nvoid xaxpy_Wxch84Fl(int32_T n, real_T a, const real_T x[3], int32_T ix0, real_T\r\n                    y[9], int32_T iy0)\r\n{\r\n  int32_T k;\r\n  if ((n >= 1) && (!(a == 0.0))) {\r\n    int32_T ix;\r\n    int32_T iy;\r\n    ix = ix0 - 1;\r\n    iy = iy0 - 1;\r\n    for (k = 0; k < n; k++) {\r\n      y[iy] += a * x[ix];\r\n      ix++;\r\n      iy++;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xaxpy_Wxch84Fl.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xaxpy_Wxch84Fl_h_\r\n#define RTW_HEADER_xaxpy_Wxch84Fl_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xaxpy_Wxch84Fl(int32_T n, real_T a, const real_T x[3], int32_T ix0,\r\n  real_T y[9], int32_T iy0);\r\n\r\n#endif\r\n\r\n"},{"name":"xaxpy_guu0hJif.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xaxpy_guu0hJif.h\"\r\n\r\nvoid xaxpy_guu0hJif(int32_T n, real_T a, int32_T ix0, real_T y[9], int32_T iy0)\r\n{\r\n  int32_T k;\r\n  if ((n >= 1) && (!(a == 0.0))) {\r\n    int32_T ix;\r\n    int32_T iy;\r\n    ix = ix0 - 1;\r\n    iy = iy0 - 1;\r\n    for (k = 0; k < n; k++) {\r\n      y[iy] += a * y[ix];\r\n      ix++;\r\n      iy++;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xaxpy_guu0hJif.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xaxpy_guu0hJif_h_\r\n#define RTW_HEADER_xaxpy_guu0hJif_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xaxpy_guu0hJif(int32_T n, real_T a, int32_T ix0, real_T y[9],\r\n  int32_T iy0);\r\n\r\n#endif\r\n\r\n"},{"name":"xdotc_mznw4aLl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xdotc_mznw4aLl.h\"\r\n\r\nreal_T xdotc_mznw4aLl(int32_T n, const real_T x[9], int32_T ix0, const real_T y\r\n                      [9], int32_T iy0)\r\n{\r\n  real_T d;\r\n  int32_T k;\r\n  d = 0.0;\r\n  if (n >= 1) {\r\n    int32_T ix;\r\n    int32_T iy;\r\n    ix = ix0;\r\n    iy = iy0;\r\n    for (k = 0; k < n; k++) {\r\n      d += x[ix - 1] * y[iy - 1];\r\n      ix++;\r\n      iy++;\r\n    }\r\n  }\r\n\r\n  return d;\r\n}\r\n"},{"name":"xdotc_mznw4aLl.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xdotc_mznw4aLl_h_\r\n#define RTW_HEADER_xdotc_mznw4aLl_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T xdotc_mznw4aLl(int32_T n, const real_T x[9], int32_T ix0, const\r\n  real_T y[9], int32_T iy0);\r\n\r\n#endif\r\n\r\n"},{"name":"xgemv_NQlWbt2i.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xgemv_NQlWbt2i.h\"\r\n\r\nvoid xgemv_NQlWbt2i(int32_T m, int32_T n, const real_T A[18], int32_T ia0, const\r\n                    real_T x[18], int32_T ix0, real_T y[3])\r\n{\r\n  int32_T b_iy;\r\n  int32_T ia;\r\n  int32_T iac;\r\n  if ((m != 0) && (n != 0)) {\r\n    int32_T b;\r\n    for (b_iy = 0; b_iy < n; b_iy++) {\r\n      y[b_iy] = 0.0;\r\n    }\r\n\r\n    b_iy = 0;\r\n    b = (n - 1) * 6 + ia0;\r\n    for (iac = ia0; iac <= b; iac += 6) {\r\n      real_T c;\r\n      int32_T d;\r\n      int32_T ix;\r\n      ix = ix0;\r\n      c = 0.0;\r\n      d = (iac + m) - 1;\r\n      for (ia = iac; ia <= d; ia++) {\r\n        c += A[ia - 1] * x[ix - 1];\r\n        ix++;\r\n      }\r\n\r\n      y[b_iy] += c;\r\n      b_iy++;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xgemv_NQlWbt2i.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xgemv_NQlWbt2i_h_\r\n#define RTW_HEADER_xgemv_NQlWbt2i_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xgemv_NQlWbt2i(int32_T m, int32_T n, const real_T A[18], int32_T ia0,\r\n  const real_T x[18], int32_T ix0, real_T y[3]);\r\n\r\n#endif\r\n\r\n"},{"name":"xgemv_fRiR1I1O.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xgemv_fRiR1I1O.h\"\r\n\r\nvoid xgemv_fRiR1I1O(int32_T m, int32_T n, const real_T A[9], int32_T ia0, const\r\n                    real_T x[9], int32_T ix0, real_T y[3])\r\n{\r\n  int32_T b_iy;\r\n  int32_T ia;\r\n  int32_T iac;\r\n  if ((m != 0) && (n != 0)) {\r\n    int32_T b;\r\n    for (b_iy = 0; b_iy < n; b_iy++) {\r\n      y[b_iy] = 0.0;\r\n    }\r\n\r\n    b_iy = 0;\r\n    b = (n - 1) * 3 + ia0;\r\n    for (iac = ia0; iac <= b; iac += 3) {\r\n      real_T c;\r\n      int32_T d;\r\n      int32_T ix;\r\n      ix = ix0;\r\n      c = 0.0;\r\n      d = (iac + m) - 1;\r\n      for (ia = iac; ia <= d; ia++) {\r\n        c += A[ia - 1] * x[ix - 1];\r\n        ix++;\r\n      }\r\n\r\n      y[b_iy] += c;\r\n      b_iy++;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xgemv_fRiR1I1O.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xgemv_fRiR1I1O_h_\r\n#define RTW_HEADER_xgemv_fRiR1I1O_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xgemv_fRiR1I1O(int32_T m, int32_T n, const real_T A[9], int32_T ia0,\r\n  const real_T x[9], int32_T ix0, real_T y[3]);\r\n\r\n#endif\r\n\r\n"},{"name":"xgerc_R09LiDgJ.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xgerc_R09LiDgJ.h\"\r\n\r\nvoid xgerc_R09LiDgJ(int32_T m, int32_T n, real_T alpha1, int32_T ix0, const\r\n                    real_T y[3], real_T A[18], int32_T ia0)\r\n{\r\n  int32_T j;\r\n  if (!(alpha1 == 0.0)) {\r\n    int32_T jA;\r\n    int32_T jy;\r\n    jA = ia0 - 1;\r\n    jy = 0;\r\n    for (j = 0; j < n; j++) {\r\n      if (y[jy] != 0.0) {\r\n        real_T temp;\r\n        int32_T b;\r\n        int32_T ijA;\r\n        int32_T ix;\r\n        temp = y[jy] * alpha1;\r\n        ix = ix0;\r\n        ijA = jA;\r\n        b = m + jA;\r\n        while (ijA + 1 <= b) {\r\n          A[ijA] += A[ix - 1] * temp;\r\n          ix++;\r\n          ijA++;\r\n        }\r\n      }\r\n\r\n      jy++;\r\n      jA += 6;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xgerc_R09LiDgJ.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xgerc_R09LiDgJ_h_\r\n#define RTW_HEADER_xgerc_R09LiDgJ_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xgerc_R09LiDgJ(int32_T m, int32_T n, real_T alpha1, int32_T ix0,\r\n  const real_T y[3], real_T A[18], int32_T ia0);\r\n\r\n#endif\r\n\r\n"},{"name":"xgerc_tNNiazQU.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xgerc_tNNiazQU.h\"\r\n\r\nvoid xgerc_tNNiazQU(int32_T m, int32_T n, real_T alpha1, int32_T ix0, const\r\n                    real_T y[3], real_T A[9], int32_T ia0)\r\n{\r\n  int32_T j;\r\n  if (!(alpha1 == 0.0)) {\r\n    int32_T jA;\r\n    int32_T jy;\r\n    jA = ia0 - 1;\r\n    jy = 0;\r\n    for (j = 0; j < n; j++) {\r\n      if (y[jy] != 0.0) {\r\n        real_T temp;\r\n        int32_T b;\r\n        int32_T ijA;\r\n        int32_T ix;\r\n        temp = y[jy] * alpha1;\r\n        ix = ix0;\r\n        ijA = jA;\r\n        b = m + jA;\r\n        while (ijA + 1 <= b) {\r\n          A[ijA] += A[ix - 1] * temp;\r\n          ix++;\r\n          ijA++;\r\n        }\r\n      }\r\n\r\n      jy++;\r\n      jA += 3;\r\n    }\r\n  }\r\n}\r\n"},{"name":"xgerc_tNNiazQU.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xgerc_tNNiazQU_h_\r\n#define RTW_HEADER_xgerc_tNNiazQU_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xgerc_tNNiazQU(int32_T m, int32_T n, real_T alpha1, int32_T ix0,\r\n  const real_T y[3], real_T A[9], int32_T ia0);\r\n\r\n#endif\r\n\r\n"},{"name":"xnrm2_7bm34mDQ.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xnrm2_7bm34mDQ.h\"\r\n#include <math.h>\r\n\r\nreal_T xnrm2_7bm34mDQ(int32_T n, const real_T x[6], int32_T ix0)\r\n{\r\n  real_T y;\r\n  int32_T k;\r\n  y = 0.0;\r\n  if (n >= 1) {\r\n    if (n == 1) {\r\n      y = fabs(x[ix0 - 1]);\r\n    } else {\r\n      real_T scale;\r\n      int32_T kend;\r\n      scale = 3.3121686421112381E-170;\r\n      kend = (ix0 + n) - 1;\r\n      for (k = ix0; k <= kend; k++) {\r\n        real_T absxk;\r\n        absxk = fabs(x[k - 1]);\r\n        if (absxk > scale) {\r\n          real_T t;\r\n          t = scale / absxk;\r\n          y = y * t * t + 1.0;\r\n          scale = absxk;\r\n        } else {\r\n          real_T t;\r\n          t = absxk / scale;\r\n          y += t * t;\r\n        }\r\n      }\r\n\r\n      y = scale * sqrt(y);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"xnrm2_7bm34mDQ.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xnrm2_7bm34mDQ_h_\r\n#define RTW_HEADER_xnrm2_7bm34mDQ_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T xnrm2_7bm34mDQ(int32_T n, const real_T x[6], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xnrm2_Mnmxg9YT.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xnrm2_Mnmxg9YT.h\"\r\n#include <math.h>\r\n\r\nreal_T xnrm2_Mnmxg9YT(int32_T n, const real_T x[2], int32_T ix0)\r\n{\r\n  real_T y;\r\n  int32_T k;\r\n  y = 0.0;\r\n  if (n >= 1) {\r\n    if (n == 1) {\r\n      y = fabs(x[ix0 - 1]);\r\n    } else {\r\n      real_T scale;\r\n      int32_T kend;\r\n      scale = 3.3121686421112381E-170;\r\n      kend = (ix0 + n) - 1;\r\n      for (k = ix0; k <= kend; k++) {\r\n        real_T absxk;\r\n        absxk = fabs(x[k - 1]);\r\n        if (absxk > scale) {\r\n          real_T t;\r\n          t = scale / absxk;\r\n          y = y * t * t + 1.0;\r\n          scale = absxk;\r\n        } else {\r\n          real_T t;\r\n          t = absxk / scale;\r\n          y += t * t;\r\n        }\r\n      }\r\n\r\n      y = scale * sqrt(y);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"xnrm2_Mnmxg9YT.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xnrm2_Mnmxg9YT_h_\r\n#define RTW_HEADER_xnrm2_Mnmxg9YT_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T xnrm2_Mnmxg9YT(int32_T n, const real_T x[2], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xnrm2_Rlk0oxWw.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xnrm2_Rlk0oxWw.h\"\r\n#include <math.h>\r\n\r\nreal_T xnrm2_Rlk0oxWw(int32_T n, const real_T x[3], int32_T ix0)\r\n{\r\n  real_T y;\r\n  int32_T k;\r\n  y = 0.0;\r\n  if (n >= 1) {\r\n    if (n == 1) {\r\n      y = fabs(x[ix0 - 1]);\r\n    } else {\r\n      real_T scale;\r\n      int32_T kend;\r\n      scale = 3.3121686421112381E-170;\r\n      kend = (ix0 + n) - 1;\r\n      for (k = ix0; k <= kend; k++) {\r\n        real_T absxk;\r\n        absxk = fabs(x[k - 1]);\r\n        if (absxk > scale) {\r\n          real_T t;\r\n          t = scale / absxk;\r\n          y = y * t * t + 1.0;\r\n          scale = absxk;\r\n        } else {\r\n          real_T t;\r\n          t = absxk / scale;\r\n          y += t * t;\r\n        }\r\n      }\r\n\r\n      y = scale * sqrt(y);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"xnrm2_Rlk0oxWw.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xnrm2_Rlk0oxWw_h_\r\n#define RTW_HEADER_xnrm2_Rlk0oxWw_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T xnrm2_Rlk0oxWw(int32_T n, const real_T x[3], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xnrm2_nLdASVZH.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xnrm2_nLdASVZH.h\"\r\n#include <math.h>\r\n\r\nreal_T xnrm2_nLdASVZH(int32_T n, const real_T x[18], int32_T ix0)\r\n{\r\n  real_T y;\r\n  int32_T k;\r\n  y = 0.0;\r\n  if (n >= 1) {\r\n    if (n == 1) {\r\n      y = fabs(x[ix0 - 1]);\r\n    } else {\r\n      real_T scale;\r\n      int32_T kend;\r\n      scale = 3.3121686421112381E-170;\r\n      kend = (ix0 + n) - 1;\r\n      for (k = ix0; k <= kend; k++) {\r\n        real_T absxk;\r\n        absxk = fabs(x[k - 1]);\r\n        if (absxk > scale) {\r\n          real_T t;\r\n          t = scale / absxk;\r\n          y = y * t * t + 1.0;\r\n          scale = absxk;\r\n        } else {\r\n          real_T t;\r\n          t = absxk / scale;\r\n          y += t * t;\r\n        }\r\n      }\r\n\r\n      y = scale * sqrt(y);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"xnrm2_nLdASVZH.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xnrm2_nLdASVZH_h_\r\n#define RTW_HEADER_xnrm2_nLdASVZH_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T xnrm2_nLdASVZH(int32_T n, const real_T x[18], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xnrm2_xDOlDEtw.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xnrm2_xDOlDEtw.h\"\r\n#include <math.h>\r\n\r\nreal_T xnrm2_xDOlDEtw(int32_T n, const real_T x[9], int32_T ix0)\r\n{\r\n  real_T y;\r\n  int32_T k;\r\n  y = 0.0;\r\n  if (n >= 1) {\r\n    if (n == 1) {\r\n      y = fabs(x[ix0 - 1]);\r\n    } else {\r\n      real_T scale;\r\n      int32_T kend;\r\n      scale = 3.3121686421112381E-170;\r\n      kend = (ix0 + n) - 1;\r\n      for (k = ix0; k <= kend; k++) {\r\n        real_T absxk;\r\n        absxk = fabs(x[k - 1]);\r\n        if (absxk > scale) {\r\n          real_T t;\r\n          t = scale / absxk;\r\n          y = y * t * t + 1.0;\r\n          scale = absxk;\r\n        } else {\r\n          real_T t;\r\n          t = absxk / scale;\r\n          y += t * t;\r\n        }\r\n      }\r\n\r\n      y = scale * sqrt(y);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n"},{"name":"xnrm2_xDOlDEtw.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xnrm2_xDOlDEtw_h_\r\n#define RTW_HEADER_xnrm2_xDOlDEtw_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T xnrm2_xDOlDEtw(int32_T n, const real_T x[9], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xrot_i7f01JoJ.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xrot_i7f01JoJ.h\"\r\n\r\nvoid xrot_i7f01JoJ(real_T x[9], int32_T ix0, int32_T iy0, real_T c, real_T s)\r\n{\r\n  real_T temp;\r\n  real_T temp_tmp;\r\n  temp = x[iy0 - 1];\r\n  temp_tmp = x[ix0 - 1];\r\n  x[iy0 - 1] = temp * c - temp_tmp * s;\r\n  x[ix0 - 1] = temp_tmp * c + temp * s;\r\n  temp = x[ix0] * c + x[iy0] * s;\r\n  x[iy0] = x[iy0] * c - x[ix0] * s;\r\n  x[ix0] = temp;\r\n  temp = x[iy0 + 1];\r\n  temp_tmp = x[ix0 + 1];\r\n  x[iy0 + 1] = temp * c - temp_tmp * s;\r\n  x[ix0 + 1] = temp_tmp * c + temp * s;\r\n}\r\n"},{"name":"xrot_i7f01JoJ.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xrot_i7f01JoJ_h_\r\n#define RTW_HEADER_xrot_i7f01JoJ_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xrot_i7f01JoJ(real_T x[9], int32_T ix0, int32_T iy0, real_T c,\r\n  real_T s);\r\n\r\n#endif\r\n\r\n"},{"name":"xrotg_XzIjz1eG.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xrotg_XzIjz1eG.h\"\r\n#include <math.h>\r\n\r\nvoid xrotg_XzIjz1eG(real_T *a, real_T *b, real_T *c, real_T *s)\r\n{\r\n  real_T absa;\r\n  real_T absb;\r\n  real_T roe;\r\n  real_T scale;\r\n  roe = *b;\r\n  absa = fabs(*a);\r\n  absb = fabs(*b);\r\n  if (absa > absb) {\r\n    roe = *a;\r\n  }\r\n\r\n  scale = absa + absb;\r\n  if (scale == 0.0) {\r\n    *s = 0.0;\r\n    *c = 1.0;\r\n    *a = 0.0;\r\n    *b = 0.0;\r\n  } else {\r\n    real_T ads;\r\n    real_T bds;\r\n    ads = absa / scale;\r\n    bds = absb / scale;\r\n    scale *= sqrt(ads * ads + bds * bds);\r\n    if (roe < 0.0) {\r\n      scale = -scale;\r\n    }\r\n\r\n    *c = *a / scale;\r\n    *s = *b / scale;\r\n    if (absa > absb) {\r\n      *b = *s;\r\n    } else if (*c != 0.0) {\r\n      *b = 1.0 / *c;\r\n    } else {\r\n      *b = 1.0;\r\n    }\r\n\r\n    *a = scale;\r\n  }\r\n}\r\n"},{"name":"xrotg_XzIjz1eG.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xrotg_XzIjz1eG_h_\r\n#define RTW_HEADER_xrotg_XzIjz1eG_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xrotg_XzIjz1eG(real_T *a, real_T *b, real_T *c, real_T *s);\r\n\r\n#endif\r\n\r\n"},{"name":"xscal_59GtRAwv.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xscal_59GtRAwv.h\"\r\n\r\nvoid xscal_59GtRAwv(int32_T n, real_T a, real_T x[9], int32_T ix0)\r\n{\r\n  int32_T b;\r\n  int32_T k;\r\n  b = (ix0 + n) - 1;\r\n  for (k = ix0; k <= b; k++) {\r\n    x[k - 1] *= a;\r\n  }\r\n}\r\n"},{"name":"xscal_59GtRAwv.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xscal_59GtRAwv_h_\r\n#define RTW_HEADER_xscal_59GtRAwv_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xscal_59GtRAwv(int32_T n, real_T a, real_T x[9], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xscal_PLmmUlD2.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xscal_PLmmUlD2.h\"\r\n\r\nvoid xscal_PLmmUlD2(int32_T n, real_T a, real_T x[3], int32_T ix0)\r\n{\r\n  int32_T b;\r\n  int32_T k;\r\n  b = (ix0 + n) - 1;\r\n  for (k = ix0; k <= b; k++) {\r\n    x[k - 1] *= a;\r\n  }\r\n}\r\n"},{"name":"xscal_PLmmUlD2.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xscal_PLmmUlD2_h_\r\n#define RTW_HEADER_xscal_PLmmUlD2_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xscal_PLmmUlD2(int32_T n, real_T a, real_T x[3], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xscal_eaAxXsvQ.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xscal_eaAxXsvQ.h\"\r\n\r\nvoid xscal_eaAxXsvQ(real_T a, real_T x[9], int32_T ix0)\r\n{\r\n  int32_T k;\r\n  for (k = ix0; k <= ix0 + 2; k++) {\r\n    x[k - 1] *= a;\r\n  }\r\n}\r\n"},{"name":"xscal_eaAxXsvQ.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xscal_eaAxXsvQ_h_\r\n#define RTW_HEADER_xscal_eaAxXsvQ_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xscal_eaAxXsvQ(real_T a, real_T x[9], int32_T ix0);\r\n\r\n#endif\r\n\r\n"},{"name":"xswap_JoAqPjUv.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#include \"rtwtypes.h\"\r\n#include \"xswap_JoAqPjUv.h\"\r\n\r\nvoid xswap_JoAqPjUv(real_T x[9], int32_T ix0, int32_T iy0)\r\n{\r\n  real_T temp;\r\n  temp = x[ix0 - 1];\r\n  x[ix0 - 1] = x[iy0 - 1];\r\n  x[iy0 - 1] = temp;\r\n  temp = x[ix0];\r\n  x[ix0] = x[iy0];\r\n  x[iy0] = temp;\r\n  temp = x[ix0 + 1];\r\n  x[ix0 + 1] = x[iy0 + 1];\r\n  x[iy0 + 1] = temp;\r\n}\r\n"},{"name":"xswap_JoAqPjUv.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTW_HEADER_xswap_JoAqPjUv_h_\r\n#define RTW_HEADER_xswap_JoAqPjUv_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern void xswap_JoAqPjUv(real_T x[9], int32_T ix0, int32_T iy0);\r\n\r\n#endif\r\n\r\n"}]};