var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"model/EQV","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include <stddef.h>\r\n#include <stdio.h>\r\n#include \"EQV.h\"\r\n\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(EQV_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n  EQV_step();\r\n  OverrunFlag = false;\r\n}\r\n\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  (void)(argc);\r\n  (void)(argv);\r\n  EQV_initialize();\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(EQV_M) == (NULL)) {\r\n  }\r\n\r\n  EQV_terminate();\r\n  return 0;\r\n}\r\n"},{"name":"EQV.c","type":"source","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Model files","code":"#include \"EQV.h\"\r\n#include <string.h>\r\n#include \"rtwtypes.h\"\r\n#include <stddef.h>\r\n\r\nB_EQV_T EQV_B;\r\nDW_EQV_T EQV_DW;\r\nExtU_EQV_T EQV_U;\r\nExtY_EQV_T EQV_Y;\r\nstatic RT_MODEL_EQV_T EQV_M_;\r\nRT_MODEL_EQV_T *const EQV_M = &EQV_M_;\r\nvoid EQV_step(void)\r\n{\r\n  NeslSimulationData *simulationData;\r\n  NeuDiagnosticManager *diagnosticManager;\r\n  NeuDiagnosticTree *diagnosticTree;\r\n  NeuDiagnosticTree *diagnosticTree_0;\r\n  NeuDiagnosticTree *diagnosticTree_1;\r\n  NeuDiagnosticTree *diagnosticTree_2;\r\n  real_T tmp_1[58];\r\n  real_T tmp_3[58];\r\n  real_T tmp[24];\r\n  real_T tmp_5[24];\r\n  real_T rtb_OUTPUT_1_0[2];\r\n  real_T Product;\r\n  real_T Product1;\r\n  real_T rtb_Add;\r\n  real_T rtb_Memory8;\r\n  real_T rtb_OUTPUT_1_1;\r\n  real_T time;\r\n  real_T time_0;\r\n  real_T time_1;\r\n  real_T time_2;\r\n  real_T time_3;\r\n  real_T time_4;\r\n  real_T time_5;\r\n  real_T time_tmp;\r\n  real_T time_tmp_0;\r\n  int32_T isHit;\r\n  int32_T isHit_0;\r\n  int32_T isHit_1;\r\n  int32_T rowIdx;\r\n  int_T tmp_2[8];\r\n  int_T tmp_4[8];\r\n  int_T tmp_0[7];\r\n  int_T tmp_6[7];\r\n  boolean_T rtb_Logic_a_idx_0;\r\n  boolean_T rtb_Logic_idx_0;\r\n  boolean_T rtb_Logic_idx_1;\r\n  EQV_B.INPUT_1_1_1[0] = EQV_U.y_f;\r\n  EQV_B.INPUT_1_1_1[1] = 0.0;\r\n  EQV_B.INPUT_1_1_1[2] = 0.0;\r\n  EQV_DW.INPUT_1_1_1_Discrete[0] = !(EQV_B.INPUT_1_1_1[0] ==\r\n    EQV_DW.INPUT_1_1_1_Discrete[1]);\r\n  EQV_DW.INPUT_1_1_1_Discrete[1] = EQV_B.INPUT_1_1_1[0];\r\n  EQV_B.INPUT_1_1_1[0] = EQV_DW.INPUT_1_1_1_Discrete[1];\r\n  EQV_B.INPUT_1_1_1[3] = EQV_DW.INPUT_1_1_1_Discrete[0];\r\n  EQV_B.INPUT_2_1_1[0] = EQV_U.VoltageLevel;\r\n  EQV_B.INPUT_2_1_1[1] = 0.0;\r\n  EQV_B.INPUT_2_1_1[2] = 0.0;\r\n  EQV_DW.INPUT_2_1_1_Discrete[0] = !(EQV_B.INPUT_2_1_1[0] ==\r\n    EQV_DW.INPUT_2_1_1_Discrete[1]);\r\n  EQV_DW.INPUT_2_1_1_Discrete[1] = EQV_B.INPUT_2_1_1[0];\r\n  EQV_B.INPUT_2_1_1[0] = EQV_DW.INPUT_2_1_1_Discrete[1];\r\n  EQV_B.INPUT_2_1_1[3] = EQV_DW.INPUT_2_1_1_Discrete[0];\r\n  rowIdx = (int32_T)(((((uint32_T)EQV_U.AMS_error << 1) + EQV_U.AMS_error_reset)\r\n                      << 1) + EQV_DW.Memory_PreviousInput);\r\n  rtb_Logic_idx_0 = EQV_P.Logic_table[(uint32_T)rowIdx];\r\n  rtb_Logic_idx_1 = EQV_P.Logic_table[rowIdx + 8U];\r\n  rowIdx = (int32_T)(((((uint32_T)EQV_U.IMD_error << 1) + EQV_U.IMD_error_reset)\r\n                      << 1) + EQV_DW.Memory_PreviousInput_m);\r\n  rtb_Logic_a_idx_0 = EQV_P.Logic_table_f[(uint32_T)rowIdx];\r\n  rtb_Memory8 = (rtb_Logic_idx_1 ? (real_T)EQV_P.Logic_table_f[rowIdx + 8U] :\r\n                 0.0) * EQV_U.SC;\r\n  Product = rtb_Memory8 * EQV_DW.Delay1_DSTATE;\r\n  EQV_B.INPUT_3_1_1[0] = Product;\r\n  EQV_B.INPUT_3_1_1[1] = 0.0;\r\n  EQV_B.INPUT_3_1_1[2] = 0.0;\r\n  EQV_DW.INPUT_3_1_1_Discrete[0] = !(EQV_B.INPUT_3_1_1[0] ==\r\n    EQV_DW.INPUT_3_1_1_Discrete[1]);\r\n  EQV_DW.INPUT_3_1_1_Discrete[1] = EQV_B.INPUT_3_1_1[0];\r\n  EQV_B.INPUT_3_1_1[0] = EQV_DW.INPUT_3_1_1_Discrete[1];\r\n  EQV_B.INPUT_3_1_1[3] = EQV_DW.INPUT_3_1_1_Discrete[0];\r\n  Product1 = rtb_Memory8 * EQV_DW.Delay2_DSTATE[0];\r\n  EQV_B.INPUT_4_1_1[0] = Product1;\r\n  EQV_B.INPUT_4_1_1[1] = 0.0;\r\n  EQV_B.INPUT_4_1_1[2] = 0.0;\r\n  EQV_DW.INPUT_4_1_1_Discrete[0] = !(EQV_B.INPUT_4_1_1[0] ==\r\n    EQV_DW.INPUT_4_1_1_Discrete[1]);\r\n  EQV_DW.INPUT_4_1_1_Discrete[1] = EQV_B.INPUT_4_1_1[0];\r\n  EQV_B.INPUT_4_1_1[0] = EQV_DW.INPUT_4_1_1_Discrete[1];\r\n  EQV_B.INPUT_4_1_1[3] = EQV_DW.INPUT_4_1_1_Discrete[0];\r\n  EQV_B.INPUT_5_1_1[0] = EQV_U.y;\r\n  EQV_B.INPUT_5_1_1[1] = 0.0;\r\n  EQV_B.INPUT_5_1_1[2] = 0.0;\r\n  EQV_DW.INPUT_5_1_1_Discrete[0] = !(EQV_B.INPUT_5_1_1[0] ==\r\n    EQV_DW.INPUT_5_1_1_Discrete[1]);\r\n  EQV_DW.INPUT_5_1_1_Discrete[1] = EQV_B.INPUT_5_1_1[0];\r\n  EQV_B.INPUT_5_1_1[0] = EQV_DW.INPUT_5_1_1_Discrete[1];\r\n  EQV_B.INPUT_5_1_1[3] = EQV_DW.INPUT_5_1_1_Discrete[0];\r\n  rtb_Memory8 *= EQV_DW.Delay3_DSTATE[0];\r\n  EQV_B.INPUT_6_1_1[0] = rtb_Memory8;\r\n  EQV_B.INPUT_6_1_1[1] = 0.0;\r\n  EQV_B.INPUT_6_1_1[2] = 0.0;\r\n  EQV_DW.INPUT_6_1_1_Discrete[0] = !(EQV_B.INPUT_6_1_1[0] ==\r\n    EQV_DW.INPUT_6_1_1_Discrete[1]);\r\n  EQV_DW.INPUT_6_1_1_Discrete[1] = EQV_B.INPUT_6_1_1[0];\r\n  EQV_B.INPUT_6_1_1[0] = EQV_DW.INPUT_6_1_1_Discrete[1];\r\n  EQV_B.INPUT_6_1_1[3] = EQV_DW.INPUT_6_1_1_Discrete[0];\r\n  simulationData = (NeslSimulationData *)EQV_DW.STATE_1_SimData;\r\n  time_tmp = ((EQV_M->Timing.clockTick0) * 0.2);\r\n  time = time_tmp;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 18;\r\n  simulationData->mData->mDiscStates.mX = &EQV_DW.STATE_1_Discrete[0];\r\n  simulationData->mData->mModeVector.mN = 16;\r\n  simulationData->mData->mModeVector.mX = &EQV_DW.STATE_1_Modes[0];\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_0[0] = 0;\r\n  tmp[0] = EQV_B.INPUT_1_1_1[0];\r\n  tmp[1] = EQV_B.INPUT_1_1_1[1];\r\n  tmp[2] = EQV_B.INPUT_1_1_1[2];\r\n  tmp[3] = EQV_B.INPUT_1_1_1[3];\r\n  tmp_0[1] = 4;\r\n  tmp[4] = EQV_B.INPUT_2_1_1[0];\r\n  tmp[5] = EQV_B.INPUT_2_1_1[1];\r\n  tmp[6] = EQV_B.INPUT_2_1_1[2];\r\n  tmp[7] = EQV_B.INPUT_2_1_1[3];\r\n  tmp_0[2] = 8;\r\n  tmp[8] = EQV_B.INPUT_3_1_1[0];\r\n  tmp[9] = EQV_B.INPUT_3_1_1[1];\r\n  tmp[10] = EQV_B.INPUT_3_1_1[2];\r\n  tmp[11] = EQV_B.INPUT_3_1_1[3];\r\n  tmp_0[3] = 12;\r\n  tmp[12] = EQV_B.INPUT_4_1_1[0];\r\n  tmp[13] = EQV_B.INPUT_4_1_1[1];\r\n  tmp[14] = EQV_B.INPUT_4_1_1[2];\r\n  tmp[15] = EQV_B.INPUT_4_1_1[3];\r\n  tmp_0[4] = 16;\r\n  tmp[16] = EQV_B.INPUT_5_1_1[0];\r\n  tmp[17] = EQV_B.INPUT_5_1_1[1];\r\n  tmp[18] = EQV_B.INPUT_5_1_1[2];\r\n  tmp[19] = EQV_B.INPUT_5_1_1[3];\r\n  tmp_0[5] = 20;\r\n  tmp[20] = EQV_B.INPUT_6_1_1[0];\r\n  tmp[21] = EQV_B.INPUT_6_1_1[1];\r\n  tmp[22] = EQV_B.INPUT_6_1_1[2];\r\n  tmp[23] = EQV_B.INPUT_6_1_1[3];\r\n  tmp_0[6] = 24;\r\n  simulationData->mData->mInputValues.mN = 24;\r\n  simulationData->mData->mInputValues.mX = &tmp[0];\r\n  simulationData->mData->mInputOffsets.mN = 7;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_0[0];\r\n  simulationData->mData->mOutputs.mN = 34;\r\n  simulationData->mData->mOutputs.mX = &EQV_B.STATE_1[0];\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  time_tmp_0 = ((EQV_M->Timing.clockTick0) * 0.2);\r\n  time_0 = time_tmp_0;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_0;\r\n  isHit = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)EQV_DW.STATE_1_DiagMgr;\r\n  diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  rowIdx = ne_simulator_method((NeslSimulator *)EQV_DW.STATE_1_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (rowIdx != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg;\r\n      msg = rtw_diagnostics_msg(diagnosticTree);\r\n      rtmSetErrorStatus(EQV_M, msg);\r\n    }\r\n  }\r\n\r\n  simulationData = (NeslSimulationData *)EQV_DW.OUTPUT_1_0_SimData;\r\n  time_1 = time_tmp;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_1;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &EQV_DW.OUTPUT_1_0_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &EQV_DW.OUTPUT_1_0_Modes;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_2[0] = 0;\r\n  tmp_1[0] = EQV_B.INPUT_1_1_1[0];\r\n  tmp_1[1] = EQV_B.INPUT_1_1_1[1];\r\n  tmp_1[2] = EQV_B.INPUT_1_1_1[2];\r\n  tmp_1[3] = EQV_B.INPUT_1_1_1[3];\r\n  tmp_2[1] = 4;\r\n  tmp_1[4] = EQV_B.INPUT_2_1_1[0];\r\n  tmp_1[5] = EQV_B.INPUT_2_1_1[1];\r\n  tmp_1[6] = EQV_B.INPUT_2_1_1[2];\r\n  tmp_1[7] = EQV_B.INPUT_2_1_1[3];\r\n  tmp_2[2] = 8;\r\n  tmp_1[8] = EQV_B.INPUT_3_1_1[0];\r\n  tmp_1[9] = EQV_B.INPUT_3_1_1[1];\r\n  tmp_1[10] = EQV_B.INPUT_3_1_1[2];\r\n  tmp_1[11] = EQV_B.INPUT_3_1_1[3];\r\n  tmp_2[3] = 12;\r\n  tmp_1[12] = EQV_B.INPUT_4_1_1[0];\r\n  tmp_1[13] = EQV_B.INPUT_4_1_1[1];\r\n  tmp_1[14] = EQV_B.INPUT_4_1_1[2];\r\n  tmp_1[15] = EQV_B.INPUT_4_1_1[3];\r\n  tmp_2[4] = 16;\r\n  tmp_1[16] = EQV_B.INPUT_5_1_1[0];\r\n  tmp_1[17] = EQV_B.INPUT_5_1_1[1];\r\n  tmp_1[18] = EQV_B.INPUT_5_1_1[2];\r\n  tmp_1[19] = EQV_B.INPUT_5_1_1[3];\r\n  tmp_2[5] = 20;\r\n  tmp_1[20] = EQV_B.INPUT_6_1_1[0];\r\n  tmp_1[21] = EQV_B.INPUT_6_1_1[1];\r\n  tmp_1[22] = EQV_B.INPUT_6_1_1[2];\r\n  tmp_1[23] = EQV_B.INPUT_6_1_1[3];\r\n  tmp_2[6] = 24;\r\n  memcpy(&tmp_1[24], &EQV_B.STATE_1[0], 34U * sizeof(real_T));\r\n  tmp_2[7] = 58;\r\n  simulationData->mData->mInputValues.mN = 58;\r\n  simulationData->mData->mInputValues.mX = &tmp_1[0];\r\n  simulationData->mData->mInputOffsets.mN = 8;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_2[0];\r\n  simulationData->mData->mOutputs.mN = 2;\r\n  simulationData->mData->mOutputs.mX = &rtb_OUTPUT_1_0[0];\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  time_2 = time_tmp_0;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_2;\r\n  isHit_0 = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit_0;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)EQV_DW.OUTPUT_1_0_DiagMgr;\r\n  diagnosticTree_0 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  rowIdx = ne_simulator_method((NeslSimulator *)EQV_DW.OUTPUT_1_0_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (rowIdx != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_0;\r\n      msg_0 = rtw_diagnostics_msg(diagnosticTree_0);\r\n      rtmSetErrorStatus(EQV_M, msg_0);\r\n    }\r\n  }\r\n\r\n  rtb_Add = rtb_OUTPUT_1_0[0] + EQV_U.CurrentLevel;\r\n  simulationData = (NeslSimulationData *)EQV_DW.OUTPUT_1_1_SimData;\r\n  time_3 = time_tmp;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_3;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 0;\r\n  simulationData->mData->mDiscStates.mX = &EQV_DW.OUTPUT_1_1_Discrete;\r\n  simulationData->mData->mModeVector.mN = 0;\r\n  simulationData->mData->mModeVector.mX = &EQV_DW.OUTPUT_1_1_Modes;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_4[0] = 0;\r\n  tmp_3[0] = EQV_B.INPUT_1_1_1[0];\r\n  tmp_3[1] = EQV_B.INPUT_1_1_1[1];\r\n  tmp_3[2] = EQV_B.INPUT_1_1_1[2];\r\n  tmp_3[3] = EQV_B.INPUT_1_1_1[3];\r\n  tmp_4[1] = 4;\r\n  tmp_3[4] = EQV_B.INPUT_2_1_1[0];\r\n  tmp_3[5] = EQV_B.INPUT_2_1_1[1];\r\n  tmp_3[6] = EQV_B.INPUT_2_1_1[2];\r\n  tmp_3[7] = EQV_B.INPUT_2_1_1[3];\r\n  tmp_4[2] = 8;\r\n  tmp_3[8] = EQV_B.INPUT_3_1_1[0];\r\n  tmp_3[9] = EQV_B.INPUT_3_1_1[1];\r\n  tmp_3[10] = EQV_B.INPUT_3_1_1[2];\r\n  tmp_3[11] = EQV_B.INPUT_3_1_1[3];\r\n  tmp_4[3] = 12;\r\n  tmp_3[12] = EQV_B.INPUT_4_1_1[0];\r\n  tmp_3[13] = EQV_B.INPUT_4_1_1[1];\r\n  tmp_3[14] = EQV_B.INPUT_4_1_1[2];\r\n  tmp_3[15] = EQV_B.INPUT_4_1_1[3];\r\n  tmp_4[4] = 16;\r\n  tmp_3[16] = EQV_B.INPUT_5_1_1[0];\r\n  tmp_3[17] = EQV_B.INPUT_5_1_1[1];\r\n  tmp_3[18] = EQV_B.INPUT_5_1_1[2];\r\n  tmp_3[19] = EQV_B.INPUT_5_1_1[3];\r\n  tmp_4[5] = 20;\r\n  tmp_3[20] = EQV_B.INPUT_6_1_1[0];\r\n  tmp_3[21] = EQV_B.INPUT_6_1_1[1];\r\n  tmp_3[22] = EQV_B.INPUT_6_1_1[2];\r\n  tmp_3[23] = EQV_B.INPUT_6_1_1[3];\r\n  tmp_4[6] = 24;\r\n  memcpy(&tmp_3[24], &EQV_B.STATE_1[0], 34U * sizeof(real_T));\r\n  tmp_4[7] = 58;\r\n  simulationData->mData->mInputValues.mN = 58;\r\n  simulationData->mData->mInputValues.mX = &tmp_3[0];\r\n  simulationData->mData->mInputOffsets.mN = 8;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_4[0];\r\n  simulationData->mData->mOutputs.mN = 1;\r\n  simulationData->mData->mOutputs.mX = &rtb_OUTPUT_1_1;\r\n  simulationData->mData->mTolerances.mN = 0;\r\n  simulationData->mData->mTolerances.mX = NULL;\r\n  simulationData->mData->mCstateHasChanged = false;\r\n  time_4 = time_tmp_0;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_4;\r\n  isHit_1 = 0;\r\n  simulationData->mData->mSampleHits.mN = 1;\r\n  simulationData->mData->mSampleHits.mX = &isHit_1;\r\n  simulationData->mData->mIsFundamentalSampleHit = true;\r\n  diagnosticManager = (NeuDiagnosticManager *)EQV_DW.OUTPUT_1_1_DiagMgr;\r\n  diagnosticTree_1 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  rowIdx = ne_simulator_method((NeslSimulator *)EQV_DW.OUTPUT_1_1_Simulator,\r\n    NESL_SIM_OUTPUTS, simulationData, diagnosticManager);\r\n  if (rowIdx != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_1;\r\n      msg_1 = rtw_diagnostics_msg(diagnosticTree_1);\r\n      rtmSetErrorStatus(EQV_M, msg_1);\r\n    }\r\n  }\r\n\r\n  EQV_Y.AMS_error_latched = EQV_DW.Memory4_PreviousInput;\r\n  EQV_Y.IMD_error_latched = EQV_DW.Memory5_PreviousInput;\r\n  EQV_Y.Current = EQV_DW.Memory1_PreviousInput;\r\n  EQV_Y.VehicleVoltage = EQV_DW.Memory2_PreviousInput;\r\n  EQV_Y.AccumulatorVoltage = EQV_DW.Memory3_PreviousInput;\r\n  EQV_Y.AirMinus = EQV_DW.Memory6_PreviousInput;\r\n  EQV_Y.AirPlus = EQV_DW.Memory7_PreviousInput;\r\n  EQV_Y.Precharge = EQV_DW.Memory8_PreviousInput;\r\n  EQV_DW.Memory_PreviousInput = rtb_Logic_idx_0;\r\n  EQV_DW.Memory_PreviousInput_m = rtb_Logic_a_idx_0;\r\n  EQV_DW.Delay1_DSTATE = EQV_U.EnablePrecharge;\r\n  EQV_DW.Delay2_DSTATE[0] = EQV_DW.Delay2_DSTATE[1];\r\n  EQV_DW.Delay3_DSTATE[0] = EQV_DW.Delay3_DSTATE[1];\r\n  EQV_DW.Delay2_DSTATE[1] = EQV_DW.Delay2_DSTATE[2];\r\n  EQV_DW.Delay3_DSTATE[1] = EQV_DW.Delay3_DSTATE[2];\r\n  EQV_DW.Delay2_DSTATE[2] = EQV_U.EnableAirPlus;\r\n  EQV_DW.Delay3_DSTATE[2] = EQV_U.EnableAirMinus;\r\n  simulationData = (NeslSimulationData *)EQV_DW.STATE_1_SimData;\r\n  time_5 = time_tmp;\r\n  simulationData->mData->mTime.mN = 1;\r\n  simulationData->mData->mTime.mX = &time_5;\r\n  simulationData->mData->mContStates.mN = 0;\r\n  simulationData->mData->mContStates.mX = NULL;\r\n  simulationData->mData->mDiscStates.mN = 18;\r\n  simulationData->mData->mDiscStates.mX = &EQV_DW.STATE_1_Discrete[0];\r\n  simulationData->mData->mModeVector.mN = 16;\r\n  simulationData->mData->mModeVector.mX = &EQV_DW.STATE_1_Modes[0];\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mFoundZcEvents = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsMajorTimeStep = true;\r\n  rtb_Logic_idx_1 = false;\r\n  simulationData->mData->mIsSolverAssertCheck = rtb_Logic_idx_1;\r\n  simulationData->mData->mIsSolverCheckingCIC = false;\r\n  simulationData->mData->mIsComputingJacobian = false;\r\n  simulationData->mData->mIsEvaluatingF0 = false;\r\n  simulationData->mData->mIsSolverRequestingReset = false;\r\n  simulationData->mData->mIsModeUpdateTimeStep = true;\r\n  tmp_6[0] = 0;\r\n  tmp_5[0] = EQV_B.INPUT_1_1_1[0];\r\n  tmp_5[1] = EQV_B.INPUT_1_1_1[1];\r\n  tmp_5[2] = EQV_B.INPUT_1_1_1[2];\r\n  tmp_5[3] = EQV_B.INPUT_1_1_1[3];\r\n  tmp_6[1] = 4;\r\n  tmp_5[4] = EQV_B.INPUT_2_1_1[0];\r\n  tmp_5[5] = EQV_B.INPUT_2_1_1[1];\r\n  tmp_5[6] = EQV_B.INPUT_2_1_1[2];\r\n  tmp_5[7] = EQV_B.INPUT_2_1_1[3];\r\n  tmp_6[2] = 8;\r\n  tmp_5[8] = EQV_B.INPUT_3_1_1[0];\r\n  tmp_5[9] = EQV_B.INPUT_3_1_1[1];\r\n  tmp_5[10] = EQV_B.INPUT_3_1_1[2];\r\n  tmp_5[11] = EQV_B.INPUT_3_1_1[3];\r\n  tmp_6[3] = 12;\r\n  tmp_5[12] = EQV_B.INPUT_4_1_1[0];\r\n  tmp_5[13] = EQV_B.INPUT_4_1_1[1];\r\n  tmp_5[14] = EQV_B.INPUT_4_1_1[2];\r\n  tmp_5[15] = EQV_B.INPUT_4_1_1[3];\r\n  tmp_6[4] = 16;\r\n  tmp_5[16] = EQV_B.INPUT_5_1_1[0];\r\n  tmp_5[17] = EQV_B.INPUT_5_1_1[1];\r\n  tmp_5[18] = EQV_B.INPUT_5_1_1[2];\r\n  tmp_5[19] = EQV_B.INPUT_5_1_1[3];\r\n  tmp_6[5] = 20;\r\n  tmp_5[20] = EQV_B.INPUT_6_1_1[0];\r\n  tmp_5[21] = EQV_B.INPUT_6_1_1[1];\r\n  tmp_5[22] = EQV_B.INPUT_6_1_1[2];\r\n  tmp_5[23] = EQV_B.INPUT_6_1_1[3];\r\n  tmp_6[6] = 24;\r\n  simulationData->mData->mInputValues.mN = 24;\r\n  simulationData->mData->mInputValues.mX = &tmp_5[0];\r\n  simulationData->mData->mInputOffsets.mN = 7;\r\n  simulationData->mData->mInputOffsets.mX = &tmp_6[0];\r\n  diagnosticManager = (NeuDiagnosticManager *)EQV_DW.STATE_1_DiagMgr;\r\n  diagnosticTree_2 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n  rowIdx = ne_simulator_method((NeslSimulator *)EQV_DW.STATE_1_Simulator,\r\n    NESL_SIM_UPDATE, simulationData, diagnosticManager);\r\n  if (rowIdx != 0) {\r\n    rtb_Logic_idx_1 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n    if (rtb_Logic_idx_1) {\r\n      char *msg_2;\r\n      msg_2 = rtw_diagnostics_msg(diagnosticTree_2);\r\n      rtmSetErrorStatus(EQV_M, msg_2);\r\n    }\r\n  }\r\n\r\n  EQV_DW.Memory4_PreviousInput = rtb_Logic_idx_0;\r\n  EQV_DW.Memory5_PreviousInput = rtb_Logic_a_idx_0;\r\n  EQV_DW.Memory1_PreviousInput = rtb_Add;\r\n  EQV_DW.Memory2_PreviousInput = rtb_OUTPUT_1_0[1];\r\n  EQV_DW.Memory3_PreviousInput = rtb_OUTPUT_1_1;\r\n  EQV_DW.Memory6_PreviousInput = rtb_Memory8;\r\n  EQV_DW.Memory7_PreviousInput = Product1;\r\n  EQV_DW.Memory8_PreviousInput = Product;\r\n  EQV_M->Timing.clockTick0++;\r\n}\r\n\r\nvoid EQV_initialize(void)\r\n{\r\n  {\r\n    NeModelParameters modelParameters;\r\n    NeModelParameters modelParameters_0;\r\n    NeModelParameters modelParameters_1;\r\n    NeslSimulationData *tmp_1;\r\n    NeslSimulator *tmp;\r\n    NeuDiagnosticManager *diagnosticManager;\r\n    NeuDiagnosticTree *diagnosticTree;\r\n    NeuDiagnosticTree *diagnosticTree_0;\r\n    NeuDiagnosticTree *diagnosticTree_1;\r\n    real_T tmp_2;\r\n    int32_T tmp_3;\r\n    boolean_T tmp_0;\r\n    tmp = nesl_lease_simulator(\"EQV/EQV/Solver Configuration_1\", 0, 0);\r\n    EQV_DW.STATE_1_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(EQV_DW.STATE_1_Simulator);\r\n    if (tmp_0) {\r\n      EQV_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"EQV/EQV/Solver Configuration_1\", 0, 0);\r\n      EQV_DW.STATE_1_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    EQV_DW.STATE_1_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    EQV_DW.STATE_1_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters.mSolverTolerance = 0.001;\r\n    modelParameters.mSolverAbsTol = 0.001;\r\n    modelParameters.mSolverRelTol = 0.001;\r\n    modelParameters.mVariableStepSolver = false;\r\n    modelParameters.mIsUsingODEN = false;\r\n    modelParameters.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters.mFixedStepSize = 0.001;\r\n    modelParameters.mStartTime = 0.0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mUseSimState = false;\r\n    modelParameters.mLinTrimCompile = false;\r\n    modelParameters.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters.mRTWModifiedTimeStamp = 5.71617938E+8;\r\n    modelParameters.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters.mIsUsingODEN = tmp_0;\r\n    modelParameters.mLoadInitialState = false;\r\n    modelParameters.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)EQV_DW.STATE_1_DiagMgr;\r\n    diagnosticTree = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = nesl_initialize_simulator((NeslSimulator *)EQV_DW.STATE_1_Simulator,\r\n      &modelParameters, diagnosticManager);\r\n    if (tmp_3 != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n      if (tmp_0) {\r\n        char *msg;\r\n        msg = rtw_diagnostics_msg(diagnosticTree);\r\n        rtmSetErrorStatus(EQV_M, msg);\r\n      }\r\n    }\r\n\r\n    tmp = nesl_lease_simulator(\"EQV/EQV/Solver Configuration_1\", 1, 0);\r\n    EQV_DW.OUTPUT_1_0_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(EQV_DW.OUTPUT_1_0_Simulator);\r\n    if (tmp_0) {\r\n      EQV_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"EQV/EQV/Solver Configuration_1\", 1, 0);\r\n      EQV_DW.OUTPUT_1_0_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    EQV_DW.OUTPUT_1_0_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    EQV_DW.OUTPUT_1_0_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_0.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_0.mSolverTolerance = 0.001;\r\n    modelParameters_0.mSolverAbsTol = 0.001;\r\n    modelParameters_0.mSolverRelTol = 0.001;\r\n    modelParameters_0.mVariableStepSolver = false;\r\n    modelParameters_0.mIsUsingODEN = false;\r\n    modelParameters_0.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters_0.mFixedStepSize = 0.001;\r\n    modelParameters_0.mStartTime = 0.0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mUseSimState = false;\r\n    modelParameters_0.mLinTrimCompile = false;\r\n    modelParameters_0.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters_0.mRTWModifiedTimeStamp = 5.71617938E+8;\r\n    modelParameters_0.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters_0.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters_0.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters_0.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters_0.mIsUsingODEN = tmp_0;\r\n    modelParameters_0.mLoadInitialState = false;\r\n    modelParameters_0.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)EQV_DW.OUTPUT_1_0_DiagMgr;\r\n    diagnosticTree_0 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = nesl_initialize_simulator((NeslSimulator *)\r\n      EQV_DW.OUTPUT_1_0_Simulator, &modelParameters_0, diagnosticManager);\r\n    if (tmp_3 != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n      if (tmp_0) {\r\n        char *msg_0;\r\n        msg_0 = rtw_diagnostics_msg(diagnosticTree_0);\r\n        rtmSetErrorStatus(EQV_M, msg_0);\r\n      }\r\n    }\r\n\r\n    tmp = nesl_lease_simulator(\"EQV/EQV/Solver Configuration_1\", 1, 1);\r\n    EQV_DW.OUTPUT_1_1_Simulator = (void *)tmp;\r\n    tmp_0 = pointer_is_null(EQV_DW.OUTPUT_1_1_Simulator);\r\n    if (tmp_0) {\r\n      EQV_627956e1_1_gateway();\r\n      tmp = nesl_lease_simulator(\"EQV/EQV/Solver Configuration_1\", 1, 1);\r\n      EQV_DW.OUTPUT_1_1_Simulator = (void *)tmp;\r\n    }\r\n\r\n    tmp_1 = nesl_create_simulation_data();\r\n    EQV_DW.OUTPUT_1_1_SimData = (void *)tmp_1;\r\n    diagnosticManager = rtw_create_diagnostics();\r\n    EQV_DW.OUTPUT_1_1_DiagMgr = (void *)diagnosticManager;\r\n    modelParameters_1.mSolverType = NE_SOLVER_TYPE_DAE;\r\n    modelParameters_1.mSolverTolerance = 0.001;\r\n    modelParameters_1.mSolverAbsTol = 0.001;\r\n    modelParameters_1.mSolverRelTol = 0.001;\r\n    modelParameters_1.mVariableStepSolver = false;\r\n    modelParameters_1.mIsUsingODEN = false;\r\n    modelParameters_1.mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_NO;\r\n    modelParameters_1.mFixedStepSize = 0.001;\r\n    modelParameters_1.mStartTime = 0.0;\r\n    modelParameters_1.mLoadInitialState = false;\r\n    modelParameters_1.mUseSimState = false;\r\n    modelParameters_1.mLinTrimCompile = false;\r\n    modelParameters_1.mLoggingMode = SSC_LOGGING_NONE;\r\n    modelParameters_1.mRTWModifiedTimeStamp = 5.71617938E+8;\r\n    modelParameters_1.mZcDisabled = true;\r\n    tmp_2 = 0.001;\r\n    modelParameters_1.mSolverTolerance = tmp_2;\r\n    tmp_2 = 0.2;\r\n    modelParameters_1.mFixedStepSize = tmp_2;\r\n    tmp_0 = false;\r\n    modelParameters_1.mVariableStepSolver = tmp_0;\r\n    tmp_0 = false;\r\n    modelParameters_1.mIsUsingODEN = tmp_0;\r\n    modelParameters_1.mLoadInitialState = false;\r\n    modelParameters_1.mZcDisabled = true;\r\n    diagnosticManager = (NeuDiagnosticManager *)EQV_DW.OUTPUT_1_1_DiagMgr;\r\n    diagnosticTree_1 = neu_diagnostic_manager_get_initial_tree(diagnosticManager);\r\n    tmp_3 = nesl_initialize_simulator((NeslSimulator *)\r\n      EQV_DW.OUTPUT_1_1_Simulator, &modelParameters_1, diagnosticManager);\r\n    if (tmp_3 != 0) {\r\n      tmp_0 = error_buffer_is_empty(rtmGetErrorStatus(EQV_M));\r\n      if (tmp_0) {\r\n        char *msg_1;\r\n        msg_1 = rtw_diagnostics_msg(diagnosticTree_1);\r\n        rtmSetErrorStatus(EQV_M, msg_1);\r\n      }\r\n    }\r\n\r\n    EQV_DW.Memory_PreviousInput = EQV_P.SRFlipFlop2_initial_condition;\r\n    EQV_DW.Memory_PreviousInput_m = EQV_P.SRFlipFlop1_initial_condition;\r\n    EQV_DW.Delay1_DSTATE = EQV_P.Delay1_InitialCondition;\r\n    EQV_DW.Delay2_DSTATE[0] = EQV_P.Delay2_InitialCondition;\r\n    EQV_DW.Delay3_DSTATE[0] = EQV_P.Delay3_InitialCondition;\r\n    EQV_DW.Delay2_DSTATE[1] = EQV_P.Delay2_InitialCondition;\r\n    EQV_DW.Delay3_DSTATE[1] = EQV_P.Delay3_InitialCondition;\r\n    EQV_DW.Delay2_DSTATE[2] = EQV_P.Delay2_InitialCondition;\r\n    EQV_DW.Delay3_DSTATE[2] = EQV_P.Delay3_InitialCondition;\r\n    EQV_DW.Memory4_PreviousInput = EQV_P.Memory4_InitialCondition;\r\n    EQV_DW.Memory5_PreviousInput = EQV_P.Memory5_InitialCondition;\r\n    EQV_DW.Memory1_PreviousInput = EQV_P.Memory1_InitialCondition;\r\n    EQV_DW.Memory2_PreviousInput = EQV_P.Memory2_InitialCondition;\r\n    EQV_DW.Memory3_PreviousInput = EQV_P.Memory3_InitialCondition;\r\n    EQV_DW.Memory6_PreviousInput = EQV_P.Memory6_InitialCondition;\r\n    EQV_DW.Memory7_PreviousInput = EQV_P.Memory7_InitialCondition;\r\n    EQV_DW.Memory8_PreviousInput = EQV_P.Memory8_InitialCondition;\r\n  }\r\n}\r\n\r\nvoid EQV_terminate(void)\r\n{\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)EQV_DW.STATE_1_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)EQV_DW.STATE_1_SimData);\r\n  nesl_erase_simulator(\"EQV/EQV/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    EQV_DW.OUTPUT_1_0_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)EQV_DW.OUTPUT_1_0_SimData);\r\n  nesl_erase_simulator(\"EQV/EQV/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n  neu_destroy_diagnostic_manager((NeuDiagnosticManager *)\r\n    EQV_DW.OUTPUT_1_1_DiagMgr);\r\n  nesl_destroy_simulation_data((NeslSimulationData *)EQV_DW.OUTPUT_1_1_SimData);\r\n  nesl_erase_simulator(\"EQV/EQV/Solver Configuration_1\");\r\n  nesl_destroy_registry();\r\n}\r\n"},{"name":"EQV.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_EQV_h_\r\n#define RTW_HEADER_EQV_h_\r\n#ifndef EQV_COMMON_INCLUDES_\r\n#define EQV_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"nesl_rtw.h\"\r\n#include \"EQV_627956e1_1_gateway.h\"\r\n#endif\r\n\r\n#include \"EQV_types.h\"\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\ntypedef struct {\r\n  real_T INPUT_1_1_1[4];\r\n  real_T INPUT_2_1_1[4];\r\n  real_T INPUT_3_1_1[4];\r\n  real_T INPUT_4_1_1[4];\r\n  real_T INPUT_5_1_1[4];\r\n  real_T INPUT_6_1_1[4];\r\n  real_T STATE_1[34];\r\n} B_EQV_T;\r\n\r\ntypedef struct {\r\n  real_T INPUT_1_1_1_Discrete[2];\r\n  real_T INPUT_2_1_1_Discrete[2];\r\n  real_T Delay1_DSTATE;\r\n  real_T INPUT_3_1_1_Discrete[2];\r\n  real_T Delay2_DSTATE[3];\r\n  real_T INPUT_4_1_1_Discrete[2];\r\n  real_T INPUT_5_1_1_Discrete[2];\r\n  real_T Delay3_DSTATE[3];\r\n  real_T INPUT_6_1_1_Discrete[2];\r\n  real_T STATE_1_Discrete[18];\r\n  real_T OUTPUT_1_0_Discrete;\r\n  real_T OUTPUT_1_1_Discrete;\r\n  real_T Memory4_PreviousInput;\r\n  real_T Memory5_PreviousInput;\r\n  real_T Memory1_PreviousInput;\r\n  real_T Memory2_PreviousInput;\r\n  real_T Memory3_PreviousInput;\r\n  real_T Memory6_PreviousInput;\r\n  real_T Memory7_PreviousInput;\r\n  real_T Memory8_PreviousInput;\r\n  void* STATE_1_Simulator;\r\n  void* STATE_1_SimData;\r\n  void* STATE_1_DiagMgr;\r\n  void* STATE_1_ZcLogger;\r\n  void* STATE_1_TsInfo;\r\n  void* OUTPUT_1_0_Simulator;\r\n  void* OUTPUT_1_0_SimData;\r\n  void* OUTPUT_1_0_DiagMgr;\r\n  void* OUTPUT_1_0_ZcLogger;\r\n  void* OUTPUT_1_0_TsInfo;\r\n  void* OUTPUT_1_1_Simulator;\r\n  void* OUTPUT_1_1_SimData;\r\n  void* OUTPUT_1_1_DiagMgr;\r\n  void* OUTPUT_1_1_ZcLogger;\r\n  void* OUTPUT_1_1_TsInfo;\r\n  int_T STATE_1_Modes[16];\r\n  int_T OUTPUT_1_0_Modes;\r\n  int_T OUTPUT_1_1_Modes;\r\n  boolean_T Memory_PreviousInput;\r\n  boolean_T Memory_PreviousInput_m;\r\n  boolean_T STATE_1_FirstOutput;\r\n  boolean_T OUTPUT_1_0_FirstOutput;\r\n  boolean_T OUTPUT_1_1_FirstOutput;\r\n} DW_EQV_T;\r\n\r\ntypedef struct {\r\n  boolean_T AMS_error;\r\n  boolean_T AMS_error_reset;\r\n  boolean_T IMD_error;\r\n  boolean_T IMD_error_reset;\r\n  real_T SC;\r\n  real_T y;\r\n  real_T EnableAirMinus;\r\n  real_T EnableAirPlus;\r\n  real_T EnablePrecharge;\r\n  real_T y_f;\r\n  real_T CurrentLevel;\r\n  real_T VoltageLevel;\r\n} ExtU_EQV_T;\r\n\r\ntypedef struct {\r\n  real_T AMS_error_latched;\r\n  real_T IMD_error_latched;\r\n  real_T Current;\r\n  real_T VehicleVoltage;\r\n  real_T AccumulatorVoltage;\r\n  real_T AirMinus;\r\n  real_T AirPlus;\r\n  real_T Precharge;\r\n} ExtY_EQV_T;\r\n\r\nstruct P_EQV_T_ {\r\n  boolean_T SRFlipFlop2_initial_condition;\r\n  boolean_T SRFlipFlop1_initial_condition;\r\n  real_T Delay1_InitialCondition;\r\n  real_T Delay2_InitialCondition;\r\n  real_T Delay3_InitialCondition;\r\n  real_T Memory4_InitialCondition;\r\n  real_T Memory5_InitialCondition;\r\n  real_T Memory1_InitialCondition;\r\n  real_T Memory2_InitialCondition;\r\n  real_T Memory3_InitialCondition;\r\n  real_T Memory6_InitialCondition;\r\n  real_T Memory7_InitialCondition;\r\n  real_T Memory8_InitialCondition;\r\n  boolean_T Logic_table[16];\r\n  boolean_T Logic_table_f[16];\r\n};\r\n\r\nstruct tag_RTM_EQV_T {\r\n  const char_T * volatile errorStatus;\r\n  struct {\r\n    uint32_T clockTick0;\r\n  } Timing;\r\n};\r\n\r\nextern P_EQV_T EQV_P;\r\nextern B_EQV_T EQV_B;\r\nextern DW_EQV_T EQV_DW;\r\nextern ExtU_EQV_T EQV_U;\r\nextern ExtY_EQV_T EQV_Y;\r\nextern void EQV_initialize(void);\r\nextern void EQV_step(void);\r\nextern void EQV_terminate(void);\r\nextern RT_MODEL_EQV_T *const EQV_M;\r\n\r\n#endif\r\n\r\n"},{"name":"EQV_private.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_EQV_private_h_\r\n#define RTW_HEADER_EQV_private_h_\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n"},{"name":"EQV_types.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_EQV_types_h_\r\n#define RTW_HEADER_EQV_types_h_\r\n\r\ntypedef struct P_EQV_T_ P_EQV_T;\r\ntypedef struct tag_RTM_EQV_T RT_MODEL_EQV_T;\r\n\r\n#endif\r\n\r\n"},{"name":"EQV_data.c","type":"source","group":"data","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Data files","code":"#include \"EQV.h\"\r\n\r\nP_EQV_T EQV_P = {\r\n\r\n  false,\r\n\r\n  false,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n\r\n  { false, true, false, false, true, true, false, false, true, false, true, true,\r\n    false, false, false, false },\r\n\r\n\r\n  { false, true, false, false, true, true, false, false, true, false, true, true,\r\n    false, false, false, false }\r\n};\r\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_backsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      backward substitution: solving Ux=b for real\r\n *      double precision float operands.\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\r\n * Abstract: Backward substitution: Solving Ux=b \r\n *           U: real, double\r\n *           b: real, double\r\n *           U is an upper (or unit upper) triangular full matrix.\r\n *           The entries in the lower triangle are ignored.\r\n *           U is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                   const real_T    *pb,\r\n                                   real_T          *x,\r\n                                   int_T            N,\r\n                                   int_T            P,\r\n                                   boolean_T        unit_upper)\r\n{\r\n  int_T i,k;\r\n  for(k=P; k>0; k--) {\r\n    real_T *pUcol = pU;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N-1;\r\n      real_T s = 0.0;\r\n      real_T *pUrow = pUcol--;          /* access current row of U */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pUrow * *xj--;\r\n          pUrow -= N;\r\n        }\r\n      }\r\n\r\n      if (unit_upper) {\r\n        *xj = *pb-- - s;\r\n      } else {\r\n        *xj = (*pb-- - s) / *pUrow;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_backsubrr_dbl.c */\r\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_forwardsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      forward substitution: solving Lx=b\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\r\n * Abstract: Forward substitution: solving Lx=b \r\n *           L: Real, double\r\n *           b: Real, double\r\n *           L is a lower (or unit lower) triangular full matrix.\r\n *           The entries in the upper triangle are ignored.\r\n *           L is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                  const real_T  *pb,\r\n                                  real_T        *x,\r\n                                  int_T          N,\r\n                                  int_T          P,\r\n                                  const int32_T *piv,\r\n                                  boolean_T      unit_lower)\r\n{  \r\n  /* Real inputs: */\r\n  int_T i, k;\r\n  for(k=0; k<P; k++) {\r\n    real_T *pLcol = pL;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N;\r\n      real_T s = 0.0;\r\n      real_T *pLrow = pLcol++;          /* access current row of L */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pLrow * *xj;\r\n          pLrow += N;\r\n          xj++;\r\n        }\r\n      }\r\n\r\n      if (unit_lower) {\r\n        *xj = pb[piv[i]] - s;\r\n      } else {\r\n        *xj = (pb[piv[i]] - s) / *pLrow;\r\n      }\r\n    }\r\n    pb += N;\r\n  }\r\n}\r\n\r\n/* [EOF] rt_forwardsubrr_dbl.c */\r\n"},{"name":"rt_lu_real.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_lu_real.c     \r\n *\r\n * Abstract:\r\n *      Real-Time Workshop support routine for lu_real\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_lu_real  =======================================================\r\n * Abstract: A is real.\r\n *\r\n */\r\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\r\n                const int_T n,     /* number or rows = number of columns */\r\n                int32_T     *piv)  /* pivote vector                      */\r\n{\r\n  int_T k;\r\n\r\n  /* initialize row-pivot indices: */\r\n  for (k = 0; k < n; k++) {\r\n    piv[k] = k;\r\n  }\r\n\r\n  /* Loop over each column: */\r\n  for (k = 0; k < n; k++) {\r\n    const int_T kn = k*n;\r\n    int_T p = k;\r\n\r\n    /* Scan the lower triangular part of this column only\r\n     * Record row of largest value\r\n     */\r\n    {\r\n      int_T i;\r\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\r\n      for (i = k+1; i < n; i++) {\r\n        real_T q = fabs(A[i+kn]);\r\n        if (q > Amax) {p = i; Amax = q;}\r\n      }\r\n    }\r\n\r\n    /* swap rows if required */\r\n    if (p != k) {\r\n      int_T j;\r\n      int32_T t1;\r\n      for (j = 0; j < n; j++) {\r\n        real_T t;\r\n        const int_T j_n = j*n;\r\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\r\n      }\r\n      /* swap pivot row indices */\r\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\r\n    }\r\n\r\n    /* column reduction */\r\n    {\r\n      real_T Adiag = A[k+kn];\r\n      int_T i,j;\r\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\r\n\r\n        /* divide lower triangular part of column by max */\r\n        Adiag = 1.0/Adiag;\r\n        for (i = k+1; i < n; i++) {\r\n          A[i+kn] *= Adiag;\r\n        }\r\n\r\n        /* subtract multiple of column from remaining columns */\r\n        for (j = k+1; j < n; j++) {\r\n          int_T j_n = j*n;\r\n          for (i = k+1; i < n; i++) {\r\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_lu_real.c */\r\n"},{"name":"rt_matrixlib.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef rt_matrixlib_h\r\n#define rt_matrixlib_h\r\n\r\n/* Copyright 2007-2013 The MathWorks, Inc.\r\n *\r\n * File    : rt_matrixlib.h\r\n * Abstract:\r\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\r\n *\r\n */\r\n\r\n\r\n/*==========*\r\n * Includes *\r\n *==========*/\r\n\r\n#include \"rtwtypes.h\"\r\n#include <limits.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* Matrix Multiplication Utility Functions */\r\nextern void rt_MatMultRR_Dbl(real_T         *y, \r\n                             const real_T   *A, \r\n                             const real_T   *B, \r\n                             const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Dbl(creal_T       *y,\r\n                             const real_T  *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCR_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const real_T  *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCC_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultRR_Sgl(real32_T       *y,\r\n                             const real32_T *A,\r\n                             const real32_T *B,\r\n                             const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\r\n                             const real32_T  *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const real32_T  *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\r\n                                   const real_T *A,\r\n                                   const real_T *B,\r\n                                   const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\r\n                                   const real_T  *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const real_T  *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n#endif\r\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\r\n                                   const real32_T *A,\r\n                                   const real32_T *B,\r\n                                   const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\r\n                                   const real32_T  *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const real32_T  *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n#endif \r\n\r\n/* Matrix Inversion Utility Functions */\r\nextern void rt_lu_real(real_T      *A,\r\n                       const int_T n,\r\n                       int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx(creal_T *A,\r\n                       const int_T n,\r\n                       int32_T *piv);\r\n#endif\r\n\r\nextern void rt_lu_real_sgl(real32_T      *A,\r\n                           const int_T n,\r\n                           int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx_sgl(creal32_T *A,\r\n                           const int_T n,\r\n                           int32_T *piv);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                          const real_T    *pb,\r\n                                          real_T          *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                         const real_T  *pb,\r\n                                         real_T        *x,\r\n                                         int_T          N,\r\n                                         int_T          P,\r\n                                         const int32_T *piv,\r\n                                         boolean_T      unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\r\n                                         const real_T    *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\r\n                                          const real32_T    *pb,\r\n                                          real32_T          *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\r\n                                         const real32_T    *pb,\r\n                                         real32_T    *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\r\n                                         const real32_T    *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\n\r\nextern void rt_MatDivRR_Dbl(real_T        *Out,\r\n                            const real_T  *In1,\r\n                            const real_T  *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            real_T        *x,\r\n                            const int_T    dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\r\n                            const real_T  *In1,\r\n                            const creal_T *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const real_T  *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const creal_T *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n#endif\r\n\r\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\r\n                            const real32_T  *In1,\r\n                            const real32_T  *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            real32_T        *x,\r\n                            const int_T      dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\r\n                            const real32_T  *In1,\r\n                            const creal32_T *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const real32_T  *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const creal32_T *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n#endif\r\n\r\n\r\n/* Matrix multiplication defines */\r\n\r\n/* Quick (approximate) complex absolute value: */\r\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\r\n\r\n/* Quick (approximate) complex absolute value for singles: */\r\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \r\n\r\n#ifdef CREAL_T\r\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\r\n                                const creal_T In1,\r\n                                const creal_T In2);\r\n\r\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\r\n                                  const creal_T In1,\r\n                                  const creal_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\r\n                                     const creal_T In1);\r\n\r\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\r\n                                const creal32_T In1,\r\n                                const creal32_T In2);\r\n\r\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\r\n                                  const creal32_T In1,\r\n                                  const creal32_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\r\n                                     const creal32_T In1);\r\n\r\n#endif\r\n\r\nextern real_T rt_Hypot_Dbl(real_T In1,\r\n                           real_T In2);\r\n\r\nextern real32_T rt_Hypot_Sgl(real32_T In1,\r\n                             real32_T In2);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* rt_matrixlib_h */\r\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\r\n *\r\n * File: rt_matrixlib_dbl.c\r\n *\r\n * Abstract:\r\n *      Simulink Coder utility functions\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n#ifdef CREAL_T\r\nvoid rt_ComplexTimes_Dbl(creal_T* c,\r\n                         const creal_T a,\r\n                         const creal_T b)\r\n{\r\n    if (a.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.re * b.im;\r\n        if (b.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (b.re == 0.0 || a.re == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else if (b.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0 || a.re == 0.0) { \r\n            c->re = 0.0;\r\n        }\r\n    } else if (a.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0) {\r\n            c->im = 0.0;\r\n        }\r\n    } else if (b.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.re * b.im;\r\n    } else {\r\n        c->re = a.re * b.re - a.im * b.im;\r\n        c->im = a.re * b.im + a.im * b.re;\r\n    }\r\n}\r\n\r\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\r\n                           const creal_T a,\r\n                           const creal_T b)\r\n{\r\n    if (b.im == 0.0) {\r\n        c->re = a.re / b.re;\r\n        if (a.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else { /* a.im != 0.0 */\r\n            c->im = a.im / b.re;\r\n            if (a.re == 0.0) {\r\n                c->re = 0.0;\r\n            }\r\n        }\r\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\r\n        c->re = a.im / b.im;\r\n        c->im = -a.re / b.im;\r\n        if (a.re == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (a.im == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else {\r\n        real_T brm = fabs(b.re);\r\n        real_T bim = fabs(b.im);\r\n        if (brm > bim) {\r\n            real_T s = b.im / b.re;\r\n            real_T d = b.re + s * b.im;\r\n            c->im = (a.im - s * a.re) / d;\r\n            c->re = (a.re + s * a.im) / d;\r\n        } else if (brm == bim) {\r\n            real_T half = 0.5;\r\n            real_T sgnbr = b.re > 0.0 ? half : -half;\r\n            real_T sgnbi = b.im > 0.0 ? half : -half;\r\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\r\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\r\n        } else {\r\n            real_T s = b.re / b.im;\r\n            real_T d = b.im + s * b.re;\r\n            c->im = (s * a.im - a.re) / d;\r\n            c->re = (s * a.re + a.im) / d;\r\n        }\r\n    }\r\n}\r\n\r\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\r\n                              const creal_T In1)\r\n{\r\n    creal_T y;\r\n    y.re = 1.0;\r\n    y.im = 0.0;\r\n\r\n    rt_ComplexRDivide_Dbl(Out, y, In1);\r\n}\r\n\r\n#endif\r\n\r\n\r\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\r\n{\r\n    real_T y;\r\n    if (a != a || b != b) {\r\n        y = a + b;\r\n    } else {\r\n        real_T t;\r\n        if (fabs(a) > fabs(b)) {\r\n            t = b/a;\r\n            y = fabs(a)*sqrt(1.0 + t*t);\r\n        } else {\r\n            if (b == 0.0) {\r\n                y = 0.0;\r\n            } else {\r\n                t = a/b;\r\n                y = fabs(b)*sqrt(1.0 + t*t);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return y;\r\n}\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n"},{"name":"EQV_627956e1_1.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_std.h\"\r\n#include \"pm_default_allocator.h\"\r\n#include \"ne_dae_fwd.h\"\r\n#include \"ne_profiler_fwd.h\"\r\n#include \"ne_dae_construct.h\"\r\n#include \"nesl_la.h\"\r\n#include \"EQV_627956e1_1.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n\r\nvoid EQV_627956e1_1_dae( NeDae **dae, const NeModelParameters *modelParams,\r\n  const NeSolverParameters *solverParams)\r\n{\r\n  PmAllocator *ne_allocator;\r\n  const McLinearAlgebraFactory *linear_algebra_ptr =\r\n    (solverParams->mLinearAlgebra == NE_FULL_LA) ?\r\n    get_rtw_linear_algebra() :\r\n    ((solverParams->mLinearAlgebra == NE_SPARSE_LA) ?\r\n     mc_get_csparse_linear_algebra() :\r\n     get_auto_linear_algebra());\r\n  NeRtpValues *rtpValues = NULL;\r\n  ne_allocator = pm_default_allocator();\r\n  ne_dae_create( dae,\r\n                EQV_627956e1_1_dae_ds( ne_allocator ),\r\n                NULL,\r\n                FALSE,\r\n                rtpValues,\r\n                *solverParams,\r\n                *modelParams,\r\n                linear_algebra_ptr,\r\n                NULL,\r\n                NULL,\r\n                NULL,\r\n                ne_allocator,\r\n                DAEMON_CHOICE_NONE);\r\n}\r\n"},{"name":"EQV_627956e1_1.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __EQV_627956e1_1_h__\r\n#define __EQV_627956e1_1_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void EQV_627956e1_1_dae( NeDae **dae, const NeModelParameters\r\n    *modelParams,\r\n    const NeSolverParameters *solverParams);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n/* EQV_627956e1_1_ds.c - body for module EQV_627956e1_1_ds */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_zc.h\"\r\n#include \"EQV_627956e1_1_ds_obs_il.h\"\r\n#include \"EQV_627956e1_1_ds_obs_all.h\"\r\n#include \"EQV_627956e1_1_ds_obs_act.h\"\r\n#include \"EQV_627956e1_1_ds_log.h\"\r\n#include \"EQV_627956e1_1_ds_tdxf_p.h\"\r\n#include \"EQV_627956e1_1_ds_dxf_p.h\"\r\n#include \"EQV_627956e1_1_ds_dxf.h\"\r\n#include \"EQV_627956e1_1_ds_mode.h\"\r\n#include \"EQV_627956e1_1_ds_f.h\"\r\n#include \"EQV_627956e1_1_ds_assert.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"ssc_ml_fun.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n\r\nstatic int32_T ds_m_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_m(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dum_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dum(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_a_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_a(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_b_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_b(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_c_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_c(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_vmf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vpf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_vsf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_slf0(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_duf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dpdxf(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dwf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_tduf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dnf_v_x(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cer(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxcer_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddcer(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddcer_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ic(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_icr(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_im(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_id(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icr_il(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduicr_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_icrm(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_ddicrm(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_freqs(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_mdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tduy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_tdxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_y(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                    NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_duy_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_duy(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_dty_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dty(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_cache_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_r(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_update2_i(const NeDynamicSystem *ds, const\r\n  NeDynamicSystemInput *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lock2_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_sfo(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_sfp(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_init_r(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_init_i(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_passert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_iassert(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_t(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_v0(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_del_tmax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dxdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dudelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dtdelt(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_obs_exp(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_l(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_i(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_j(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dp_r(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qx(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qu(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qt(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_q1(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_qx_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qu_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_qt_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_q1_p(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_var_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput *\r\n  in, NeDsMethodOutput *out);\r\nstatic int32_T ds_eq_tol(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_lv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                     NeDsMethodOutput *out);\r\nstatic int32_T ds_slv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                      NeDsMethodOutput *out);\r\nstatic int32_T ds_nldv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_sclv(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_imin(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_imax(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n  NeDsMethodOutput *out);\r\nstatic int32_T ds_dimin(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic int32_T ds_dimax(const NeDynamicSystem *ds, const NeDynamicSystemInput\r\n  *in, NeDsMethodOutput *out);\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_freqs(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator);\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator);\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator);\r\nstatic void release_reference(NeDynamicSystem *ds);\r\nstatic void get_reference(NeDynamicSystem *ds);\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T);\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp);\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr);\r\nstatic NeEquationData s_equation_data[16] = { { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Capacitor\", 1U, 0U, TRUE, 1.0, \"1\", }, {\r\n    \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Diode\", 1U, 1U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Diode\", 3U, 2U, TRUE, 1.0,\r\n    \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Resistor\", 1U, 5U,\r\n    TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"EQV/EQV/SPMT Switch\", 3U, 6U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/SPMT Switch\", 5U, 9U, TRUE, 1.0, \"1\", }, {\r\n    \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/SPMT Switch\", 7U, 14U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/SPMT Switch\", 9U,\r\n    21U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"EQV/EQV/SPMT Switch\", 11U, 30U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/SPMT Switch\", 13U, 41U, TRUE, 1.0, \"1\", },\r\n  { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/SPMT Switch\", 15U, 54U, TRUE,\r\n    1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/SPMT Switch\",\r\n    15U, 69U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME,\r\n    \"EQV/EQV/SPMT Switch\", 11U, 84U, TRUE, 1.0, \"1\", }, { \"\", 0U, 8,\r\n    NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Switch\", 3U, 95U, TRUE, 1.0, \"1\", }, { \"\",\r\n    0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Switch1\", 3U, 98U, TRUE, 1.0, \"1\",\r\n  }, { \"\", 0U, 8, NE_EQUATION_DOMAIN_TIME, \"EQV/EQV/Switch2\", 3U, 101U, TRUE,\r\n    1.0, \"1\", } };\r\n\r\nstatic NeCERData *s_cer_data = NULL;\r\nstatic NeICRData *s_icr_data = NULL;\r\nstatic NeVariableData s_variable_data[16] = { { \"EQV.Capacitor.vc\", 0U, 0,\r\n    \"EQV/EQV/Capacitor\", 1.0, \"1\", 0.0, TRUE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_MANDATORY, \"Capacitor voltage\", }, {\r\n    \"EQV.Diode.private.Cjunction.vc\", 0U, 0, \"EQV/EQV/Diode\", 1.0, \"1\", 0.0,\r\n    TRUE, FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Capacitor voltage\", }, {\r\n    \"EQV.Capacitor.i\", 0U, 0, \"EQV/EQV/Capacitor\", 1.0, \"1\", 0.0, FALSE, FALSE,\r\n      { { 1, 1 } }, NE_INIT_MODE_NONE, \"Current\", }, { \"EQV.Capacitor.n.v\", 0U,\r\n    1, \"EQV/EQV/Capacitor\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage\", }, { \"EQV.Resistor.i\", 0U, 0,\r\n    \"EQV/EQV/Resistor\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Current\", }, { \"EQV.Switch2.i\", 0U, 0, \"EQV/EQV/Switch2\",\r\n    1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Current\", },\r\n    { \"EQV.Diode.i_capacitor\", 0U, 0, \"EQV/EQV/Diode\", 1.0, \"1\", 0.0, FALSE,\r\n    FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Junction capacitance current\", }, {\r\n    \"EQV.Switch1.v\", 0U, 0, \"EQV/EQV/Switch1\", 1.0, \"1\", 0.0, FALSE, FALSE, { {\r\n        1, 1 } }, NE_INIT_MODE_NONE, \"Voltage\", }, { \"EQV.Resistor.p.v\", 0U, 1,\r\n    \"EQV/EQV/Resistor\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage\", }, { \"EQV.SPMT_Switch.connected_port_index\",\r\n    0U, 0, \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Connected port index\", }, { \"EQV.SPMT_Switch.v1\", 0U, 0,\r\n    \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n1)\", }, { \"EQV.SPMT_Switch.v4\", 0U, 0,\r\n    \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n4)\", }, { \"EQV.SPMT_Switch.v5\", 0U, 0,\r\n    \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n5)\", }, { \"EQV.SPMT_Switch.v6\", 0U, 0,\r\n    \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n6)\", }, { \"EQV.SPMT_Switch.v7\", 0U, 0,\r\n    \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n7)\", }, { \"EQV.SPMT_Switch.v8\", 0U, 0,\r\n    \"EQV/EQV/SPMT Switch\", 1.0, \"1\", 0.0, FALSE, FALSE, { { 1, 1 } },\r\n    NE_INIT_MODE_NONE, \"Voltage (p -> n8)\", } };\r\n\r\nstatic NeVariableData s_discrete_data[1] = { {\r\n    \"EQV.SPMT_Switch.stuck_port_index\", 0U, 0, \"EQV/EQV/SPMT Switch\", 1.0, \"1\",\r\n    0.0, FALSE, FALSE, { { 1, 1 } }, NE_INIT_MODE_NONE, \"Stuck port index\", } };\r\n\r\nstatic NeObservableData s_observable_data[112] = { { \"EQV.Capacitor.i\",\r\n    \"EQV/EQV/Capacitor\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"EQV.Capacitor.n.v\", \"EQV/EQV/Capacitor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Capacitor.p.v\",\r\n    \"EQV/EQV/Capacitor\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Capacitor.v\", \"EQV/EQV/Capacitor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Capacitor.vc\",\r\n    \"EQV/EQV/Capacitor\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_MANDATORY, FALSE, TRUE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Capacitor voltage\", }, { \"EQV.Capacitor.power_dissipated\",\r\n    \"EQV/EQV/Capacitor\", { { 1, 1 } }, \"kW\", 1.0e-6, \"kW\",\r\n    NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"EQV.Controlled_Voltage_Source.i\", \"EQV/EQV/Controlled Voltage Source\", { {\r\n        1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"EQV.Controlled_Voltage_Source.n.v\", \"EQV/EQV/Controlled Voltage Source\", {\r\n        { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    TRUE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Controlled_Voltage_Source.p.v\", \"EQV/EQV/Controlled Voltage Source\", {\r\n        { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Controlled_Voltage_Source.v\", \"EQV/EQV/Controlled Voltage Source\", { {\r\n        1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"EQV.Controlled_Voltage_Source.vT\", \"EQV/EQV/Controlled Voltage Source\", { {\r\n        1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"EQV.Controlled_Voltage_Source1.i\", \"EQV/EQV/Controlled Voltage Source1\", {\r\n        { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"i\", }, {\r\n    \"EQV.Controlled_Voltage_Source1.n.v\", \"EQV/EQV/Controlled Voltage Source1\",\r\n      { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Controlled_Voltage_Source1.p.v\", \"EQV/EQV/Controlled Voltage Source1\",\r\n      { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Controlled_Voltage_Source1.v\", \"EQV/EQV/Controlled Voltage Source1\", {\r\n        { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"v\", }, {\r\n    \"EQV.Controlled_Voltage_Source1.vT\", \"EQV/EQV/Controlled Voltage Source1\", {\r\n      { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"EQV.Current_Sensor.I\", \"EQV/EQV/Current Sensor\", { { 1, 1 } }, \"A\", 1.0,\r\n    \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"I\", }, { \"EQV.Current_Sensor.i1\",\r\n    \"EQV/EQV/Current Sensor\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"EQV.Current_Sensor.n.v\",\r\n    \"EQV/EQV/Current Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Current_Sensor.p.v\",\r\n    \"EQV/EQV/Current Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Current_Sensor_I\",\r\n    \"EQV/EQV/PS-Simulink\\nConverter\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current_Sensor_I\", }, {\r\n    \"EQV.Diode.private.Cjunction.i\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"A\", 1.0,\r\n    \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current\", }, {\r\n    \"EQV.Diode.private.Cjunction.n.v\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Diode.private.Cjunction.p.v\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Diode.private.Cjunction.v\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Diode.private.Cjunction.vc\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, TRUE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Capacitor voltage\", }, {\r\n    \"EQV.Diode.Tsim\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"K\", 1.0, \"K\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Tsim\", }, { \"EQV.Diode.fault_input\",\r\n    \"EQV/EQV/Diode\", { { 1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_DERIVED,\r\n    NE_INIT_MODE_NONE, TRUE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Input fault trigger\", }, { \"EQV.Diode.i\", \"EQV/EQV/Diode\", { { 1, 1 } },\r\n    \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"EQV.Diode.i_capacitor\",\r\n    \"EQV/EQV/Diode\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Junction capacitance current\", }, { \"EQV.Diode.i_diode\", \"EQV/EQV/Diode\", {\r\n      { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode current\",\r\n  }, { \"EQV.Diode.i_out\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Diode current output\", }, {\r\n    \"EQV.Diode.v_diode\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Intrinsic diode voltage\", }, {\r\n    \"EQV.Diode.n.v\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Diode.ni.v\",\r\n    \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Diode.p.v\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Diode.power_dissipated\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"W\", 1.0, \"kW\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"power_dissipated\", }, { \"EQV.Diode.v\",\r\n    \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Diode.v_capacitor\", \"EQV/EQV/Diode\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Junction capacitance voltage\", }, {\r\n    \"EQV.Electrical_Reference.V.v\", \"EQV/EQV/Electrical Reference\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Resistor.i\",\r\n    \"EQV/EQV/Resistor\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"EQV.Resistor.n.v\", \"EQV/EQV/Resistor\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Resistor.p.v\",\r\n    \"EQV/EQV/Resistor\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Resistor.v\", \"EQV/EQV/Resistor\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Resistor.power_dissipated\", \"EQV/EQV/Resistor\", { { 1, 1 } }, \"A^2*Ohm\",\r\n    1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"EQV.Resistor1.i\", \"EQV/EQV/Resistor1\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"EQV.Resistor1.n.v\",\r\n    \"EQV/EQV/Resistor1\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Resistor1.p.v\", \"EQV/EQV/Resistor1\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Resistor1.v\",\r\n    \"EQV/EQV/Resistor1\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Resistor1.power_dissipated\", \"EQV/EQV/Resistor1\", { { 1,\r\n        1 } }, \"A^2*Ohm\", 1.0e-6, \"A^2*Ohm\", NE_NOMINAL_SOURCE_NONE,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE,\r\n    \"power_dissipated\", }, { \"EQV.SPMT_Switch.connected_port_index\",\r\n    \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Connected port index\", }, {\r\n    \"EQV.SPMT_Switch.i1\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> n1)\", }, {\r\n    \"EQV.SPMT_Switch.i2\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> n2)\", }, {\r\n    \"EQV.SPMT_Switch.i3\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> n3)\", }, {\r\n    \"EQV.SPMT_Switch.i4\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n4)\", }, {\r\n    \"EQV.SPMT_Switch.i5\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n5)\", }, {\r\n    \"EQV.SPMT_Switch.i6\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n6)\", }, {\r\n    \"EQV.SPMT_Switch.i7\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n7)\", }, {\r\n    \"EQV.SPMT_Switch.i8\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Current (p -> n8)\", }, {\r\n    \"EQV.SPMT_Switch.icom\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current (p -> all)\", }, {\r\n    \"EQV.SPMT_Switch.n1.v\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.SPMT_Switch.n2.v\",\r\n    \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.SPMT_Switch.n3.v\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.SPMT_Switch.n4.v\",\r\n    \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"EQV.SPMT_Switch.n5.v\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, { \"EQV.SPMT_Switch.n6.v\",\r\n    \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"EQV.SPMT_Switch.n7.v\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage\", }, { \"EQV.SPMT_Switch.n8.v\",\r\n    \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Voltage\", }, { \"EQV.SPMT_Switch.p.v\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } },\r\n    \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.SPMT_Switch.power_dissipated\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"W\",\r\n    1.0, \"kW\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Power dissipated\", }, {\r\n    \"EQV.SPMT_Switch.stuck_port_index\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"1\",\r\n    1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Stuck port index\", }, {\r\n    \"EQV.SPMT_Switch.v1\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage (p -> n1)\", }, {\r\n    \"EQV.SPMT_Switch.v2\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage (p -> n2)\", }, {\r\n    \"EQV.SPMT_Switch.v3\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage (p -> n3)\", }, {\r\n    \"EQV.SPMT_Switch.v4\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n4)\", }, {\r\n    \"EQV.SPMT_Switch.v5\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n5)\", }, {\r\n    \"EQV.SPMT_Switch.v6\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n6)\", }, {\r\n    \"EQV.SPMT_Switch.v7\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n7)\", }, {\r\n    \"EQV.SPMT_Switch.v8\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage (p -> n8)\", }, {\r\n    \"EQV.SPMT_Switch.vT\", \"EQV/EQV/SPMT Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"vT\", }, {\r\n    \"EQV.Simulink_PS_Converter1_output\", \"EQV/EQV/Simulink-PS\\nConverter1\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter1_output\", }, { \"EQV.Simulink_PS_Converter2_output\",\r\n    \"EQV/EQV/Simulink-PS\\nConverter2\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter2_output\", }, {\r\n    \"EQV.Simulink_PS_Converter3_output\", \"EQV/EQV/Simulink-PS\\nConverter3\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter3_output\", }, { \"EQV.Simulink_PS_Converter4_output\",\r\n    \"EQV/EQV/Simulink-PS\\nConverter4\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter4_output\", }, {\r\n    \"EQV.Simulink_PS_Converter5_output\", \"EQV/EQV/Simulink-PS\\nConverter5\", { {\r\n        1, 1 } }, \"1\", 1.0, \"1\", NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE,\r\n    FALSE, FALSE, NE_FREQTIME_TYPE_TIME, FALSE, TRUE,\r\n    \"Simulink_PS_Converter5_output\", }, { \"EQV.Simulink_PS_Converter_output\",\r\n    \"EQV/EQV/Simulink-PS\\nConverter\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_FIXED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Simulink_PS_Converter_output\", }, {\r\n    \"EQV.Switch.i\", \"EQV/EQV/Switch\", { { 1, 1 } }, \"A\", 1.0, \"A\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Current\", }, { \"EQV.Switch.n.v\",\r\n    \"EQV/EQV/Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, TRUE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\",\r\n  }, { \"EQV.Switch.p.v\", \"EQV/EQV/Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Switch.v\",\r\n    \"EQV/EQV/Switch\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Switch.power_dissipated\", \"EQV/EQV/Switch\", { { 1, 1 }\r\n    }, \"A*V\", 1.0e-6, \"A*V\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE,\r\n    FALSE, NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"EQV.Switch.vT\", \"EQV/EQV/Switch\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, { \"EQV.Switch1.i\",\r\n    \"EQV/EQV/Switch1\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"EQV.Switch1.n.v\", \"EQV/EQV/Switch1\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Switch1.p.v\",\r\n    \"EQV/EQV/Switch1\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Switch1.v\", \"EQV/EQV/Switch1\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Switch1.power_dissipated\", \"EQV/EQV/Switch1\", { { 1, 1 } }, \"A*V\",\r\n    1.0e-6, \"A*V\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"EQV.Switch1.vT\", \"EQV/EQV/Switch1\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, { \"EQV.Switch2.i\",\r\n    \"EQV/EQV/Switch2\", { { 1, 1 } }, \"A\", 1.0, \"A\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Current\", }, { \"EQV.Switch2.n.v\", \"EQV/EQV/Switch2\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Switch2.p.v\",\r\n    \"EQV/EQV/Switch2\", { { 1, 1 } }, \"V\", 1.0, \"V\", NE_NOMINAL_SOURCE_MODEL,\r\n    NE_INIT_MODE_NONE, FALSE, FALSE, NE_FREQTIME_TYPE_TIME, TRUE, TRUE,\r\n    \"Voltage\", }, { \"EQV.Switch2.v\", \"EQV/EQV/Switch2\", { { 1, 1 } }, \"V\", 1.0,\r\n    \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, {\r\n    \"EQV.Switch2.power_dissipated\", \"EQV/EQV/Switch2\", { { 1, 1 } }, \"A*V\",\r\n    1.0e-6, \"A*V\", NE_NOMINAL_SOURCE_NONE, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, FALSE, \"power_dissipated\", }, {\r\n    \"EQV.Switch2.vT\", \"EQV/EQV/Switch2\", { { 1, 1 } }, \"1\", 1.0, \"1\",\r\n    NE_NOMINAL_SOURCE_DERIVED, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"PS\", }, { \"EQV.Voltage_Sensor.V\",\r\n    \"EQV/EQV/Voltage Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, { \"EQV.Voltage_Sensor.n.v\",\r\n    \"EQV/EQV/Voltage Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Voltage_Sensor.p.v\",\r\n    \"EQV/EQV/Voltage Sensor\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Voltage_Sensor1.V\",\r\n    \"EQV/EQV/Voltage Sensor1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"V\", }, { \"EQV.Voltage_Sensor1.n.v\",\r\n    \"EQV/EQV/Voltage Sensor1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, TRUE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Voltage_Sensor1.p.v\",\r\n    \"EQV/EQV/Voltage Sensor1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, TRUE, TRUE, \"Voltage\", }, { \"EQV.Voltage_Sensor1_V\",\r\n    \"EQV/EQV/PS-Simulink\\nConverter1\", { { 1, 1 } }, \"V\", 1.0, \"V\",\r\n    NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage_Sensor1_V\", }, {\r\n    \"EQV.Voltage_Sensor_V\", \"EQV/EQV/PS-Simulink\\nConverter2\", { { 1, 1 } }, \"V\",\r\n    1.0, \"V\", NE_NOMINAL_SOURCE_MODEL, NE_INIT_MODE_NONE, FALSE, FALSE,\r\n    NE_FREQTIME_TYPE_TIME, FALSE, TRUE, \"Voltage_Sensor_V\", } };\r\n\r\nstatic NeModeData *s_major_mode_data = NULL;\r\nstatic NeZCData s_zc_data[16] = { { \"EQV/EQV/Diode\", 1U, 0U, \"EQV.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 1U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 2U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 3U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 4U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 5U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 6U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 7U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 8U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 9U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 10U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 11U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/SPMT Switch\", 1U, 12U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/Switch\", 1U, 13U, \"EQV.Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/Switch1\", 1U, 14U, \"EQV.Switch1\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    NE_ZC_TYPE_FALSE, }, { \"EQV/EQV/Switch2\", 1U, 15U, \"EQV.Switch2\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    NE_ZC_TYPE_FALSE, } };\r\n\r\nstatic NeRange s_range[16] = { {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeAssertData s_assert_data[55] = { { \"EQV/EQV/SPMT Switch\", 1U, 0U,\r\n    \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not an integer value.  Fractional indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonIntegerIndex\", }, { \"EQV/EQV/SPMT Switch\",\r\n    1U, 1U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not a positive value.  Zero and negative indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonPositiveIndex\", }, { \"EQV/EQV/SPMT Switch\",\r\n    1U, 2U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"Index is out of range.\",\r\n    \"physmod:common:data2:mf:xlate:IndexOutOfRange\", }, { \"EQV/EQV/SPMT Switch\",\r\n    1U, 3U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not an integer value.  Fractional indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonIntegerIndex\", }, { \"EQV/EQV/SPMT Switch\",\r\n    1U, 4U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE,\r\n    \"Index is not a positive value.  Zero and negative indices are not supported.\",\r\n    \"physmod:common:data2:mf:xlate:NonPositiveIndex\", }, { \"EQV/EQV/SPMT Switch\",\r\n    1U, 5U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"Index is out of range.\",\r\n    \"physmod:common:data2:mf:xlate:IndexOutOfRange\", }, { \"EQV/EQV/Capacitor\",\r\n    1U, 6U, \"EQV.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"EQV/EQV/Capacitor\", 1U, 7U, \"EQV.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"EQV/EQV/Capacitor\", 1U, 8U, \"EQV.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"EQV/EQV/Capacitor\", 1U, 9U, \"EQV.Capacitor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"EQV/EQV/Resistor\", 1U, 10U, \"EQV.Resistor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"EQV/EQV/Resistor\", 1U, 11U, \"EQV.Resistor.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"EQV/EQV/Resistor1\", 1U, 12U, \"EQV.Resistor1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the exponent must be positive when the base is equal to zero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireExponentPositive\", }, {\r\n    \"EQV/EQV/Resistor1\", 1U, 13U, \"EQV.Resistor1.power_dissipated\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    FALSE,\r\n    \"In power, the base must be nonnegative when the exponent is not an integer.\",\r\n    \"physmod:common:mf:expr:analyze:RequireBaseNonnegative\", }, {\r\n    \"EQV/EQV/Diode\", 1U, 14U, \"EQV.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/Diode\", 1U, 15U, \"EQV.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/Diode\", 1U, 16U, \"EQV.Diode\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 17U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 18U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 19U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 20U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 21U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 22U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 23U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 24U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 25U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 26U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 27U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 28U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 29U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 30U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 31U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 32U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 33U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 34U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 35U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 36U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 37U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 38U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 39U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 40U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 41U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 42U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 43U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 44U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 45U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 46U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 47U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 48U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 49U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 50U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/SPMT Switch\", 1U, 51U, \"EQV.SPMT_Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/Switch\", 1U, 52U, \"EQV.Switch\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/Switch1\", 1U, 53U, \"EQV.Switch1\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", }, {\r\n    \"EQV/EQV/Switch2\", 1U, 54U, \"EQV.Switch2\",\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    FALSE, \"In divide, the denominator must be nonzero.\",\r\n    \"physmod:common:mf:expr:analyze:RequireDenominatorNonzero\", } };\r\n\r\nstatic NeRange s_assert_range[55] = { {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 29U, 26U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 27U, 26U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 36U, 26U, 37U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    26U, 33U, 26U, 35U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 29U, 20U, 30U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/resistor.ssc\",\r\n    20U, 27U, 20U, 28U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 16U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 16U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 16U, 48U, 22U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeAssertData *s_param_assert_data = NULL;\r\nstatic NeRange *s_param_assert_range = NULL;\r\nstatic NeAssertData *s_initial_assert_data = NULL;\r\nstatic NeRange *s_initial_assert_range = NULL;\r\nstatic NeRange s_equation_range[104] = { {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/capacitor.ssc\",\r\n    36U, 5U, 36U, 25U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+semiconductors/diode_base.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/branch.ssc\",\r\n    23U, 5U, 23U, 19U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/elec/library/m/+ee/+switches/spmt.sscp\",\r\n    1U, 1U, 1U, 1U, NE_RANGE_TYPE_PROTECTED, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    46U, 9U, 46U, 24U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 9U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    46U, 9U, 46U, 24U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 9U, 48U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    45U, 8U, 45U, 22U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    46U, 9U, 46U, 24U, NE_RANGE_TYPE_NORMAL, }, {\r\n    \"C:/Program Files/MATLAB/R2022a/toolbox/physmod/simscape/library/m/+foundation/+electrical/+elements/controlled_switch.ssc\",\r\n    48U, 9U, 48U, 22U, NE_RANGE_TYPE_NORMAL, } };\r\n\r\nstatic NeRange *s_cer_range = NULL;\r\nstatic NeRange *s_icr_range = NULL;\r\nstatic NeParameterData *s_logical_parameter_data = NULL;\r\nstatic NeParameterData *s_integer_parameter_data = NULL;\r\nstatic NeParameterData *s_index_parameter_data = NULL;\r\nstatic NeParameterData *s_real_parameter_data = NULL;\r\nstatic NeDsMethodOutput *ds_output_m_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM_P.mNumCol = 16;\r\n  out->mM_P.mNumRow = 16;\r\n  out->mM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_m(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mM.mN = 2;\r\n  out->mM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMM.mN = 2;\r\n  out->mVMM.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM_P.mNumCol = 16;\r\n  out->mDXM_P.mNumRow = 2;\r\n  out->mDXM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mDXM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXM.mN = 0;\r\n  out->mDXM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM_P.mNumCol = 1;\r\n  out->mDDM_P.mNumRow = 2;\r\n  out->mDDM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDDM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDM.mN = 0;\r\n  out->mDDM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM_P.mNumCol = 6;\r\n  out->mDUM_P.mNumRow = 2;\r\n  out->mDUM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mDUM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dum(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUM.mN = 0;\r\n  out->mDUM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM_P.mNumCol = 1;\r\n  out->mDTM_P.mNumRow = 2;\r\n  out->mDTM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTM.mN = 0;\r\n  out->mDTM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM_P.mNumCol = 0;\r\n  out->mDPM_P.mNumRow = 2;\r\n  out->mDPM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDPM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPM.mN = 0;\r\n  out->mDPM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA_P.mNumCol = 16;\r\n  out->mA_P.mNumRow = 16;\r\n  out->mA_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mA_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    10);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_a(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mA.mN = 10;\r\n  out->mA.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 10);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB_P.mNumCol = 6;\r\n  out->mB_P.mNumRow = 16;\r\n  out->mB_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mB_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_b(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mB.mN = 1;\r\n  out->mB.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC_P.mNumCol = 1;\r\n  out->mC_P.mNumRow = 16;\r\n  out->mC_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mC_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_c(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mC.mN = 0;\r\n  out->mC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_f(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mF.mN = 16;\r\n  out->mF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vmf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVMF.mN = 16;\r\n  out->mVMF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vpf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVPF.mN = 16;\r\n  out->mVPF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_vsf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVSF.mN = 16;\r\n  out->mVSF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF.mN = 16;\r\n  out->mSLF.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slf0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLF0.mN = 16;\r\n  out->mSLF0.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF_P.mNumCol = 16;\r\n  out->mDXF_P.mNumRow = 16;\r\n  out->mDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    27);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXF.mN = 27;\r\n  out->mDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 27);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF_P.mNumCol = 6;\r\n  out->mDUF_P.mNumRow = 16;\r\n  out->mDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUF.mN = 2;\r\n  out->mDUF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 2);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF_P.mNumCol = 1;\r\n  out->mDTF_P.mNumRow = 16;\r\n  out->mDTF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTF.mN = 0;\r\n  out->mDTF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF_P.mNumCol = 1;\r\n  out->mDDF_P.mNumRow = 16;\r\n  out->mDDF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDDF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDF.mN = 0;\r\n  out->mDDF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF_P.mNumCol = 0;\r\n  out->mDPDXF_P.mNumRow = 27;\r\n  out->mDPDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 1);\r\n  out->mDPDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dpdxf(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDPDXF.mN = 0;\r\n  out->mDPDXF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF_P.mNumCol = 0;\r\n  out->mDWF_P.mNumRow = 16;\r\n  out->mDWF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  out->mDWF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dwf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDWF.mN = 0;\r\n  out->mDWF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUF_P.mNumCol = 6;\r\n  out->mTDUF_P.mNumRow = 16;\r\n  out->mTDUF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mTDUF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxf_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXF_P.mNumCol = 16;\r\n  out->mTDXF_P.mNumRow = 16;\r\n  out->mTDXF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mTDXF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    45);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_P.mNumCol = 8;\r\n  out->mDNF_P.mNumRow = 16;\r\n  out->mDNF_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    9);\r\n  out->mDNF_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF.mN = 0;\r\n  out->mDNF.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dnf_v_x(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDNF_V_X.mN = 16;\r\n  out->mDNF_V_X.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cer(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCER.mN = 0;\r\n  out->mCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER.mN = 0;\r\n  out->mDXCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXCER_P.mNumCol = 16;\r\n  out->mDXCER_P.mNumRow = 0;\r\n  out->mDXCER_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 17);\r\n  out->mDXCER_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddcer(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDCER.mN = 0;\r\n  out->mDDCER.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddcer_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDCER_P.mNumCol = 1;\r\n  out->mDDCER_P.mNumRow = 0;\r\n  out->mDDCER_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDDCER_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ic(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIC.mN = 16;\r\n  out->mIC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR.mN = 0;\r\n  out->mICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_im(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IM.mN = 0;\r\n  out->mICR_IM.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_id(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_ID.mN = 0;\r\n  out->mICR_ID.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icr_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICR_IL.mN = 0;\r\n  out->mICR_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR.mN = 0;\r\n  out->mDXICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICR_P.mNumCol = 16;\r\n  out->mDXICR_P.mNumRow = 0;\r\n  out->mDXICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 17);\r\n  out->mDXICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR.mN = 0;\r\n  out->mDDICR.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICR_P.mNumCol = 1;\r\n  out->mDDICR_P.mNumRow = 0;\r\n  out->mDDICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDDICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduicr_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUICR_P.mNumCol = 6;\r\n  out->mTDUICR_P.mNumRow = 0;\r\n  out->mTDUICR_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 7);\r\n  out->mTDUICR_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM_P.mNumCol = 16;\r\n  out->mICRM_P.mNumRow = 0;\r\n  out->mICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_icrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mICRM.mN = 0;\r\n  out->mICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM_P.mNumCol = 16;\r\n  out->mDXICRM_P.mNumRow = 0;\r\n  out->mDXICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 17);\r\n  out->mDXICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXICRM.mN = 0;\r\n  out->mDXICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM_P.mNumCol = 1;\r\n  out->mDDICRM_P.mNumRow = 0;\r\n  out->mDDICRM_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDDICRM_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_ddicrm(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDDICRM.mN = 0;\r\n  out->mDDICRM.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_freqs(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mFREQS.mN = 0;\r\n  out->mFREQS.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDUY_P.mNumCol = 6;\r\n  out->mMDUY_P.mNumRow = 3;\r\n  out->mMDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mMDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMDXY_P.mNumCol = 16;\r\n  out->mMDXY_P.mNumRow = 3;\r\n  out->mMDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mMDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tduy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDUY_P.mNumCol = 6;\r\n  out->mTDUY_P.mNumRow = 3;\r\n  out->mTDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mTDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_tdxy_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mTDXY_P.mNumCol = 16;\r\n  out->mTDXY_P.mNumRow = 3;\r\n  out->mTDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mTDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_y(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mY.mN = 3;\r\n  out->mY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 3);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY_P.mNumCol = 16;\r\n  out->mDXY_P.mNumRow = 3;\r\n  out->mDXY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mDXY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    5);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXY.mN = 5;\r\n  out->mDXY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 5);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY_P.mNumCol = 6;\r\n  out->mDUY_P.mNumRow = 3;\r\n  out->mDUY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mDUY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_duy(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUY.mN = 1;\r\n  out->mDUY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty_p(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY_P.mNumCol = 1;\r\n  out->mDTY_P.mNumRow = 3;\r\n  out->mDTY_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mDTY_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dty(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTY.mN = 0;\r\n  out->mDTY.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_mode(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mMODE.mN = 16;\r\n  out->mMODE.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_zc(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mZC.mN = 16;\r\n  out->mZC.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_R.mN = 0;\r\n  out->mCACHE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_cache_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mCACHE_I.mN = 0;\r\n  out->mCACHE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_R.mN = 1;\r\n  out->mUPDATE_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE_I.mN = 0;\r\n  out->mUPDATE_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_R.mN = 1;\r\n  out->mUPDATE2_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_update2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mUPDATE2_I.mN = 0;\r\n  out->mUPDATE2_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_R.mN = 1;\r\n  out->mLOCK_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK_I.mN = 0;\r\n  out->mLOCK_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_r(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_R.mN = 1;\r\n  out->mLOCK2_R.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lock2_i(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOCK2_I.mN = 0;\r\n  out->mLOCK2_I.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfo(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFO.mN = 0;\r\n  out->mSFO.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sfp(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSFP.mN = 0;\r\n  out->mSFP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_R.mN = 1;\r\n  out->mINIT_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_init_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mINIT_I.mN = 0;\r\n  out->mINIT_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_log(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLOG.mN = 97;\r\n  out->mLOG.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 97);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_assert(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mASSERT.mN = 55;\r\n  out->mASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    55);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_passert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mPASSERT.mN = 0;\r\n  out->mPASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_iassert(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIASSERT.mN = 0;\r\n  out->mIASSERT.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_t(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_T.mN = 0;\r\n  out->mDEL_T.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V.mN = 0;\r\n  out->mDEL_V.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_v0(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_V0.mN = 0;\r\n  out->mDEL_V0.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_del_tmax(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDEL_TMAX.mN = 0;\r\n  out->mDEL_TMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT_P.mNumCol = 16;\r\n  out->mDXDELT_P.mNumRow = 0;\r\n  out->mDXDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 17);\r\n  out->mDXDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dxdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDXDELT.mN = 0;\r\n  out->mDXDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT_P.mNumCol = 6;\r\n  out->mDUDELT_P.mNumRow = 0;\r\n  out->mDUDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 7);\r\n  out->mDUDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dudelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDUDELT.mN = 0;\r\n  out->mDUDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt_p(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT_P.mNumCol = 1;\r\n  out->mDTDELT_P.mNumRow = 0;\r\n  out->mDTDELT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 2);\r\n  out->mDTDELT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (int32_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dtdelt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDTDELT.mN = 0;\r\n  out->mDTDELT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_exp(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_EXP.mN = 106;\r\n  out->mOBS_EXP.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    106);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_act(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ACT.mN = 106;\r\n  out->mOBS_ACT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    106);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_all(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_ALL.mN = 106;\r\n  out->mOBS_ALL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    106);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_obs_il(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mOBS_IL.mN = 106;\r\n  out->mOBS_IL.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 106);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_l(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_L.mN = 0;\r\n  out->mDP_L.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_i(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_I.mN = 0;\r\n  out->mDP_I.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_j(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_J.mN = 0;\r\n  out->mDP_J.mX = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dp_r(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDP_R.mN = 0;\r\n  out->mDP_R.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX.mN = 0;\r\n  out->mQX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU.mN = 0;\r\n  out->mQU.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT.mN = 0;\r\n  out->mQT.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1.mN = 0;\r\n  out->mQ1.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qx_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQX_P.mNumCol = 16;\r\n  out->mQX_P.mNumRow = 16;\r\n  out->mQX_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    17);\r\n  out->mQX_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qu_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQU_P.mNumCol = 6;\r\n  out->mQU_P.mNumRow = 16;\r\n  out->mQU_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    7);\r\n  out->mQU_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_qt_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQT_P.mNumCol = 1;\r\n  out->mQT_P.mNumRow = 16;\r\n  out->mQT_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQT_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_q1_p(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mQ1_P.mNumCol = 1;\r\n  out->mQ1_P.mNumRow = 16;\r\n  out->mQ1_P.mJc = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    2);\r\n  out->mQ1_P.mIr = (int32_T *) allocator->mCallocFcn(allocator, sizeof(int32_T),\r\n    0);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_var_tol(const NeDynamicSystem *ds,\r\n  PmAllocator *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mVAR_TOL.mN = 16;\r\n  out->mVAR_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_eq_tol(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mEQ_TOL.mN = 16;\r\n  out->mEQ_TOL.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_lv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mLV.mN = 16;\r\n  out->mLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_slv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSLV.mN = 16;\r\n  out->mSLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof(boolean_T),\r\n    16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_nldv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mNLDV.mN = 16;\r\n  out->mNLDV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_sclv(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mSCLV.mN = 16;\r\n  out->mSCLV.mX = (boolean_T *) allocator->mCallocFcn(allocator, sizeof\r\n    (boolean_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imin(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMIN.mN = 16;\r\n  out->mIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_imax(const NeDynamicSystem *ds, PmAllocator\r\n  *allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mIMAX.mN = 16;\r\n  out->mIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 16);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimin(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMIN.mN = 1;\r\n  out->mDIMIN.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic NeDsMethodOutput *ds_output_dimax(const NeDynamicSystem *ds, PmAllocator *\r\n  allocator)\r\n{\r\n  NeDsMethodOutput *out;\r\n  (void)ds;\r\n  out = (NeDsMethodOutput *) allocator->mCallocFcn(allocator, sizeof\r\n    (NeDsMethodOutput), 1);\r\n  out->mDIMAX.mN = 1;\r\n  out->mDIMAX.mX = (real_T *) allocator->mCallocFcn(allocator, sizeof(real_T), 1);\r\n  return out;\r\n}\r\n\r\nstatic void release_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  if (--_ds->mRefCnt == 0) {\r\n    _ds->mAlloc.mFreeFcn(&_ds->mAlloc, _ds);\r\n  }\r\n}\r\n\r\nstatic void get_reference(NeDynamicSystem *ds)\r\n{\r\n  _NeDynamicSystem *_ds;\r\n  _ds = (_NeDynamicSystem *)ds;\r\n  ++_ds->mRefCnt;\r\n}\r\n\r\nstatic NeDynamicSystem *diagnostics(NeDynamicSystem *ds, boolean_T kp)\r\n{\r\n  _NeDynamicSystem *_ds = (_NeDynamicSystem *)ds;\r\n  (void) kp;\r\n  ne_ds_get_reference(&_ds->mBase);\r\n  return &_ds->mBase;\r\n}\r\n\r\nstatic void expand(const NeDynamicSystem *ds, const NeDynamicSystemInput *in,\r\n                   PmRealVector *out, boolean_T kp)\r\n{\r\n  (void)ds;\r\n  (void)kp;\r\n  memcpy(out->mX, in->mX.mX, sizeof(real_T)*out->mN);\r\n}\r\n\r\nstatic void rtpmap(const NeDynamicSystem * ds, const PmIntVector* inl, const\r\n                   PmIntVector* ini, const PmIntVector* inj, const PmRealVector*\r\n                   inr, PmIntVector* outl, PmIntVector* outi, PmIntVector* outj,\r\n                   PmRealVector* outr)\r\n{\r\n  (void)ds;\r\n  memcpy(outl->mX, inl->mX, sizeof(int32_T)*inl->mN);\r\n  memcpy(outi->mX, ini->mX, sizeof(int32_T)*ini->mN);\r\n  memcpy(outj->mX, inj->mX, sizeof(int32_T)*inj->mN);\r\n  memcpy(outr->mX, inr->mX, sizeof(real_T)*inr->mN);\r\n}\r\n\r\nNeDynamicSystem *EQV_627956e1_1_dae_ds(PmAllocator *allocator)\r\n{\r\n  NeDynamicSystem *ds;\r\n  _NeDynamicSystem *_ds;\r\n  static SscIoInfo input_info[6];\r\n  static SscIoInfo output_info[3];\r\n\r\n  /* allocate dynamic system data and extended data */\r\n  _ds = (_NeDynamicSystem *)allocator->mCallocFcn( allocator, sizeof\r\n    (_NeDynamicSystem), 1);\r\n  _ds->mAlloc = *allocator;\r\n  _ds->mRefCnt = 1;\r\n  ds = &_ds->mBase;\r\n\r\n  /* setup sizes */\r\n  ds->mNumVariables = 16;\r\n  ds->mNumDiscreteRealVariables = 1;\r\n  ds->mNumDifferentialVariables = 2;\r\n  ds->mNumEquations = 16;\r\n  ds->mNumCEResiduals = 0;\r\n  ds->mNumICResiduals = 0;\r\n  ds->mNumFreqs = 0;\r\n  ds->mNumModes = 16;\r\n  ds->mNumMajorModes = 0;\r\n  ds->mNumRealCache = 0;\r\n  ds->mNumIntCache = 0;\r\n  ds->mNumObservables = 112;\r\n  ds->mNumObservableElements = 106;\r\n  ds->mNumZcs = 16;\r\n  ds->mNumAsserts = 55;\r\n  ds->mNumAssertRanges = 55;\r\n  ds->mNumParamAsserts = 0;\r\n  ds->mNumParamAssertRanges = 0;\r\n  ds->mNumInitialAsserts = 0;\r\n  ds->mNumInitialAssertRanges = 0;\r\n  ds->mNumRanges = 16;\r\n  ds->mNumEquationRanges = 104;\r\n  ds->mNumCERRanges = 0;\r\n  ds->mNumICRRanges = 0;\r\n  ds->mNumFundamentalSamples = 0;\r\n  ds->mNumDelays = 0;\r\n  ds->mNumLogicalParameters = 0;\r\n  ds->mNumIntegerParameters = 0;\r\n  ds->mNumIndexParameters = 0;\r\n  ds->mNumRealParameters = 0;\r\n  ds->mNumLogicalDerivedParameters = 0;\r\n  ds->mNumIntegerDerivedParameters = 0;\r\n  ds->mNumIndexDerivedParameters = 0;\r\n  ds->mNumRealDerivedParameters = 0;\r\n  ds->mIsOutputLinear = TRUE;\r\n  ds->mIsOutputSwitchedLinear = TRUE;\r\n  ds->mIsScalable = FALSE;\r\n\r\n  /* setup ios */\r\n  ds->mNumIo[SSC_INPUT_IO_TYPE] = 6;\r\n  input_info[0].mIdentifier = \"EQV.Simulink_PS_Converter_output\";\r\n  input_info[0].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[0].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[0].mSize, 1, 1);\r\n  input_info[0].mName = \"EQV.Simulink_PS_Converter_output\";\r\n  input_info[0].mUnit = \"1\";\r\n  input_info[1].mIdentifier = \"EQV.Simulink_PS_Converter1_output\";\r\n  input_info[1].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[1].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[1].mSize, 1, 1);\r\n  input_info[1].mName = \"EQV.Simulink_PS_Converter1_output\";\r\n  input_info[1].mUnit = \"1\";\r\n  input_info[2].mIdentifier = \"EQV.Simulink_PS_Converter2_output\";\r\n  input_info[2].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[2].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[2].mSize, 1, 1);\r\n  input_info[2].mName = \"EQV.Simulink_PS_Converter2_output\";\r\n  input_info[2].mUnit = \"1\";\r\n  input_info[3].mIdentifier = \"EQV.Simulink_PS_Converter3_output\";\r\n  input_info[3].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[3].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[3].mSize, 1, 1);\r\n  input_info[3].mName = \"EQV.Simulink_PS_Converter3_output\";\r\n  input_info[3].mUnit = \"1\";\r\n  input_info[4].mIdentifier = \"EQV.Simulink_PS_Converter4_output\";\r\n  input_info[4].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[4].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[4].mSize, 1, 1);\r\n  input_info[4].mName = \"EQV.Simulink_PS_Converter4_output\";\r\n  input_info[4].mUnit = \"1\";\r\n  input_info[5].mIdentifier = \"EQV.Simulink_PS_Converter5_output\";\r\n  input_info[5].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& input_info[5].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& input_info[5].mSize, 1, 1);\r\n  input_info[5].mName = \"EQV.Simulink_PS_Converter5_output\";\r\n  input_info[5].mUnit = \"1\";\r\n  ds->mIo[SSC_INPUT_IO_TYPE] = input_info;\r\n  ds->mNumIo[SSC_OUTPUT_IO_TYPE] = 3;\r\n  output_info[0].mIdentifier = \"EQV.Current_Sensor_I\";\r\n  output_info[0].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& output_info[0].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& output_info[0].mSize, 1, 1);\r\n  output_info[0].mName = \"EQV.Current_Sensor_I\";\r\n  output_info[0].mUnit = \"A\";\r\n  output_info[1].mIdentifier = \"EQV.Voltage_Sensor1_V\";\r\n  output_info[1].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& output_info[1].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& output_info[1].mSize, 1, 1);\r\n  output_info[1].mName = \"EQV.Voltage_Sensor1_V\";\r\n  output_info[1].mUnit = \"V\";\r\n  output_info[2].mIdentifier = \"EQV.Voltage_Sensor_V\";\r\n  output_info[2].mSize = ssc_make_scalar_array_size();\r\n  ssc_array_size_set_dim(& output_info[2].mSize, 0, 1);\r\n  ssc_array_size_set_dim(& output_info[2].mSize, 1, 1);\r\n  output_info[2].mName = \"EQV.Voltage_Sensor_V\";\r\n  output_info[2].mUnit = \"V\";\r\n  ds->mIo[SSC_OUTPUT_IO_TYPE] = output_info;\r\n\r\n  /* setup administration methods */\r\n  ds->mReleaseReference = release_reference;\r\n  ds->mGetReference = get_reference;\r\n  ds->mDiagnosticsDsFcn = diagnostics;\r\n  ds->mExpandFcn = expand;\r\n  ds->mRtpMapFcn = rtpmap;\r\n  ds->mMethods[NE_DS_METHOD_M_P] = ds_m_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_M_P] = ds_output_m_p;\r\n  ds->mMethods[NE_DS_METHOD_M] = ds_m;\r\n  ds->mMakeOutput[NE_DS_METHOD_M] = ds_output_m;\r\n  ds->mMethods[NE_DS_METHOD_VMM] = ds_vmm;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMM] = ds_output_vmm;\r\n  ds->mMethods[NE_DS_METHOD_DXM_P] = ds_dxm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM_P] = ds_output_dxm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXM] = ds_dxm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXM] = ds_output_dxm;\r\n  ds->mMethods[NE_DS_METHOD_DDM_P] = ds_ddm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM_P] = ds_output_ddm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDM] = ds_ddm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDM] = ds_output_ddm;\r\n  ds->mMethods[NE_DS_METHOD_DUM_P] = ds_dum_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM_P] = ds_output_dum_p;\r\n  ds->mMethods[NE_DS_METHOD_DUM] = ds_dum;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUM] = ds_output_dum;\r\n  ds->mMethods[NE_DS_METHOD_DTM_P] = ds_dtm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM_P] = ds_output_dtm_p;\r\n  ds->mMethods[NE_DS_METHOD_DTM] = ds_dtm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTM] = ds_output_dtm;\r\n  ds->mMethods[NE_DS_METHOD_DPM_P] = ds_dpm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM_P] = ds_output_dpm_p;\r\n  ds->mMethods[NE_DS_METHOD_DPM] = ds_dpm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPM] = ds_output_dpm;\r\n  ds->mMethods[NE_DS_METHOD_A_P] = ds_a_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_A_P] = ds_output_a_p;\r\n  ds->mMethods[NE_DS_METHOD_A] = ds_a;\r\n  ds->mMakeOutput[NE_DS_METHOD_A] = ds_output_a;\r\n  ds->mMethods[NE_DS_METHOD_B_P] = ds_b_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_B_P] = ds_output_b_p;\r\n  ds->mMethods[NE_DS_METHOD_B] = ds_b;\r\n  ds->mMakeOutput[NE_DS_METHOD_B] = ds_output_b;\r\n  ds->mMethods[NE_DS_METHOD_C_P] = ds_c_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_C_P] = ds_output_c_p;\r\n  ds->mMethods[NE_DS_METHOD_C] = ds_c;\r\n  ds->mMakeOutput[NE_DS_METHOD_C] = ds_output_c;\r\n  ds->mMethods[NE_DS_METHOD_F] = EQV_627956e1_1_ds_f;\r\n  ds->mMakeOutput[NE_DS_METHOD_F] = ds_output_f;\r\n  ds->mMethods[NE_DS_METHOD_VMF] = ds_vmf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VMF] = ds_output_vmf;\r\n  ds->mMethods[NE_DS_METHOD_VPF] = ds_vpf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VPF] = ds_output_vpf;\r\n  ds->mMethods[NE_DS_METHOD_VSF] = ds_vsf;\r\n  ds->mMakeOutput[NE_DS_METHOD_VSF] = ds_output_vsf;\r\n  ds->mMethods[NE_DS_METHOD_SLF] = ds_slf;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF] = ds_output_slf;\r\n  ds->mMethods[NE_DS_METHOD_SLF0] = ds_slf0;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLF0] = ds_output_slf0;\r\n  ds->mMethods[NE_DS_METHOD_DXF_P] = EQV_627956e1_1_ds_dxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF_P] = ds_output_dxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DXF] = EQV_627956e1_1_ds_dxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXF] = ds_output_dxf;\r\n  ds->mMethods[NE_DS_METHOD_DUF_P] = ds_duf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF_P] = ds_output_duf_p;\r\n  ds->mMethods[NE_DS_METHOD_DUF] = ds_duf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUF] = ds_output_duf;\r\n  ds->mMethods[NE_DS_METHOD_DTF_P] = ds_dtf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF_P] = ds_output_dtf_p;\r\n  ds->mMethods[NE_DS_METHOD_DTF] = ds_dtf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTF] = ds_output_dtf;\r\n  ds->mMethods[NE_DS_METHOD_DDF_P] = ds_ddf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF_P] = ds_output_ddf_p;\r\n  ds->mMethods[NE_DS_METHOD_DDF] = ds_ddf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDF] = ds_output_ddf;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF_P] = ds_dpdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF_P] = ds_output_dpdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DPDXF] = ds_dpdxf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DPDXF] = ds_output_dpdxf;\r\n  ds->mMethods[NE_DS_METHOD_DWF_P] = ds_dwf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF_P] = ds_output_dwf_p;\r\n  ds->mMethods[NE_DS_METHOD_DWF] = ds_dwf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DWF] = ds_output_dwf;\r\n  ds->mMethods[NE_DS_METHOD_TDUF_P] = ds_tduf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUF_P] = ds_output_tduf_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXF_P] = EQV_627956e1_1_ds_tdxf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXF_P] = ds_output_tdxf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF_P] = ds_dnf_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_P] = ds_output_dnf_p;\r\n  ds->mMethods[NE_DS_METHOD_DNF] = ds_dnf;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF] = ds_output_dnf;\r\n  ds->mMethods[NE_DS_METHOD_DNF_V_X] = ds_dnf_v_x;\r\n  ds->mMakeOutput[NE_DS_METHOD_DNF_V_X] = ds_output_dnf_v_x;\r\n  ds->mMethods[NE_DS_METHOD_CER] = ds_cer;\r\n  ds->mMakeOutput[NE_DS_METHOD_CER] = ds_output_cer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER] = ds_dxcer;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER] = ds_output_dxcer;\r\n  ds->mMethods[NE_DS_METHOD_DXCER_P] = ds_dxcer_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXCER_P] = ds_output_dxcer_p;\r\n  ds->mMethods[NE_DS_METHOD_DDCER] = ds_ddcer;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDCER] = ds_output_ddcer;\r\n  ds->mMethods[NE_DS_METHOD_DDCER_P] = ds_ddcer_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDCER_P] = ds_output_ddcer_p;\r\n  ds->mMethods[NE_DS_METHOD_IC] = ds_ic;\r\n  ds->mMakeOutput[NE_DS_METHOD_IC] = ds_output_ic;\r\n  ds->mMethods[NE_DS_METHOD_ICR] = ds_icr;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR] = ds_output_icr;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IM] = ds_icr_im;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IM] = ds_output_icr_im;\r\n  ds->mMethods[NE_DS_METHOD_ICR_ID] = ds_icr_id;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_ID] = ds_output_icr_id;\r\n  ds->mMethods[NE_DS_METHOD_ICR_IL] = ds_icr_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICR_IL] = ds_output_icr_il;\r\n  ds->mMethods[NE_DS_METHOD_DXICR] = ds_dxicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR] = ds_output_dxicr;\r\n  ds->mMethods[NE_DS_METHOD_DXICR_P] = ds_dxicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICR_P] = ds_output_dxicr_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICR] = ds_ddicr;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR] = ds_output_ddicr;\r\n  ds->mMethods[NE_DS_METHOD_DDICR_P] = ds_ddicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICR_P] = ds_output_ddicr_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUICR_P] = ds_tduicr_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUICR_P] = ds_output_tduicr_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM_P] = ds_icrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM_P] = ds_output_icrm_p;\r\n  ds->mMethods[NE_DS_METHOD_ICRM] = ds_icrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_ICRM] = ds_output_icrm;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM_P] = ds_dxicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM_P] = ds_output_dxicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DXICRM] = ds_dxicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXICRM] = ds_output_dxicrm;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM_P] = ds_ddicrm_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM_P] = ds_output_ddicrm_p;\r\n  ds->mMethods[NE_DS_METHOD_DDICRM] = ds_ddicrm;\r\n  ds->mMakeOutput[NE_DS_METHOD_DDICRM] = ds_output_ddicrm;\r\n  ds->mMethods[NE_DS_METHOD_FREQS] = ds_freqs;\r\n  ds->mMakeOutput[NE_DS_METHOD_FREQS] = ds_output_freqs;\r\n  ds->mMethods[NE_DS_METHOD_MDUY_P] = ds_mduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDUY_P] = ds_output_mduy_p;\r\n  ds->mMethods[NE_DS_METHOD_MDXY_P] = ds_mdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_MDXY_P] = ds_output_mdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDUY_P] = ds_tduy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDUY_P] = ds_output_tduy_p;\r\n  ds->mMethods[NE_DS_METHOD_TDXY_P] = ds_tdxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_TDXY_P] = ds_output_tdxy_p;\r\n  ds->mMethods[NE_DS_METHOD_Y] = ds_y;\r\n  ds->mMakeOutput[NE_DS_METHOD_Y] = ds_output_y;\r\n  ds->mMethods[NE_DS_METHOD_DXY_P] = ds_dxy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY_P] = ds_output_dxy_p;\r\n  ds->mMethods[NE_DS_METHOD_DXY] = ds_dxy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXY] = ds_output_dxy;\r\n  ds->mMethods[NE_DS_METHOD_DUY_P] = ds_duy_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY_P] = ds_output_duy_p;\r\n  ds->mMethods[NE_DS_METHOD_DUY] = ds_duy;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUY] = ds_output_duy;\r\n  ds->mMethods[NE_DS_METHOD_DTY_P] = ds_dty_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY_P] = ds_output_dty_p;\r\n  ds->mMethods[NE_DS_METHOD_DTY] = ds_dty;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTY] = ds_output_dty;\r\n  ds->mMethods[NE_DS_METHOD_MODE] = EQV_627956e1_1_ds_mode;\r\n  ds->mMakeOutput[NE_DS_METHOD_MODE] = ds_output_mode;\r\n  ds->mMethods[NE_DS_METHOD_ZC] = EQV_627956e1_1_ds_zc;\r\n  ds->mMakeOutput[NE_DS_METHOD_ZC] = ds_output_zc;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_R] = ds_cache_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_R] = ds_output_cache_r;\r\n  ds->mMethods[NE_DS_METHOD_CACHE_I] = ds_cache_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_CACHE_I] = ds_output_cache_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_R] = ds_update_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_R] = ds_output_update_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE_I] = ds_update_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE_I] = ds_output_update_i;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_R] = ds_update2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_R] = ds_output_update2_r;\r\n  ds->mMethods[NE_DS_METHOD_UPDATE2_I] = ds_update2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_UPDATE2_I] = ds_output_update2_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_R] = ds_lock_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_R] = ds_output_lock_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK_I] = ds_lock_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK_I] = ds_output_lock_i;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_R] = ds_lock2_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_R] = ds_output_lock2_r;\r\n  ds->mMethods[NE_DS_METHOD_LOCK2_I] = ds_lock2_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOCK2_I] = ds_output_lock2_i;\r\n  ds->mMethods[NE_DS_METHOD_SFO] = ds_sfo;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFO] = ds_output_sfo;\r\n  ds->mMethods[NE_DS_METHOD_SFP] = ds_sfp;\r\n  ds->mMakeOutput[NE_DS_METHOD_SFP] = ds_output_sfp;\r\n  ds->mMethods[NE_DS_METHOD_INIT_R] = ds_init_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_R] = ds_output_init_r;\r\n  ds->mMethods[NE_DS_METHOD_INIT_I] = ds_init_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_INIT_I] = ds_output_init_i;\r\n  ds->mMethods[NE_DS_METHOD_LOG] = EQV_627956e1_1_ds_log;\r\n  ds->mMakeOutput[NE_DS_METHOD_LOG] = ds_output_log;\r\n  ds->mMethods[NE_DS_METHOD_ASSERT] = EQV_627956e1_1_ds_assert;\r\n  ds->mMakeOutput[NE_DS_METHOD_ASSERT] = ds_output_assert;\r\n  ds->mMethods[NE_DS_METHOD_PASSERT] = ds_passert;\r\n  ds->mMakeOutput[NE_DS_METHOD_PASSERT] = ds_output_passert;\r\n  ds->mMethods[NE_DS_METHOD_IASSERT] = ds_iassert;\r\n  ds->mMakeOutput[NE_DS_METHOD_IASSERT] = ds_output_iassert;\r\n  ds->mMethods[NE_DS_METHOD_DEL_T] = ds_del_t;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_T] = ds_output_del_t;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V] = ds_del_v;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V] = ds_output_del_v;\r\n  ds->mMethods[NE_DS_METHOD_DEL_V0] = ds_del_v0;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_V0] = ds_output_del_v0;\r\n  ds->mMethods[NE_DS_METHOD_DEL_TMAX] = ds_del_tmax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DEL_TMAX] = ds_output_del_tmax;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT_P] = ds_dxdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT_P] = ds_output_dxdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DXDELT] = ds_dxdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DXDELT] = ds_output_dxdelt;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT_P] = ds_dudelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT_P] = ds_output_dudelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DUDELT] = ds_dudelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DUDELT] = ds_output_dudelt;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT_P] = ds_dtdelt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT_P] = ds_output_dtdelt_p;\r\n  ds->mMethods[NE_DS_METHOD_DTDELT] = ds_dtdelt;\r\n  ds->mMakeOutput[NE_DS_METHOD_DTDELT] = ds_output_dtdelt;\r\n  ds->mMethods[NE_DS_METHOD_OBS_EXP] = ds_obs_exp;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_EXP] = ds_output_obs_exp;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ACT] = EQV_627956e1_1_ds_obs_act;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ACT] = ds_output_obs_act;\r\n  ds->mMethods[NE_DS_METHOD_OBS_ALL] = EQV_627956e1_1_ds_obs_all;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_ALL] = ds_output_obs_all;\r\n  ds->mMethods[NE_DS_METHOD_OBS_IL] = EQV_627956e1_1_ds_obs_il;\r\n  ds->mMakeOutput[NE_DS_METHOD_OBS_IL] = ds_output_obs_il;\r\n  ds->mMethods[NE_DS_METHOD_DP_L] = ds_dp_l;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_L] = ds_output_dp_l;\r\n  ds->mMethods[NE_DS_METHOD_DP_I] = ds_dp_i;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_I] = ds_output_dp_i;\r\n  ds->mMethods[NE_DS_METHOD_DP_J] = ds_dp_j;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_J] = ds_output_dp_j;\r\n  ds->mMethods[NE_DS_METHOD_DP_R] = ds_dp_r;\r\n  ds->mMakeOutput[NE_DS_METHOD_DP_R] = ds_output_dp_r;\r\n  ds->mMethods[NE_DS_METHOD_QX] = ds_qx;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX] = ds_output_qx;\r\n  ds->mMethods[NE_DS_METHOD_QU] = ds_qu;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU] = ds_output_qu;\r\n  ds->mMethods[NE_DS_METHOD_QT] = ds_qt;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT] = ds_output_qt;\r\n  ds->mMethods[NE_DS_METHOD_Q1] = ds_q1;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1] = ds_output_q1;\r\n  ds->mMethods[NE_DS_METHOD_QX_P] = ds_qx_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QX_P] = ds_output_qx_p;\r\n  ds->mMethods[NE_DS_METHOD_QU_P] = ds_qu_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QU_P] = ds_output_qu_p;\r\n  ds->mMethods[NE_DS_METHOD_QT_P] = ds_qt_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_QT_P] = ds_output_qt_p;\r\n  ds->mMethods[NE_DS_METHOD_Q1_P] = ds_q1_p;\r\n  ds->mMakeOutput[NE_DS_METHOD_Q1_P] = ds_output_q1_p;\r\n  ds->mMethods[NE_DS_METHOD_VAR_TOL] = ds_var_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_VAR_TOL] = ds_output_var_tol;\r\n  ds->mMethods[NE_DS_METHOD_EQ_TOL] = ds_eq_tol;\r\n  ds->mMakeOutput[NE_DS_METHOD_EQ_TOL] = ds_output_eq_tol;\r\n  ds->mMethods[NE_DS_METHOD_LV] = ds_lv;\r\n  ds->mMakeOutput[NE_DS_METHOD_LV] = ds_output_lv;\r\n  ds->mMethods[NE_DS_METHOD_SLV] = ds_slv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SLV] = ds_output_slv;\r\n  ds->mMethods[NE_DS_METHOD_NLDV] = ds_nldv;\r\n  ds->mMakeOutput[NE_DS_METHOD_NLDV] = ds_output_nldv;\r\n  ds->mMethods[NE_DS_METHOD_SCLV] = ds_sclv;\r\n  ds->mMakeOutput[NE_DS_METHOD_SCLV] = ds_output_sclv;\r\n  ds->mMethods[NE_DS_METHOD_IMIN] = ds_imin;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMIN] = ds_output_imin;\r\n  ds->mMethods[NE_DS_METHOD_IMAX] = ds_imax;\r\n  ds->mMakeOutput[NE_DS_METHOD_IMAX] = ds_output_imax;\r\n  ds->mMethods[NE_DS_METHOD_DIMIN] = ds_dimin;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMIN] = ds_output_dimin;\r\n  ds->mMethods[NE_DS_METHOD_DIMAX] = ds_dimax;\r\n  ds->mMakeOutput[NE_DS_METHOD_DIMAX] = ds_output_dimax;\r\n\r\n  /* equation data */\r\n  ds->mEquationData = s_equation_data;\r\n\r\n  /* cer data */\r\n  ds->mCERData = s_cer_data;\r\n\r\n  /* icr data */\r\n  ds->mICRData = s_icr_data;\r\n\r\n  /* continuous variable data */\r\n  ds->mVariableData = s_variable_data;\r\n\r\n  /* discrete variable data */\r\n  ds->mDiscreteData = s_discrete_data;\r\n\r\n  /* observable data */\r\n  ds->mObservableData = s_observable_data;\r\n\r\n  /* major mode data */\r\n  ds->mMajorModeData = s_major_mode_data;\r\n\r\n  /* zc data */\r\n  ds->mZCData = s_zc_data;\r\n\r\n  /* ranges */\r\n  ds->mRanges = s_range;\r\n\r\n  /* assert data */\r\n  ds->mAssertData = s_assert_data;\r\n\r\n  /* assert ranges */\r\n  ds->mAssertRanges = s_assert_range;\r\n\r\n  /* param assert data */\r\n  ds->mParamAssertData = s_param_assert_data;\r\n\r\n  /* param assert ranges */\r\n  ds->mParamAssertRanges = s_param_assert_range;\r\n\r\n  /* initial assert data */\r\n  ds->mInitialAssertData = s_initial_assert_data;\r\n\r\n  /* initial assert ranges */\r\n  ds->mInitialAssertRanges = s_initial_assert_range;\r\n\r\n  /* equation ranges */\r\n  ds->mEquationRanges = s_equation_range;\r\n\r\n  /* cer ranges */\r\n  ds->mCERRanges = s_cer_range;\r\n\r\n  /* icr ranges */\r\n  ds->mICRRanges = s_icr_range;\r\n\r\n  /* parameters */\r\n  ds->mLogicalParameters = s_logical_parameter_data;\r\n  ds->mIntegerParameters = s_integer_parameter_data;\r\n  ds->mIndexParameters = s_index_parameter_data;\r\n  ds->mRealParameters = s_real_parameter_data;\r\n\r\n  /* constant tables */\r\n  ds->mNumLargeArray = 0;\r\n  return (NeDynamicSystem *)_ds;\r\n}\r\n\r\nstatic int32_T ds_passert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_iassert (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cer (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxcer_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXCER_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddcer (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddcer_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDCER_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_v0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_tmax (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_del_t (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXDELT_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dudelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUDELT_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtdelt_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTDELT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mINIT_R;\r\n  out.mX[0] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  D_idx_0 = t1->mD.mX[0];\r\n  out = t2->mUPDATE_R;\r\n  out.mX[0] = D_idx_0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLOCK_R;\r\n  out.mX[0] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_cache_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_init_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  D_idx_0 = t1->mD.mX[0];\r\n  out = t2->mUPDATE2_R;\r\n  out.mX[0] = D_idx_0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_r (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLOCK2_R;\r\n  out.mX[0] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_update2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lock2_i (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfp (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sfo (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mDUF;\r\n  out.mX[0] = -1.0E-8;\r\n  out.mX[1] = -1.0E-6;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUF_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 2;\r\n  out.mJc[5] = 2;\r\n  out.mJc[6] = 2;\r\n  out.mIr[0] = 15;\r\n  out.mIr[1] = 5;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDF_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_a (const NeDynamicSystem *sys, const NeDynamicSystemInput *t10,\r\n                     NeDsMethodOutput *t11)\r\n{\r\n  PmRealVector out;\r\n  (void)t10;\r\n  out = t11->mA;\r\n  out.mX[0] = 1.0E-6;\r\n  out.mX[1] = -0.0;\r\n  out.mX[2] = -0.01;\r\n  out.mX[3] = -1.0;\r\n  out.mX[4] = 1.0043755555938443;\r\n  out.mX[5] = 0.0043755555938442738;\r\n  out.mX[6] = -1.0;\r\n  out.mX[7] = -1.0E-8;\r\n  out.mX[8] = 0.01;\r\n  out.mX[9] = -0.01;\r\n  (void)sys;\r\n  (void)t11;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_a_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mA_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 3;\r\n  out.mJc[3] = 4;\r\n  out.mJc[4] = 4;\r\n  out.mJc[5] = 5;\r\n  out.mJc[6] = 6;\r\n  out.mJc[7] = 8;\r\n  out.mJc[8] = 9;\r\n  out.mJc[9] = 10;\r\n  out.mJc[10] = 10;\r\n  out.mJc[11] = 10;\r\n  out.mJc[12] = 10;\r\n  out.mJc[13] = 10;\r\n  out.mJc[14] = 10;\r\n  out.mJc[15] = 10;\r\n  out.mJc[16] = 10;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  out.mIr[2] = 3;\r\n  out.mIr[3] = 0;\r\n  out.mIr[4] = 3;\r\n  out.mIr[5] = 3;\r\n  out.mIr[6] = 1;\r\n  out.mIr[7] = 3;\r\n  out.mIr[8] = 3;\r\n  out.mIr[9] = 3;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mB;\r\n  out.mX[0] = 0.01;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_b_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mB_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 1;\r\n  out.mJc[6] = 1;\r\n  out.mIr[0] = 3;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_c_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mC_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUF_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mJc[2] = 3;\r\n  out.mJc[3] = 4;\r\n  out.mJc[4] = 5;\r\n  out.mJc[5] = 6;\r\n  out.mJc[6] = 7;\r\n  out.mIr[0] = 3;\r\n  out.mIr[1] = 15;\r\n  out.mIr[2] = 5;\r\n  out.mIr[3] = 14;\r\n  out.mIr[4] = 15;\r\n  out.mIr[5] = 12;\r\n  out.mIr[6] = 13;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dwf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDWF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpdxf_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPDXF_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 27ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = true;\r\n  out.mX[3] = false;\r\n  out.mX[4] = true;\r\n  out.mX[5] = true;\r\n  out.mX[6] = true;\r\n  out.mX[7] = true;\r\n  out.mX[8] = true;\r\n  out.mX[9] = true;\r\n  out.mX[10] = true;\r\n  out.mX[11] = true;\r\n  out.mX[12] = true;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  out.mX[15] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDNF_P;\r\n  out.mNumCol = 8ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dnf_v_x (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mDNF_V_X;\r\n  out.mX[0] = true;\r\n  out.mX[1] = true;\r\n  out.mX[2] = true;\r\n  out.mX[3] = false;\r\n  out.mX[4] = true;\r\n  out.mX[5] = true;\r\n  out.mX[6] = true;\r\n  out.mX[7] = true;\r\n  out.mX[8] = true;\r\n  out.mX[9] = true;\r\n  out.mX[10] = true;\r\n  out.mX[11] = true;\r\n  out.mX[12] = true;\r\n  out.mX[13] = true;\r\n  out.mX[14] = true;\r\n  out.mX[15] = true;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slf0 (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLF0;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vpf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVPF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vsf (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVSF;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_freqs (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ic (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIC;\r\n  out.mX[0] = 0.0;\r\n  out.mX[1] = 0.0;\r\n  out.mX[2] = 0.0;\r\n  out.mX[3] = 0.0;\r\n  out.mX[4] = 0.0;\r\n  out.mX[5] = 0.0;\r\n  out.mX[6] = 0.0;\r\n  out.mX[7] = 0.0;\r\n  out.mX[8] = 0.0;\r\n  out.mX[9] = 1.0;\r\n  out.mX[10] = 0.0;\r\n  out.mX[11] = 0.0;\r\n  out.mX[12] = 0.0;\r\n  out.mX[13] = 0.0;\r\n  out.mX[14] = 0.0;\r\n  out.mX[15] = 0.0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_im (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_id (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icr_il (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICR_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICR_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduicr_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUICR_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_icrm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mICRM_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXICRM_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddicrm_p (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDICRM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 0ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_imin (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMIN;\r\n  out.mX[0] = -pmf_get_inf();\r\n  out.mX[1] = -pmf_get_inf();\r\n  out.mX[2] = -pmf_get_inf();\r\n  out.mX[3] = -pmf_get_inf();\r\n  out.mX[4] = -pmf_get_inf();\r\n  out.mX[5] = -pmf_get_inf();\r\n  out.mX[6] = -pmf_get_inf();\r\n  out.mX[7] = -pmf_get_inf();\r\n  out.mX[8] = -pmf_get_inf();\r\n  out.mX[9] = -pmf_get_inf();\r\n  out.mX[10] = -pmf_get_inf();\r\n  out.mX[11] = -pmf_get_inf();\r\n  out.mX[12] = -pmf_get_inf();\r\n  out.mX[13] = -pmf_get_inf();\r\n  out.mX[14] = -pmf_get_inf();\r\n  out.mX[15] = -pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_imax (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mIMAX;\r\n  out.mX[0] = pmf_get_inf();\r\n  out.mX[1] = pmf_get_inf();\r\n  out.mX[2] = pmf_get_inf();\r\n  out.mX[3] = pmf_get_inf();\r\n  out.mX[4] = pmf_get_inf();\r\n  out.mX[5] = pmf_get_inf();\r\n  out.mX[6] = pmf_get_inf();\r\n  out.mX[7] = pmf_get_inf();\r\n  out.mX[8] = pmf_get_inf();\r\n  out.mX[9] = pmf_get_inf();\r\n  out.mX[10] = pmf_get_inf();\r\n  out.mX[11] = pmf_get_inf();\r\n  out.mX[12] = pmf_get_inf();\r\n  out.mX[13] = pmf_get_inf();\r\n  out.mX[14] = pmf_get_inf();\r\n  out.mX[15] = pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimin (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mDIMIN;\r\n  out.mX[0] = -pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dimax (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mDIMAX;\r\n  out.mX[0] = pmf_get_inf();\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                     NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mM;\r\n  out.mX[0] = -0.05;\r\n  out.mX[1] = -5.0E-12;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_m_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mM_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 2;\r\n  out.mJc[4] = 2;\r\n  out.mJc[5] = 2;\r\n  out.mJc[6] = 2;\r\n  out.mJc[7] = 2;\r\n  out.mJc[8] = 2;\r\n  out.mJc[9] = 2;\r\n  out.mJc[10] = 2;\r\n  out.mJc[11] = 2;\r\n  out.mJc[12] = 2;\r\n  out.mJc[13] = 2;\r\n  out.mJc[14] = 2;\r\n  out.mJc[15] = 2;\r\n  out.mJc[16] = 2;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXM_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_ddm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDDM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dum_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUM_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dtm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTM_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dpm_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDPM_P;\r\n  out.mNumCol = 0ULL;\r\n  out.mNumRow = 2ULL;\r\n  out.mJc[0] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_vmm (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mVMM;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_obs_exp (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static real_T _cg_const_1[106] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 298.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\r\n\r\n  PmRealVector out;\r\n  real_T t0[106];\r\n  int32_T b;\r\n  (void)t1;\r\n  out = t2->mOBS_EXP;\r\n  for (b = 0; b < 106; b++) {\r\n    t0[b] = _cg_const_1[b];\r\n  }\r\n\r\n  for (b = 0; b < 106; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_l (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_i (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_j (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dp_r (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1 (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qx_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQX_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qu_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQU_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_qt_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQT_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_q1_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mQ1_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_var_tol (const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mVAR_TOL;\r\n  out.mX[0] = 1.0E-9;\r\n  out.mX[1] = 1.0E-9;\r\n  out.mX[2] = 1.0E-9;\r\n  out.mX[3] = 1.0E-9;\r\n  out.mX[4] = 1.0E-9;\r\n  out.mX[5] = 1.0E-9;\r\n  out.mX[6] = 1.0E-9;\r\n  out.mX[7] = 1.0E-9;\r\n  out.mX[8] = 1.0E-9;\r\n  out.mX[9] = 1.0E-9;\r\n  out.mX[10] = 1.0E-9;\r\n  out.mX[11] = 1.0E-9;\r\n  out.mX[12] = 1.0E-9;\r\n  out.mX[13] = 1.0E-9;\r\n  out.mX[14] = 1.0E-9;\r\n  out.mX[15] = 1.0E-9;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_eq_tol (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmRealVector out;\r\n  (void)t1;\r\n  out = t2->mEQ_TOL;\r\n  out.mX[0] = 1.0E-9;\r\n  out.mX[1] = 1.0E-9;\r\n  out.mX[2] = 1.0E-9;\r\n  out.mX[3] = 1.0E-9;\r\n  out.mX[4] = 1.0E-9;\r\n  out.mX[5] = 1.0E-9;\r\n  out.mX[6] = 1.0E-9;\r\n  out.mX[7] = 1.0E-9;\r\n  out.mX[8] = 1.0E-9;\r\n  out.mX[9] = 1.0E-9;\r\n  out.mX[10] = 1.0E-9;\r\n  out.mX[11] = 1.0E-9;\r\n  out.mX[12] = 1.0E-9;\r\n  out.mX[13] = 1.0E-9;\r\n  out.mX[14] = 1.0E-9;\r\n  out.mX[15] = 1.0E-9;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_lv (const NeDynamicSystem *sys, const NeDynamicSystemInput *t1,\r\n                      NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_slv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_nldv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mNLDV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_sclv (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmBoolVector out;\r\n  (void)t1;\r\n  out = t2->mSCLV;\r\n  out.mX[0] = false;\r\n  out.mX[1] = false;\r\n  out.mX[2] = false;\r\n  out.mX[3] = false;\r\n  out.mX[4] = false;\r\n  out.mX[5] = false;\r\n  out.mX[6] = false;\r\n  out.mX[7] = false;\r\n  out.mX[8] = false;\r\n  out.mX[9] = false;\r\n  out.mX[10] = false;\r\n  out.mX[11] = false;\r\n  out.mX[12] = false;\r\n  out.mX[13] = false;\r\n  out.mX[14] = false;\r\n  out.mX[15] = false;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_y (const NeDynamicSystem *sys, const NeDynamicSystemInput *t3,\r\n                     NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T U_idx_0;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_8;\r\n  U_idx_0 = t3->mU.mX[0];\r\n  X_idx_4 = t3->mX.mX[4];\r\n  X_idx_5 = t3->mX.mX[5];\r\n  X_idx_8 = t3->mX.mX[8];\r\n  out = t4->mY;\r\n  out.mX[0] = X_idx_4 + X_idx_5;\r\n  out.mX[1] = X_idx_8;\r\n  out.mX[2] = (X_idx_4 * 0.43755555938442742 + X_idx_5 * 0.43755555938442742) +\r\n    U_idx_0;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t10, NeDsMethodOutput *t11)\r\n{\r\n  PmRealVector out;\r\n  (void)t10;\r\n  out = t11->mDXY;\r\n  out.mX[0] = 1.0;\r\n  out.mX[1] = 0.43755555938442742;\r\n  out.mX[2] = 1.0;\r\n  out.mX[3] = 0.43755555938442742;\r\n  out.mX[4] = 1.0;\r\n  (void)sys;\r\n  (void)t11;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXY_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 2;\r\n  out.mJc[6] = 4;\r\n  out.mJc[7] = 4;\r\n  out.mJc[8] = 4;\r\n  out.mJc[9] = 5;\r\n  out.mJc[10] = 5;\r\n  out.mJc[11] = 5;\r\n  out.mJc[12] = 5;\r\n  out.mJc[13] = 5;\r\n  out.mJc[14] = 5;\r\n  out.mJc[15] = 5;\r\n  out.mJc[16] = 5;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 0;\r\n  out.mIr[3] = 2;\r\n  out.mIr[4] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t2, NeDsMethodOutput *t3)\r\n{\r\n  PmRealVector out;\r\n  (void)t2;\r\n  out = t3->mDUY;\r\n  out.mX[0] = 1.0;\r\n  (void)sys;\r\n  (void)t3;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_duy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDUY_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 1;\r\n  out.mJc[6] = 1;\r\n  out.mIr[0] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDUY_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_mdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mMDXY_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 0;\r\n  out.mJc[6] = 0;\r\n  out.mJc[7] = 0;\r\n  out.mJc[8] = 0;\r\n  out.mJc[9] = 0;\r\n  out.mJc[10] = 0;\r\n  out.mJc[11] = 0;\r\n  out.mJc[12] = 0;\r\n  out.mJc[13] = 0;\r\n  out.mJc[14] = 0;\r\n  out.mJc[15] = 0;\r\n  out.mJc[16] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tduy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDUY_P;\r\n  out.mNumCol = 6ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 1;\r\n  out.mJc[3] = 1;\r\n  out.mJc[4] = 1;\r\n  out.mJc[5] = 1;\r\n  out.mJc[6] = 1;\r\n  out.mIr[0] = 2;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_tdxy_p (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXY_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  out.mJc[2] = 0;\r\n  out.mJc[3] = 0;\r\n  out.mJc[4] = 0;\r\n  out.mJc[5] = 2;\r\n  out.mJc[6] = 4;\r\n  out.mJc[7] = 4;\r\n  out.mJc[8] = 4;\r\n  out.mJc[9] = 5;\r\n  out.mJc[10] = 5;\r\n  out.mJc[11] = 5;\r\n  out.mJc[12] = 5;\r\n  out.mJc[13] = 5;\r\n  out.mJc[14] = 5;\r\n  out.mJc[15] = 5;\r\n  out.mJc[16] = 5;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 0;\r\n  out.mIr[3] = 2;\r\n  out.mIr[4] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty (const NeDynamicSystem *sys, const NeDynamicSystemInput\r\n  *t1, NeDsMethodOutput *t2)\r\n{\r\n  (void)t1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n\r\nstatic int32_T ds_dty_p (const NeDynamicSystem *sys, const NeDynamicSystemInput *\r\n  t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDTY_P;\r\n  out.mNumCol = 1ULL;\r\n  out.mNumRow = 3ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 0;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_H\r\n#define EQV_627956E1_1_DS_H            1\r\n\r\n  extern NeDynamicSystem *EQV_627956e1_1_dae_ds(PmAllocator *allocator );\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_assert.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_assert.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_assert(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmIntVector out;\r\n  int32_T M_idx_5;\r\n  int32_T M_idx_6;\r\n  int32_T M_idx_7;\r\n  M_idx_5 = t1->mM.mX[5];\r\n  M_idx_6 = t1->mM.mX[6];\r\n  M_idx_7 = t1->mM.mX[7];\r\n  out = t2->mASSERT;\r\n  out.mX[0] = 1;\r\n  out.mX[1] = 1;\r\n  out.mX[2] = 1;\r\n  out.mX[3] = (int32_T)(M_idx_5 != 0);\r\n  out.mX[4] = (int32_T)(M_idx_6 != 0);\r\n  out.mX[5] = (int32_T)(M_idx_7 != 0);\r\n  out.mX[6] = 1;\r\n  out.mX[7] = 1;\r\n  out.mX[8] = 1;\r\n  out.mX[9] = 1;\r\n  out.mX[10] = 1;\r\n  out.mX[11] = 1;\r\n  out.mX[12] = 1;\r\n  out.mX[13] = 1;\r\n  out.mX[14] = 1;\r\n  out.mX[15] = 1;\r\n  out.mX[16] = 1;\r\n  out.mX[17] = 1;\r\n  out.mX[18] = 1;\r\n  out.mX[19] = 1;\r\n  out.mX[20] = 1;\r\n  out.mX[21] = 1;\r\n  out.mX[22] = 1;\r\n  out.mX[23] = 1;\r\n  out.mX[24] = 1;\r\n  out.mX[25] = 1;\r\n  out.mX[26] = 1;\r\n  out.mX[27] = 1;\r\n  out.mX[28] = 1;\r\n  out.mX[29] = 1;\r\n  out.mX[30] = 1;\r\n  out.mX[31] = 1;\r\n  out.mX[32] = 1;\r\n  out.mX[33] = 1;\r\n  out.mX[34] = 1;\r\n  out.mX[35] = 1;\r\n  out.mX[36] = 1;\r\n  out.mX[37] = 1;\r\n  out.mX[38] = 1;\r\n  out.mX[39] = 1;\r\n  out.mX[40] = 1;\r\n  out.mX[41] = 1;\r\n  out.mX[42] = 1;\r\n  out.mX[43] = 1;\r\n  out.mX[44] = 1;\r\n  out.mX[45] = 1;\r\n  out.mX[46] = 1;\r\n  out.mX[47] = 1;\r\n  out.mX[48] = 1;\r\n  out.mX[49] = 1;\r\n  out.mX[50] = 1;\r\n  out.mX[51] = 1;\r\n  out.mX[52] = 1;\r\n  out.mX[53] = 1;\r\n  out.mX[54] = 1;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_assert.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_ASSERT_H\r\n#define EQV_627956E1_1_DS_ASSERT_H     1\r\n\r\n  int32_T EQV_627956e1_1_ds_assert(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_dxf.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_dxf.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_dxf(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t34, NeDsMethodOutput *t35)\r\n{\r\n  PmRealVector out;\r\n  real_T t9[27];\r\n  real_T t12[5];\r\n  real_T t0;\r\n  real_T t20;\r\n  real_T t21;\r\n  real_T t22;\r\n  real_T t24;\r\n  real_T t26;\r\n  real_T t27;\r\n  real_T t31;\r\n  real_T t32;\r\n  real_T t6;\r\n  real_T t8;\r\n  size_t t17;\r\n  int32_T M_idx_0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_0 = t34->mM.mX[0];\r\n  M_idx_1 = t34->mM.mX[1];\r\n  M_idx_2 = t34->mM.mX[2];\r\n  M_idx_3 = t34->mM.mX[3];\r\n  M_idx_4 = t34->mM.mX[4];\r\n  M_idx_8 = t34->mM.mX[8];\r\n  M_idx_9 = t34->mM.mX[9];\r\n  out = t35->mDXF;\r\n  if (M_idx_0 != 0) {\r\n    t0 = -3.3333333333333335;\r\n  } else {\r\n    t0 = -1.0E-8;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t21 = 1.0E+6;\r\n  } else if (M_idx_8 != 0) {\r\n    t21 = 0.01;\r\n  } else {\r\n    t21 = 1.0E+6;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t22 = -1.0E+6;\r\n  } else if (M_idx_8 != 0) {\r\n    t22 = -1.0E+6;\r\n  } else {\r\n    t22 = M_idx_9 != 0 ? -0.01 : -1.0E+6;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t26 = 1.0E+6;\r\n  } else if (M_idx_8 != 0) {\r\n    t26 = 0.01;\r\n  } else {\r\n    t26 = 1.0E+6;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t27 = 0.01;\r\n  } else {\r\n    t27 = 1.0E+8;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t31 = 1.0E+6;\r\n  } else if (M_idx_8 != 0) {\r\n    t31 = 0.01;\r\n  } else {\r\n    t31 = 1.0E+6;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t6 = 0.01;\r\n  } else {\r\n    t6 = 1.0E+8;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    t32 = -0.44755555938442743;\r\n  } else {\r\n    t32 = -1.0000000043755557E+8;\r\n  }\r\n\r\n  if (M_idx_0 != 0) {\r\n    t8 = -1.0000033333333334;\r\n  } else {\r\n    t8 = -1.00000000000001;\r\n  }\r\n\r\n  t20 = t21 / 1.0E+6;\r\n  t21 = t22 / 1.0E+6;\r\n  t22 = -1.0E-6;\r\n  t24 = 1.0E-8;\r\n  t12[0ULL] = -1.0;\r\n  t12[1ULL] = t26 / 1.0E+6;\r\n  t12[2ULL] = t27 / 1.0E+8;\r\n  t12[3ULL] = (M_idx_3 != 0 ? -0.01 : -1.0E+8) / 1.0E+8;\r\n  t12[4ULL] = -4.3755555938442745E-9;\r\n  t26 = t31 / 1.0E+6;\r\n  t31 = 1.0E-6;\r\n  t9[0ULL] = -1.0E-6;\r\n  t9[1ULL] = t0;\r\n  t9[2ULL] = t20;\r\n  t9[3ULL] = t21;\r\n  t9[4ULL] = t22;\r\n  t9[5ULL] = t22;\r\n  t9[6ULL] = t24;\r\n  for (t17 = 0ULL; t17 < 5ULL; t17++) {\r\n    t9[t17 + 7ULL] = t12[t17];\r\n  }\r\n\r\n  out.mX[0] = t9[0];\r\n  out.mX[1] = t9[1];\r\n  out.mX[2] = t9[2];\r\n  out.mX[3] = t9[3];\r\n  out.mX[4] = t9[4];\r\n  out.mX[5] = t9[5];\r\n  out.mX[6] = t9[6];\r\n  out.mX[7] = t9[7];\r\n  out.mX[8] = t9[8];\r\n  out.mX[9] = t9[9];\r\n  out.mX[10] = t9[10];\r\n  out.mX[11] = t9[11];\r\n  out.mX[12] = t26;\r\n  out.mX[13] = t6 / 1.0E+8;\r\n  out.mX[14] = t32 / 1.0E+8;\r\n  out.mX[15] = t8;\r\n  out.mX[16] = 1.0E-8;\r\n  out.mX[17] = t31;\r\n  out.mX[18] = t31;\r\n  out.mX[19] = t24;\r\n  out.mX[20] = 1.0;\r\n  out.mX[21] = 1.0;\r\n  out.mX[22] = 1.0;\r\n  out.mX[23] = 1.0;\r\n  out.mX[24] = 1.0;\r\n  out.mX[25] = 1.0;\r\n  out.mX[26] = 1.0;\r\n  (void)sys;\r\n  (void)t35;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_dxf.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_DXF_H\r\n#define EQV_627956E1_1_DS_DXF_H        1\r\n\r\n  int32_T EQV_627956e1_1_ds_dxf(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_dxf_p.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_dxf_p.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_dxf_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mDXF_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 1;\r\n  out.mJc[2] = 2;\r\n  out.mJc[3] = 4;\r\n  out.mJc[4] = 7;\r\n  out.mJc[5] = 12;\r\n  out.mJc[6] = 15;\r\n  out.mJc[7] = 16;\r\n  out.mJc[8] = 17;\r\n  out.mJc[9] = 20;\r\n  out.mJc[10] = 21;\r\n  out.mJc[11] = 22;\r\n  out.mJc[12] = 23;\r\n  out.mJc[13] = 24;\r\n  out.mJc[14] = 25;\r\n  out.mJc[15] = 26;\r\n  out.mJc[16] = 27;\r\n  out.mIr[0] = 6;\r\n  out.mIr[1] = 2;\r\n  out.mIr[2] = 5;\r\n  out.mIr[3] = 6;\r\n  out.mIr[4] = 5;\r\n  out.mIr[5] = 6;\r\n  out.mIr[6] = 13;\r\n  out.mIr[7] = 2;\r\n  out.mIr[8] = 5;\r\n  out.mIr[9] = 13;\r\n  out.mIr[10] = 14;\r\n  out.mIr[11] = 15;\r\n  out.mIr[12] = 5;\r\n  out.mIr[13] = 13;\r\n  out.mIr[14] = 15;\r\n  out.mIr[15] = 2;\r\n  out.mIr[16] = 14;\r\n  out.mIr[17] = 5;\r\n  out.mIr[18] = 6;\r\n  out.mIr[19] = 15;\r\n  out.mIr[20] = 12;\r\n  out.mIr[21] = 4;\r\n  out.mIr[22] = 7;\r\n  out.mIr[23] = 8;\r\n  out.mIr[24] = 9;\r\n  out.mIr[25] = 10;\r\n  out.mIr[26] = 11;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_dxf_p.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_DXF_P_H\r\n#define EQV_627956E1_1_DS_DXF_P_H      1\r\n\r\n  int32_T EQV_627956e1_1_ds_dxf_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_external_struct.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef struct__ExternalFunctionStructTag\r\n#define struct__ExternalFunctionStructTag\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_externals.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":""},{"name":"EQV_627956e1_1_ds_f.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_f.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_f(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t15, NeDsMethodOutput *t16)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t1;\r\n  real_T t2;\r\n  real_T t3;\r\n  real_T t4;\r\n  real_T t5;\r\n  int32_T M_idx_0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_14;\r\n  int32_T M_idx_15;\r\n  int32_T M_idx_2;\r\n  int32_T M_idx_3;\r\n  int32_T M_idx_4;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_0 = t15->mM.mX[0];\r\n  M_idx_1 = t15->mM.mX[1];\r\n  M_idx_2 = t15->mM.mX[2];\r\n  M_idx_3 = t15->mM.mX[3];\r\n  M_idx_4 = t15->mM.mX[4];\r\n  M_idx_8 = t15->mM.mX[8];\r\n  M_idx_9 = t15->mM.mX[9];\r\n  M_idx_14 = t15->mM.mX[14];\r\n  M_idx_15 = t15->mM.mX[15];\r\n  U_idx_0 = t15->mU.mX[0];\r\n  U_idx_1 = t15->mU.mX[1];\r\n  X_idx_0 = t15->mX.mX[0];\r\n  X_idx_1 = t15->mX.mX[1];\r\n  X_idx_2 = t15->mX.mX[2];\r\n  X_idx_3 = t15->mX.mX[3];\r\n  X_idx_4 = t15->mX.mX[4];\r\n  X_idx_5 = t15->mX.mX[5];\r\n  X_idx_6 = t15->mX.mX[6];\r\n  X_idx_7 = t15->mX.mX[7];\r\n  X_idx_8 = t15->mX.mX[8];\r\n  X_idx_9 = t15->mX.mX[9];\r\n  X_idx_10 = t15->mX.mX[10];\r\n  X_idx_11 = t15->mX.mX[11];\r\n  X_idx_12 = t15->mX.mX[12];\r\n  X_idx_13 = t15->mX.mX[13];\r\n  X_idx_14 = t15->mX.mX[14];\r\n  X_idx_15 = t15->mX.mX[15];\r\n  D_idx_0 = t15->mD.mX[0];\r\n  out = t16->mF;\r\n  t5 = X_idx_4 + X_idx_5;\r\n  t2 = (-X_idx_2 + -X_idx_4) + -X_idx_5;\r\n  t1 = -X_idx_6 + -X_idx_4;\r\n  t3 = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t4 = (-X_idx_3 + -U_idx_1) + X_idx_8;\r\n  U_idx_1 = (-X_idx_0 + -X_idx_3) + X_idx_8;\r\n  X_idx_1 = ((X_idx_4 * -0.43755555938442742 + X_idx_5 * -0.43755555938442742) +\r\n             -U_idx_0) + X_idx_8;\r\n  if (M_idx_0 != 0) {\r\n    X_idx_6 = t1 - (t3 - 0.59999999819999994) / 0.3;\r\n  } else {\r\n    X_idx_6 = t1 - t3 * 1.0E-8;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t1 = t4 - t2 / 1.0E-6;\r\n  } else if (M_idx_8 != 0) {\r\n    t1 = t4 - t2 * 0.01;\r\n  } else {\r\n    t1 = t4 - t2 / 1.0E-6;\r\n  }\r\n\r\n  if (M_idx_1 != 0) {\r\n    t2 = U_idx_1 - X_idx_2 / 1.0E-6;\r\n  } else if (M_idx_8 != 0) {\r\n    t2 = U_idx_1 - X_idx_2 / 1.0E-6;\r\n  } else if (M_idx_9 != 0) {\r\n    t2 = U_idx_1 - X_idx_2 * 0.01;\r\n  } else {\r\n    t2 = U_idx_1 - X_idx_2 / 1.0E-6;\r\n  }\r\n\r\n  if (D_idx_0 == 1.0) {\r\n    t3 = X_idx_9 - 1.0;\r\n  } else if (D_idx_0 == 2.0) {\r\n    t3 = X_idx_9 - 2.0;\r\n  } else if (D_idx_0 == 3.0) {\r\n    t3 = X_idx_9 - 3.0;\r\n  } else if (M_idx_14 != 0) {\r\n    t3 = X_idx_9 - 1.0;\r\n  } else if (M_idx_15 != 0) {\r\n    t3 = X_idx_9 - 2.0;\r\n  } else {\r\n    t3 = X_idx_9 - 3.0;\r\n  }\r\n\r\n  if (M_idx_2 != 0) {\r\n    t4 = X_idx_3 - t5 * -0.01;\r\n  } else {\r\n    t4 = X_idx_3 - -t5 / 1.0E-8;\r\n  }\r\n\r\n  if (M_idx_3 != 0) {\r\n    t5 = X_idx_7 - X_idx_4 * 0.01;\r\n  } else {\r\n    t5 = X_idx_7 - X_idx_4 / 1.0E-8;\r\n  }\r\n\r\n  if (M_idx_4 != 0) {\r\n    U_idx_1 = X_idx_1 - X_idx_5 * 0.01;\r\n  } else {\r\n    U_idx_1 = X_idx_1 - X_idx_5 / 1.0E-8;\r\n  }\r\n\r\n  out.mX[0] = -0.0;\r\n  out.mX[1] = -0.0;\r\n  out.mX[2] = X_idx_6;\r\n  out.mX[3] = 0.0;\r\n  out.mX[4] = X_idx_10;\r\n  out.mX[5] = t1 / 1.0E+6;\r\n  out.mX[6] = t2 / 1.0E+6;\r\n  out.mX[7] = X_idx_11;\r\n  out.mX[8] = X_idx_12;\r\n  out.mX[9] = X_idx_13;\r\n  out.mX[10] = X_idx_14;\r\n  out.mX[11] = X_idx_15;\r\n  out.mX[12] = t3;\r\n  out.mX[13] = t4 / 1.0E+8;\r\n  out.mX[14] = t5 / 1.0E+8;\r\n  out.mX[15] = U_idx_1 / 1.0E+8;\r\n  (void)sys;\r\n  (void)t16;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_f.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_F_H\r\n#define EQV_627956E1_1_DS_F_H          1\r\n\r\n  int32_T EQV_627956e1_1_ds_f(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_log.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_log.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_log(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t13, NeDsMethodOutput *t14)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  real_T EQV_Capacitor_p_v;\r\n  real_T EQV_Controlled_Voltage_Source1_i;\r\n  real_T EQV_Controlled_Voltage_Source1_p_v;\r\n  real_T EQV_Controlled_Voltage_Source_i;\r\n  real_T EQV_Diode_i;\r\n  real_T EQV_Diode_p_v;\r\n  real_T EQV_Diode_v;\r\n  real_T EQV_SPMT_Switch_v3;\r\n  real_T EQV_Switch2_v;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t1;\r\n  real_T t2;\r\n  real_T t9;\r\n  U_idx_0 = t13->mU.mX[0];\r\n  U_idx_1 = t13->mU.mX[1];\r\n  U_idx_2 = t13->mU.mX[2];\r\n  U_idx_3 = t13->mU.mX[3];\r\n  U_idx_4 = t13->mU.mX[4];\r\n  U_idx_5 = t13->mU.mX[5];\r\n  X_idx_0 = t13->mX.mX[0];\r\n  X_idx_1 = t13->mX.mX[1];\r\n  X_idx_2 = t13->mX.mX[2];\r\n  X_idx_3 = t13->mX.mX[3];\r\n  X_idx_4 = t13->mX.mX[4];\r\n  X_idx_5 = t13->mX.mX[5];\r\n  X_idx_6 = t13->mX.mX[6];\r\n  X_idx_7 = t13->mX.mX[7];\r\n  X_idx_8 = t13->mX.mX[8];\r\n  X_idx_9 = t13->mX.mX[9];\r\n  X_idx_10 = t13->mX.mX[10];\r\n  X_idx_11 = t13->mX.mX[11];\r\n  X_idx_12 = t13->mX.mX[12];\r\n  X_idx_13 = t13->mX.mX[13];\r\n  X_idx_14 = t13->mX.mX[14];\r\n  X_idx_15 = t13->mX.mX[15];\r\n  D_idx_0 = t13->mD.mX[0];\r\n  out = t14->mLOG;\r\n  EQV_Capacitor_p_v = X_idx_0 + X_idx_3;\r\n  EQV_Controlled_Voltage_Source_i = X_idx_4 + X_idx_5;\r\n  EQV_Controlled_Voltage_Source1_i = (-X_idx_2 + -X_idx_4) + -X_idx_5;\r\n  EQV_Controlled_Voltage_Source1_p_v = U_idx_1 + X_idx_3;\r\n  EQV_Diode_i = -X_idx_6 + -X_idx_4;\r\n  t1 = (((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_4 * 0.43755555938442742) +\r\n        X_idx_5 * 0.43755555938442742) + U_idx_0;\r\n  EQV_Diode_p_v = (X_idx_4 * 0.43755555938442742 + X_idx_5 * 0.43755555938442742)\r\n    + U_idx_0;\r\n  EQV_Diode_v = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t2 = ((((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_4 * 0.43755555938442742) +\r\n         X_idx_5 * 0.43755555938442742) + U_idx_0) + X_idx_7;\r\n  t9 = (-X_idx_3 + -U_idx_1) + X_idx_8;\r\n  EQV_SPMT_Switch_v3 = (-X_idx_0 + -X_idx_3) + X_idx_8;\r\n  EQV_Switch2_v = ((X_idx_4 * -0.43755555938442742 + X_idx_5 *\r\n                    -0.43755555938442742) + -U_idx_0) + X_idx_8;\r\n  out.mX[0] = X_idx_2;\r\n  out.mX[1] = X_idx_3;\r\n  out.mX[2] = EQV_Capacitor_p_v;\r\n  out.mX[3] = X_idx_0;\r\n  out.mX[4] = X_idx_0;\r\n  out.mX[5] = X_idx_0 * X_idx_0 * 1.0E-9;\r\n  out.mX[6] = EQV_Controlled_Voltage_Source_i;\r\n  out.mX[7] = U_idx_0;\r\n  out.mX[8] = U_idx_0;\r\n  out.mX[9] = U_idx_0;\r\n  out.mX[10] = EQV_Controlled_Voltage_Source1_i;\r\n  out.mX[11] = X_idx_3;\r\n  out.mX[12] = EQV_Controlled_Voltage_Source1_p_v;\r\n  out.mX[13] = U_idx_1;\r\n  out.mX[14] = U_idx_1;\r\n  out.mX[15] = EQV_Controlled_Voltage_Source_i;\r\n  out.mX[16] = EQV_Controlled_Voltage_Source_i;\r\n  out.mX[17] = EQV_Controlled_Voltage_Source_i;\r\n  out.mX[18] = X_idx_6;\r\n  out.mX[19] = t1;\r\n  out.mX[20] = EQV_Diode_p_v;\r\n  out.mX[21] = EQV_Diode_v;\r\n  out.mX[22] = X_idx_1;\r\n  out.mX[23] = EQV_Diode_i;\r\n  out.mX[24] = X_idx_6;\r\n  out.mX[25] = EQV_Diode_i;\r\n  out.mX[26] = EQV_Diode_i + X_idx_6;\r\n  out.mX[27] = EQV_Diode_v;\r\n  out.mX[28] = t1;\r\n  out.mX[29] = t1;\r\n  out.mX[30] = EQV_Diode_p_v;\r\n  out.mX[31] = EQV_Diode_i * EQV_Diode_v * 0.001 * 1000.0;\r\n  out.mX[32] = EQV_Diode_v;\r\n  out.mX[33] = EQV_Diode_v;\r\n  out.mX[34] = X_idx_4;\r\n  out.mX[35] = t2;\r\n  out.mX[36] = X_idx_8;\r\n  out.mX[37] = X_idx_4 * 100.0;\r\n  out.mX[38] = X_idx_4 * X_idx_4 * 100.0;\r\n  out.mX[39] = EQV_Controlled_Voltage_Source_i;\r\n  out.mX[40] = U_idx_0;\r\n  out.mX[41] = EQV_Diode_p_v;\r\n  out.mX[42] = EQV_Controlled_Voltage_Source_i * 0.43755555938442742;\r\n  out.mX[43] = EQV_Controlled_Voltage_Source_i * EQV_Controlled_Voltage_Source_i\r\n    * 0.43755555938442742;\r\n  out.mX[44] = X_idx_9;\r\n  out.mX[45] = EQV_Controlled_Voltage_Source1_i;\r\n  out.mX[46] = X_idx_2;\r\n  out.mX[47] = X_idx_2 + EQV_Controlled_Voltage_Source1_i;\r\n  out.mX[48] = -(X_idx_10 - X_idx_8);\r\n  out.mX[49] = EQV_Controlled_Voltage_Source1_p_v;\r\n  out.mX[50] = EQV_Capacitor_p_v;\r\n  out.mX[51] = -(X_idx_11 - X_idx_8);\r\n  out.mX[52] = -(X_idx_12 - X_idx_8);\r\n  out.mX[53] = -(X_idx_13 - X_idx_8);\r\n  out.mX[54] = -(X_idx_14 - X_idx_8);\r\n  out.mX[55] = -(X_idx_15 - X_idx_8);\r\n  out.mX[56] = X_idx_8;\r\n  out.mX[57] = (EQV_Controlled_Voltage_Source1_i * t9 + X_idx_2 *\r\n                EQV_SPMT_Switch_v3) * 0.001 * 1000.0;\r\n  out.mX[58] = D_idx_0;\r\n  out.mX[59] = X_idx_10;\r\n  out.mX[60] = t9;\r\n  out.mX[61] = EQV_SPMT_Switch_v3;\r\n  out.mX[62] = X_idx_11;\r\n  out.mX[63] = X_idx_12;\r\n  out.mX[64] = X_idx_13;\r\n  out.mX[65] = X_idx_14;\r\n  out.mX[66] = X_idx_15;\r\n  out.mX[67] = U_idx_4;\r\n  out.mX[68] = U_idx_1;\r\n  out.mX[69] = U_idx_2;\r\n  out.mX[70] = U_idx_3;\r\n  out.mX[71] = U_idx_4;\r\n  out.mX[72] = U_idx_5;\r\n  out.mX[73] = U_idx_0;\r\n  out.mX[74] = -EQV_Controlled_Voltage_Source_i;\r\n  out.mX[75] = X_idx_3;\r\n  out.mX[76] = X_idx_3;\r\n  out.mX[77] = -(EQV_Controlled_Voltage_Source_i * X_idx_3);\r\n  out.mX[78] = U_idx_5;\r\n  out.mX[79] = X_idx_4;\r\n  out.mX[80] = t1;\r\n  out.mX[81] = t2;\r\n  out.mX[82] = X_idx_7;\r\n  out.mX[83] = X_idx_4 * X_idx_7;\r\n  out.mX[84] = U_idx_2;\r\n  out.mX[85] = X_idx_5;\r\n  out.mX[86] = EQV_Diode_p_v;\r\n  out.mX[87] = X_idx_8;\r\n  out.mX[88] = EQV_Switch2_v;\r\n  out.mX[89] = X_idx_5 * EQV_Switch2_v;\r\n  out.mX[90] = U_idx_3;\r\n  out.mX[91] = EQV_Diode_p_v;\r\n  out.mX[92] = EQV_Diode_p_v;\r\n  out.mX[93] = X_idx_8;\r\n  out.mX[94] = X_idx_8;\r\n  out.mX[95] = X_idx_8;\r\n  out.mX[96] = EQV_Diode_p_v;\r\n  (void)sys;\r\n  (void)t14;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_log.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_LOG_H\r\n#define EQV_627956E1_1_DS_LOG_H        1\r\n\r\n  int32_T EQV_627956e1_1_ds_log(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_mode.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_mode.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_mode(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmIntVector out;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T X_idx_1;\r\n  real_T X_idx_6;\r\n  real_T X_idx_9;\r\n  U_idx_2 = t1->mU.mX[2];\r\n  U_idx_3 = t1->mU.mX[3];\r\n  U_idx_4 = t1->mU.mX[4];\r\n  U_idx_5 = t1->mU.mX[5];\r\n  X_idx_1 = t1->mX.mX[1];\r\n  X_idx_6 = t1->mX.mX[6];\r\n  X_idx_9 = t1->mX.mX[9];\r\n  out = t2->mMODE;\r\n  out.mX[0] = (int32_T)(X_idx_6 * 1.0E-6 + X_idx_1 > 0.6);\r\n  out.mX[1] = (int32_T)(X_idx_9 == 1.0);\r\n  out.mX[2] = (int32_T)(U_idx_5 > 0.5);\r\n  out.mX[3] = (int32_T)(U_idx_2 > 0.5);\r\n  out.mX[4] = (int32_T)(U_idx_3 > 0.5);\r\n  out.mX[5] = 1;\r\n  out.mX[6] = 1;\r\n  out.mX[7] = 1;\r\n  out.mX[8] = (int32_T)(X_idx_9 == 2.0);\r\n  out.mX[9] = (int32_T)(X_idx_9 == 3.0);\r\n  out.mX[10] = (int32_T)(X_idx_9 == 4.0);\r\n  out.mX[11] = (int32_T)(X_idx_9 == 5.0);\r\n  out.mX[12] = (int32_T)(X_idx_9 == 6.0);\r\n  out.mX[13] = (int32_T)(X_idx_9 == 7.0);\r\n  out.mX[14] = (int32_T)(U_idx_4 < 1.5);\r\n  out.mX[15] = (int32_T)(U_idx_4 < 2.5);\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_mode.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_MODE_H\r\n#define EQV_627956E1_1_DS_MODE_H       1\r\n\r\n  int32_T EQV_627956e1_1_ds_mode(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_obs_act.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_obs_act.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t13, NeDsMethodOutput *t14)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[106];\r\n  real_T D_idx_0;\r\n  real_T EQV_Capacitor_p_v;\r\n  real_T EQV_Controlled_Voltage_Source1_i;\r\n  real_T EQV_Controlled_Voltage_Source1_p_v;\r\n  real_T EQV_Controlled_Voltage_Source_i;\r\n  real_T EQV_Diode_i;\r\n  real_T EQV_Diode_p_v;\r\n  real_T EQV_Diode_v;\r\n  real_T EQV_SPMT_Switch_v3;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t1;\r\n  real_T t2;\r\n  real_T t9;\r\n  int32_T b;\r\n  U_idx_0 = t13->mU.mX[0];\r\n  U_idx_1 = t13->mU.mX[1];\r\n  U_idx_2 = t13->mU.mX[2];\r\n  U_idx_3 = t13->mU.mX[3];\r\n  U_idx_4 = t13->mU.mX[4];\r\n  U_idx_5 = t13->mU.mX[5];\r\n  X_idx_0 = t13->mX.mX[0];\r\n  X_idx_1 = t13->mX.mX[1];\r\n  X_idx_2 = t13->mX.mX[2];\r\n  X_idx_3 = t13->mX.mX[3];\r\n  X_idx_4 = t13->mX.mX[4];\r\n  X_idx_5 = t13->mX.mX[5];\r\n  X_idx_6 = t13->mX.mX[6];\r\n  X_idx_7 = t13->mX.mX[7];\r\n  X_idx_8 = t13->mX.mX[8];\r\n  X_idx_9 = t13->mX.mX[9];\r\n  X_idx_10 = t13->mX.mX[10];\r\n  X_idx_11 = t13->mX.mX[11];\r\n  X_idx_12 = t13->mX.mX[12];\r\n  X_idx_13 = t13->mX.mX[13];\r\n  X_idx_14 = t13->mX.mX[14];\r\n  X_idx_15 = t13->mX.mX[15];\r\n  D_idx_0 = t13->mD.mX[0];\r\n  out = t14->mOBS_ACT;\r\n  EQV_Capacitor_p_v = X_idx_0 + X_idx_3;\r\n  EQV_Controlled_Voltage_Source_i = X_idx_4 + X_idx_5;\r\n  EQV_Controlled_Voltage_Source1_i = (-X_idx_2 + -X_idx_4) + -X_idx_5;\r\n  EQV_Controlled_Voltage_Source1_p_v = U_idx_1 + X_idx_3;\r\n  EQV_Diode_i = -X_idx_6 + -X_idx_4;\r\n  t1 = (((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_4 * 0.43755555938442742) +\r\n        X_idx_5 * 0.43755555938442742) + U_idx_0;\r\n  EQV_Diode_p_v = (X_idx_4 * 0.43755555938442742 + X_idx_5 * 0.43755555938442742)\r\n    + U_idx_0;\r\n  EQV_Diode_v = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t2 = ((((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_4 * 0.43755555938442742) +\r\n         X_idx_5 * 0.43755555938442742) + U_idx_0) + X_idx_7;\r\n  t9 = (-X_idx_3 + -U_idx_1) + X_idx_8;\r\n  EQV_SPMT_Switch_v3 = (-X_idx_0 + -X_idx_3) + X_idx_8;\r\n  t0[0ULL] = X_idx_2;\r\n  t0[1ULL] = X_idx_3;\r\n  t0[2ULL] = EQV_Capacitor_p_v;\r\n  t0[3ULL] = X_idx_0;\r\n  t0[4ULL] = X_idx_0;\r\n  t0[5ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[6ULL] = 0.0;\r\n  t0[7ULL] = U_idx_0;\r\n  t0[8ULL] = U_idx_0;\r\n  t0[9ULL] = U_idx_0;\r\n  t0[10ULL] = EQV_Controlled_Voltage_Source1_i;\r\n  t0[11ULL] = X_idx_3;\r\n  t0[12ULL] = EQV_Controlled_Voltage_Source1_p_v;\r\n  t0[13ULL] = U_idx_1;\r\n  t0[14ULL] = U_idx_1;\r\n  t0[15ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[16ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[17ULL] = 0.0;\r\n  t0[18ULL] = 0.0;\r\n  t0[19ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[20ULL] = X_idx_6;\r\n  t0[21ULL] = t1;\r\n  t0[22ULL] = EQV_Diode_p_v;\r\n  t0[23ULL] = EQV_Diode_v;\r\n  t0[24ULL] = X_idx_1;\r\n  t0[25ULL] = 298.15;\r\n  t0[26ULL] = 0.0;\r\n  t0[27ULL] = EQV_Diode_i;\r\n  t0[28ULL] = X_idx_6;\r\n  t0[29ULL] = EQV_Diode_i;\r\n  t0[30ULL] = EQV_Diode_i + X_idx_6;\r\n  t0[31ULL] = EQV_Diode_v;\r\n  t0[32ULL] = t1;\r\n  t0[33ULL] = t1;\r\n  t0[34ULL] = EQV_Diode_p_v;\r\n  t0[35ULL] = EQV_Diode_i * EQV_Diode_v * 0.001 * 1000.0;\r\n  t0[36ULL] = EQV_Diode_v;\r\n  t0[37ULL] = EQV_Diode_v;\r\n  t0[38ULL] = 0.0;\r\n  t0[39ULL] = X_idx_4;\r\n  t0[40ULL] = t2;\r\n  t0[41ULL] = X_idx_8;\r\n  t0[42ULL] = X_idx_4 * 100.0;\r\n  t0[43ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[44ULL] = U_idx_0;\r\n  t0[45ULL] = EQV_Diode_p_v;\r\n  t0[46ULL] = EQV_Controlled_Voltage_Source_i * 0.43755555938442742;\r\n  t0[47ULL] = X_idx_9;\r\n  t0[48ULL] = 0.0;\r\n  t0[49ULL] = EQV_Controlled_Voltage_Source1_i;\r\n  t0[50ULL] = X_idx_2;\r\n  t0[51ULL] = 0.0;\r\n  t0[52ULL] = 0.0;\r\n  t0[53ULL] = 0.0;\r\n  t0[54ULL] = 0.0;\r\n  t0[55ULL] = 0.0;\r\n  t0[56ULL] = X_idx_2 + EQV_Controlled_Voltage_Source1_i;\r\n  t0[57ULL] = -(X_idx_10 - X_idx_8);\r\n  t0[58ULL] = EQV_Controlled_Voltage_Source1_p_v;\r\n  t0[59ULL] = EQV_Capacitor_p_v;\r\n  t0[60ULL] = -(X_idx_11 - X_idx_8);\r\n  t0[61ULL] = -(X_idx_12 - X_idx_8);\r\n  t0[62ULL] = -(X_idx_13 - X_idx_8);\r\n  t0[63ULL] = -(X_idx_14 - X_idx_8);\r\n  t0[64ULL] = -(X_idx_15 - X_idx_8);\r\n  t0[65ULL] = X_idx_8;\r\n  t0[66ULL] = (EQV_Controlled_Voltage_Source1_i * t9 + X_idx_2 *\r\n               EQV_SPMT_Switch_v3) * 0.001 * 1000.0;\r\n  t0[67ULL] = D_idx_0;\r\n  t0[68ULL] = X_idx_10;\r\n  t0[69ULL] = t9;\r\n  t0[70ULL] = EQV_SPMT_Switch_v3;\r\n  t0[71ULL] = X_idx_11;\r\n  t0[72ULL] = X_idx_12;\r\n  t0[73ULL] = X_idx_13;\r\n  t0[74ULL] = X_idx_14;\r\n  t0[75ULL] = X_idx_15;\r\n  t0[76ULL] = U_idx_4;\r\n  t0[77ULL] = U_idx_1;\r\n  t0[78ULL] = U_idx_2;\r\n  t0[79ULL] = U_idx_3;\r\n  t0[80ULL] = U_idx_4;\r\n  t0[81ULL] = U_idx_5;\r\n  t0[82ULL] = U_idx_0;\r\n  t0[83ULL] = -EQV_Controlled_Voltage_Source_i;\r\n  t0[84ULL] = 0.0;\r\n  t0[85ULL] = X_idx_3;\r\n  t0[86ULL] = X_idx_3;\r\n  t0[87ULL] = U_idx_5;\r\n  t0[88ULL] = X_idx_4;\r\n  t0[89ULL] = t1;\r\n  t0[90ULL] = t2;\r\n  t0[91ULL] = X_idx_7;\r\n  t0[92ULL] = U_idx_2;\r\n  t0[93ULL] = X_idx_5;\r\n  t0[94ULL] = EQV_Diode_p_v;\r\n  t0[95ULL] = X_idx_8;\r\n  t0[96ULL] = ((X_idx_4 * -0.43755555938442742 + X_idx_5 * -0.43755555938442742)\r\n               + -U_idx_0) + X_idx_8;\r\n  t0[97ULL] = U_idx_3;\r\n  t0[98ULL] = EQV_Diode_p_v;\r\n  t0[99ULL] = 0.0;\r\n  t0[100ULL] = EQV_Diode_p_v;\r\n  t0[101ULL] = X_idx_8;\r\n  t0[102ULL] = 0.0;\r\n  t0[103ULL] = X_idx_8;\r\n  t0[104ULL] = X_idx_8;\r\n  t0[105ULL] = EQV_Diode_p_v;\r\n  for (b = 0; b < 106; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t14;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_obs_act.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_OBS_ACT_H\r\n#define EQV_627956E1_1_DS_OBS_ACT_H    1\r\n\r\n  int32_T EQV_627956e1_1_ds_obs_act(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_obs_all.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_obs_all.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t13, NeDsMethodOutput *t14)\r\n{\r\n  PmRealVector out;\r\n  real_T t0[106];\r\n  real_T D_idx_0;\r\n  real_T EQV_Capacitor_p_v;\r\n  real_T EQV_Controlled_Voltage_Source1_i;\r\n  real_T EQV_Controlled_Voltage_Source1_p_v;\r\n  real_T EQV_Controlled_Voltage_Source_i;\r\n  real_T EQV_Diode_i;\r\n  real_T EQV_Diode_p_v;\r\n  real_T EQV_Diode_v;\r\n  real_T EQV_SPMT_Switch_v3;\r\n  real_T U_idx_0;\r\n  real_T U_idx_1;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T X_idx_0;\r\n  real_T X_idx_1;\r\n  real_T X_idx_10;\r\n  real_T X_idx_11;\r\n  real_T X_idx_12;\r\n  real_T X_idx_13;\r\n  real_T X_idx_14;\r\n  real_T X_idx_15;\r\n  real_T X_idx_2;\r\n  real_T X_idx_3;\r\n  real_T X_idx_4;\r\n  real_T X_idx_5;\r\n  real_T X_idx_6;\r\n  real_T X_idx_7;\r\n  real_T X_idx_8;\r\n  real_T X_idx_9;\r\n  real_T t1;\r\n  real_T t2;\r\n  real_T t9;\r\n  int32_T b;\r\n  U_idx_0 = t13->mU.mX[0];\r\n  U_idx_1 = t13->mU.mX[1];\r\n  U_idx_2 = t13->mU.mX[2];\r\n  U_idx_3 = t13->mU.mX[3];\r\n  U_idx_4 = t13->mU.mX[4];\r\n  U_idx_5 = t13->mU.mX[5];\r\n  X_idx_0 = t13->mX.mX[0];\r\n  X_idx_1 = t13->mX.mX[1];\r\n  X_idx_2 = t13->mX.mX[2];\r\n  X_idx_3 = t13->mX.mX[3];\r\n  X_idx_4 = t13->mX.mX[4];\r\n  X_idx_5 = t13->mX.mX[5];\r\n  X_idx_6 = t13->mX.mX[6];\r\n  X_idx_7 = t13->mX.mX[7];\r\n  X_idx_8 = t13->mX.mX[8];\r\n  X_idx_9 = t13->mX.mX[9];\r\n  X_idx_10 = t13->mX.mX[10];\r\n  X_idx_11 = t13->mX.mX[11];\r\n  X_idx_12 = t13->mX.mX[12];\r\n  X_idx_13 = t13->mX.mX[13];\r\n  X_idx_14 = t13->mX.mX[14];\r\n  X_idx_15 = t13->mX.mX[15];\r\n  D_idx_0 = t13->mD.mX[0];\r\n  out = t14->mOBS_ALL;\r\n  EQV_Capacitor_p_v = X_idx_0 + X_idx_3;\r\n  EQV_Controlled_Voltage_Source_i = X_idx_4 + X_idx_5;\r\n  EQV_Controlled_Voltage_Source1_i = (-X_idx_2 + -X_idx_4) + -X_idx_5;\r\n  EQV_Controlled_Voltage_Source1_p_v = U_idx_1 + X_idx_3;\r\n  EQV_Diode_i = -X_idx_6 + -X_idx_4;\r\n  t1 = (((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_4 * 0.43755555938442742) +\r\n        X_idx_5 * 0.43755555938442742) + U_idx_0;\r\n  EQV_Diode_p_v = (X_idx_4 * 0.43755555938442742 + X_idx_5 * 0.43755555938442742)\r\n    + U_idx_0;\r\n  EQV_Diode_v = X_idx_6 * 1.0E-6 + X_idx_1;\r\n  t2 = ((((-X_idx_1 + X_idx_6 * -1.0E-6) + X_idx_4 * 0.43755555938442742) +\r\n         X_idx_5 * 0.43755555938442742) + U_idx_0) + X_idx_7;\r\n  t9 = (-X_idx_3 + -U_idx_1) + X_idx_8;\r\n  EQV_SPMT_Switch_v3 = (-X_idx_0 + -X_idx_3) + X_idx_8;\r\n  t0[0ULL] = X_idx_2;\r\n  t0[1ULL] = X_idx_3;\r\n  t0[2ULL] = EQV_Capacitor_p_v;\r\n  t0[3ULL] = X_idx_0;\r\n  t0[4ULL] = X_idx_0;\r\n  t0[5ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[6ULL] = 0.0;\r\n  t0[7ULL] = U_idx_0;\r\n  t0[8ULL] = U_idx_0;\r\n  t0[9ULL] = U_idx_0;\r\n  t0[10ULL] = EQV_Controlled_Voltage_Source1_i;\r\n  t0[11ULL] = X_idx_3;\r\n  t0[12ULL] = EQV_Controlled_Voltage_Source1_p_v;\r\n  t0[13ULL] = U_idx_1;\r\n  t0[14ULL] = U_idx_1;\r\n  t0[15ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[16ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[17ULL] = 0.0;\r\n  t0[18ULL] = 0.0;\r\n  t0[19ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[20ULL] = X_idx_6;\r\n  t0[21ULL] = t1;\r\n  t0[22ULL] = EQV_Diode_p_v;\r\n  t0[23ULL] = EQV_Diode_v;\r\n  t0[24ULL] = X_idx_1;\r\n  t0[25ULL] = 298.15;\r\n  t0[26ULL] = 0.0;\r\n  t0[27ULL] = EQV_Diode_i;\r\n  t0[28ULL] = X_idx_6;\r\n  t0[29ULL] = EQV_Diode_i;\r\n  t0[30ULL] = EQV_Diode_i + X_idx_6;\r\n  t0[31ULL] = EQV_Diode_v;\r\n  t0[32ULL] = t1;\r\n  t0[33ULL] = t1;\r\n  t0[34ULL] = EQV_Diode_p_v;\r\n  t0[35ULL] = EQV_Diode_i * EQV_Diode_v * 0.001 * 1000.0;\r\n  t0[36ULL] = EQV_Diode_v;\r\n  t0[37ULL] = EQV_Diode_v;\r\n  t0[38ULL] = 0.0;\r\n  t0[39ULL] = X_idx_4;\r\n  t0[40ULL] = t2;\r\n  t0[41ULL] = X_idx_8;\r\n  t0[42ULL] = X_idx_4 * 100.0;\r\n  t0[43ULL] = EQV_Controlled_Voltage_Source_i;\r\n  t0[44ULL] = U_idx_0;\r\n  t0[45ULL] = EQV_Diode_p_v;\r\n  t0[46ULL] = EQV_Controlled_Voltage_Source_i * 0.43755555938442742;\r\n  t0[47ULL] = X_idx_9;\r\n  t0[48ULL] = 0.0;\r\n  t0[49ULL] = EQV_Controlled_Voltage_Source1_i;\r\n  t0[50ULL] = X_idx_2;\r\n  t0[51ULL] = 0.0;\r\n  t0[52ULL] = 0.0;\r\n  t0[53ULL] = 0.0;\r\n  t0[54ULL] = 0.0;\r\n  t0[55ULL] = 0.0;\r\n  t0[56ULL] = X_idx_2 + EQV_Controlled_Voltage_Source1_i;\r\n  t0[57ULL] = -(X_idx_10 - X_idx_8);\r\n  t0[58ULL] = EQV_Controlled_Voltage_Source1_p_v;\r\n  t0[59ULL] = EQV_Capacitor_p_v;\r\n  t0[60ULL] = -(X_idx_11 - X_idx_8);\r\n  t0[61ULL] = -(X_idx_12 - X_idx_8);\r\n  t0[62ULL] = -(X_idx_13 - X_idx_8);\r\n  t0[63ULL] = -(X_idx_14 - X_idx_8);\r\n  t0[64ULL] = -(X_idx_15 - X_idx_8);\r\n  t0[65ULL] = X_idx_8;\r\n  t0[66ULL] = (EQV_Controlled_Voltage_Source1_i * t9 + X_idx_2 *\r\n               EQV_SPMT_Switch_v3) * 0.001 * 1000.0;\r\n  t0[67ULL] = D_idx_0;\r\n  t0[68ULL] = X_idx_10;\r\n  t0[69ULL] = t9;\r\n  t0[70ULL] = EQV_SPMT_Switch_v3;\r\n  t0[71ULL] = X_idx_11;\r\n  t0[72ULL] = X_idx_12;\r\n  t0[73ULL] = X_idx_13;\r\n  t0[74ULL] = X_idx_14;\r\n  t0[75ULL] = X_idx_15;\r\n  t0[76ULL] = U_idx_4;\r\n  t0[77ULL] = U_idx_1;\r\n  t0[78ULL] = U_idx_2;\r\n  t0[79ULL] = U_idx_3;\r\n  t0[80ULL] = U_idx_4;\r\n  t0[81ULL] = U_idx_5;\r\n  t0[82ULL] = U_idx_0;\r\n  t0[83ULL] = -EQV_Controlled_Voltage_Source_i;\r\n  t0[84ULL] = 0.0;\r\n  t0[85ULL] = X_idx_3;\r\n  t0[86ULL] = X_idx_3;\r\n  t0[87ULL] = U_idx_5;\r\n  t0[88ULL] = X_idx_4;\r\n  t0[89ULL] = t1;\r\n  t0[90ULL] = t2;\r\n  t0[91ULL] = X_idx_7;\r\n  t0[92ULL] = U_idx_2;\r\n  t0[93ULL] = X_idx_5;\r\n  t0[94ULL] = EQV_Diode_p_v;\r\n  t0[95ULL] = X_idx_8;\r\n  t0[96ULL] = ((X_idx_4 * -0.43755555938442742 + X_idx_5 * -0.43755555938442742)\r\n               + -U_idx_0) + X_idx_8;\r\n  t0[97ULL] = U_idx_3;\r\n  t0[98ULL] = EQV_Diode_p_v;\r\n  t0[99ULL] = 0.0;\r\n  t0[100ULL] = EQV_Diode_p_v;\r\n  t0[101ULL] = X_idx_8;\r\n  t0[102ULL] = 0.0;\r\n  t0[103ULL] = X_idx_8;\r\n  t0[104ULL] = X_idx_8;\r\n  t0[105ULL] = EQV_Diode_p_v;\r\n  for (b = 0; b < 106; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t14;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_obs_all.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_OBS_ALL_H\r\n#define EQV_627956E1_1_DS_OBS_ALL_H    1\r\n\r\n  int32_T EQV_627956e1_1_ds_obs_all(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_obs_il.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_obs_il.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  static boolean_T _cg_const_1[106] = { true, true, true, true, true, true, true,\r\n    false, false, false, true, true, false, false, false, true, true, true, true,\r\n    true, true, false, false, true, true, true, true, true, true, true, true,\r\n    true, false, false, false, false, true, true, true, true, false, true, true,\r\n    true, false, false, true, true, true, true, true, true, true, true, true,\r\n    true, true, true, false, true, true, true, true, true, true, true, false,\r\n    false, true, false, true, true, true, true, true, true, false, false, false,\r\n    false, false, false, false, true, true, true, true, false, true, false,\r\n    false, true, false, true, false, true, false, false, false, true, false,\r\n    true, true, true, true, false };\r\n\r\n  PmBoolVector out;\r\n  int32_T b;\r\n  boolean_T t0[106];\r\n  (void)t1;\r\n  out = t2->mOBS_IL;\r\n  for (b = 0; b < 106; b++) {\r\n    t0[b] = _cg_const_1[b];\r\n  }\r\n\r\n  for (b = 0; b < 106; b++) {\r\n    out.mX[b] = t0[b];\r\n  }\r\n\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_obs_il.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_OBS_IL_H\r\n#define EQV_627956E1_1_DS_OBS_IL_H     1\r\n\r\n  int32_T EQV_627956e1_1_ds_obs_il(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_sys_struct.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef struct__NeDynamicSystemTag\r\n#define struct__NeDynamicSystemTag\r\n\r\ntypedef struct _NeDynamicSystemTag {\r\n  NeDynamicSystem mBase;\r\n  int32_T mRefCnt;\r\n  PmAllocator mAlloc;\r\n} _NeDynamicSystem;\r\n\r\n#else\r\n\r\ntypedef struct _NeDynamicSystemTag _NeDynamicSystem;\r\n\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_tdxf_p.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_tdxf_p.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_tdxf_p(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t1, NeDsMethodOutput *t2)\r\n{\r\n  PmSparsityPattern out;\r\n  (void)t1;\r\n  out = t2->mTDXF_P;\r\n  out.mNumCol = 16ULL;\r\n  out.mNumRow = 16ULL;\r\n  out.mJc[0] = 0;\r\n  out.mJc[1] = 2;\r\n  out.mJc[2] = 5;\r\n  out.mJc[3] = 8;\r\n  out.mJc[4] = 11;\r\n  out.mJc[5] = 17;\r\n  out.mJc[6] = 21;\r\n  out.mJc[7] = 24;\r\n  out.mJc[8] = 26;\r\n  out.mJc[9] = 30;\r\n  out.mJc[10] = 39;\r\n  out.mJc[11] = 40;\r\n  out.mJc[12] = 41;\r\n  out.mJc[13] = 42;\r\n  out.mJc[14] = 43;\r\n  out.mJc[15] = 44;\r\n  out.mJc[16] = 45;\r\n  out.mIr[0] = 0;\r\n  out.mIr[1] = 6;\r\n  out.mIr[2] = 1;\r\n  out.mIr[3] = 2;\r\n  out.mIr[4] = 3;\r\n  out.mIr[5] = 0;\r\n  out.mIr[6] = 5;\r\n  out.mIr[7] = 6;\r\n  out.mIr[8] = 5;\r\n  out.mIr[9] = 6;\r\n  out.mIr[10] = 13;\r\n  out.mIr[11] = 2;\r\n  out.mIr[12] = 3;\r\n  out.mIr[13] = 5;\r\n  out.mIr[14] = 13;\r\n  out.mIr[15] = 14;\r\n  out.mIr[16] = 15;\r\n  out.mIr[17] = 3;\r\n  out.mIr[18] = 5;\r\n  out.mIr[19] = 13;\r\n  out.mIr[20] = 15;\r\n  out.mIr[21] = 1;\r\n  out.mIr[22] = 2;\r\n  out.mIr[23] = 3;\r\n  out.mIr[24] = 3;\r\n  out.mIr[25] = 14;\r\n  out.mIr[26] = 3;\r\n  out.mIr[27] = 5;\r\n  out.mIr[28] = 6;\r\n  out.mIr[29] = 15;\r\n  out.mIr[30] = 4;\r\n  out.mIr[31] = 5;\r\n  out.mIr[32] = 6;\r\n  out.mIr[33] = 7;\r\n  out.mIr[34] = 8;\r\n  out.mIr[35] = 9;\r\n  out.mIr[36] = 10;\r\n  out.mIr[37] = 11;\r\n  out.mIr[38] = 12;\r\n  out.mIr[39] = 4;\r\n  out.mIr[40] = 7;\r\n  out.mIr[41] = 8;\r\n  out.mIr[42] = 9;\r\n  out.mIr[43] = 10;\r\n  out.mIr[44] = 11;\r\n  (void)sys;\r\n  (void)t2;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_tdxf_p.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_TDXF_P_H\r\n#define EQV_627956E1_1_DS_TDXF_P_H     1\r\n\r\n  int32_T EQV_627956e1_1_ds_tdxf_p(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_ds_zc.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#include \"ne_ds.h\"\r\n#include \"EQV_627956e1_1_ds_sys_struct.h\"\r\n#include \"EQV_627956e1_1_ds_zc.h\"\r\n#include \"EQV_627956e1_1_ds.h\"\r\n#include \"EQV_627956e1_1_ds_externals.h\"\r\n#include \"EQV_627956e1_1_ds_external_struct.h\"\r\n#include \"ssc_ml_fun.h\"\r\n\r\nint32_T EQV_627956e1_1_ds_zc(const NeDynamicSystem *sys, const\r\n  NeDynamicSystemInput *t3, NeDsMethodOutput *t4)\r\n{\r\n  PmRealVector out;\r\n  real_T D_idx_0;\r\n  real_T U_idx_2;\r\n  real_T U_idx_3;\r\n  real_T U_idx_4;\r\n  real_T U_idx_5;\r\n  real_T X_idx_1;\r\n  real_T X_idx_6;\r\n  real_T X_idx_9;\r\n  real_T t0;\r\n  int32_T M_idx_1;\r\n  int32_T M_idx_10;\r\n  int32_T M_idx_11;\r\n  int32_T M_idx_12;\r\n  int32_T M_idx_14;\r\n  int32_T M_idx_8;\r\n  int32_T M_idx_9;\r\n  M_idx_1 = t3->mM.mX[1];\r\n  M_idx_8 = t3->mM.mX[8];\r\n  M_idx_9 = t3->mM.mX[9];\r\n  M_idx_10 = t3->mM.mX[10];\r\n  M_idx_11 = t3->mM.mX[11];\r\n  M_idx_12 = t3->mM.mX[12];\r\n  M_idx_14 = t3->mM.mX[14];\r\n  U_idx_2 = t3->mU.mX[2];\r\n  U_idx_3 = t3->mU.mX[3];\r\n  U_idx_4 = t3->mU.mX[4];\r\n  U_idx_5 = t3->mU.mX[5];\r\n  X_idx_1 = t3->mX.mX[1];\r\n  X_idx_6 = t3->mX.mX[6];\r\n  X_idx_9 = t3->mX.mX[9];\r\n  D_idx_0 = t3->mD.mX[0];\r\n  out = t4->mZC;\r\n  if ((!(D_idx_0 == 1.0)) && (!(D_idx_0 == 2.0)) && (!(D_idx_0 == 3.0))) {\r\n    t0 = 1.5 - U_idx_4;\r\n  } else {\r\n    t0 = 0.0;\r\n  }\r\n\r\n  if ((!(D_idx_0 == 1.0)) && (!(D_idx_0 == 2.0)) && (!(D_idx_0 == 3.0)) &&\r\n      (M_idx_14 == 0)) {\r\n    U_idx_4 = 2.5 - U_idx_4;\r\n  } else {\r\n    U_idx_4 = 0.0;\r\n  }\r\n\r\n  out.mX[0] = (X_idx_6 * 1.0E-6 + X_idx_1) - 0.6;\r\n  out.mX[1] = (real_T)(X_idx_9 == 1.0);\r\n  out.mX[2] = (real_T)((M_idx_1 == 0) && (X_idx_9 == 2.0));\r\n  out.mX[3] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (X_idx_9 == 3.0));\r\n  out.mX[4] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (X_idx_9 == 4.0));\r\n  out.mX[5] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (M_idx_10 == 0) && (X_idx_9 == 5.0));\r\n  out.mX[6] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (M_idx_10 == 0) && (M_idx_11 == 0) && (X_idx_9 == 6.0));\r\n  out.mX[7] = (real_T)((M_idx_1 == 0) && (M_idx_8 == 0) && (M_idx_9 == 0) &&\r\n                       (M_idx_10 == 0) && (M_idx_11 == 0) && (M_idx_12 == 0) &&\r\n                       (X_idx_9 == 7.0));\r\n  out.mX[8] = t0;\r\n  out.mX[9] = U_idx_4;\r\n  out.mX[10] = 1.0;\r\n  out.mX[11] = 1.0;\r\n  out.mX[12] = 1.0;\r\n  out.mX[13] = U_idx_5 - 0.5;\r\n  out.mX[14] = U_idx_2 - 0.5;\r\n  out.mX[15] = U_idx_3 - 0.5;\r\n  (void)sys;\r\n  (void)t4;\r\n  return 0;\r\n}\r\n"},{"name":"EQV_627956e1_1_ds_zc.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef EQV_627956E1_1_DS_ZC_H\r\n#define EQV_627956E1_1_DS_ZC_H         1\r\n\r\n  int32_T EQV_627956e1_1_ds_zc(const NeDynamicSystem *sys, const\r\n    NeDynamicSystemInput *Q, NeDsMethodOutput *M);\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n"},{"name":"EQV_627956e1_1_gateway.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\r\n * This file is generated for the Simscape network associated with the solver block 'EQV/EQV/Solver Configuration'.\r\n */\r\n\r\n#ifdef MATLAB_MEX_FILE\r\n#include \"tmwtypes.h\"\r\n#else\r\n#include \"rtwtypes.h\"\r\n#endif\r\n\r\n#include \"nesl_rtw.h\"\r\n#include \"EQV_627956e1_1.h\"\r\n#include \"EQV_627956e1_1_gateway.h\"\r\n\r\nvoid EQV_627956e1_1_gateway(void)\r\n{\r\n  NeModelParameters modelparams = { (NeSolverType) 0, 0.001, 0.001, 0.001, 0, 0,\r\n    (NeModifyAbsTol) 0, 0.001, 0, 0, 0, 0, (SscLoggingSetting) 0, 571617938, 1,\r\n  };\r\n\r\n  NeSolverParameters solverparams = { 0, 0, 1, 0, 0, 0.001, 0.001, 1e-09, 0, 0,\r\n    100, 0, 1, (NeIndexReductionMethod) 1, 0, 1e-09, 1, (NeLocalSolverChoice) 0,\r\n    0.2, 1, 3, 2, 0, 2, (NeLinearAlgebraChoice) 0, 0,\r\n    (NeEquationFormulationChoice) 0, 1024, 1, 0.001, (NePartitionStorageMethod)\r\n    0, 1024, (NePartitionMethod) 0, };\r\n\r\n  const NeOutputParameters* outputparameters = NULL;\r\n  NeDae* dae;\r\n  size_t numOutputs = 0;\r\n  int* rtpDaes = NULL;\r\n  int* rtwLogDaes = NULL;\r\n\r\n  {\r\n    static const NeOutputParameters outputparameters_init[] = { { 0, 0, }, { 0,\r\n        1, }, };\r\n\r\n    outputparameters = outputparameters_init;\r\n    numOutputs = sizeof(outputparameters_init)/sizeof(outputparameters_init[0]);\r\n  }\r\n\r\n  EQV_627956e1_1_dae(&dae,\r\n                     &modelparams,\r\n                     &solverparams);\r\n  nesl_register_simulator_group(\"EQV/EQV/Solver Configuration_1\",\r\n    1,\r\n    &dae,\r\n    &solverparams,\r\n    &modelparams,\r\n    numOutputs,\r\n    outputparameters,\r\n    0,\r\n    rtpDaes,\r\n    0,\r\n    rtwLogDaes);\r\n}\r\n"},{"name":"EQV_627956e1_1_gateway.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __EQV_627956e1_1_gateway_h__\r\n#define __EQV_627956e1_1_gateway_h__\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern void EQV_627956e1_1_gateway(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif\r\n"},{"name":"ssc_ml_fun.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\GitHub\\AMS-model\\Batteri256\\Code\\EQV_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n#ifndef SSC_ML_FUN_H\r\n#define SSC_ML_FUN_H                   1\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\n};\r\n\r\n#endif\r\n"}]};